<!DOCTYPE html>
<html>
	<head>
		<title>Leaflet Tile Viewer</title>
		<meta charset="utf-8" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<style>
			body {
				margin: 0;
				padding: 0;
			}

			#map {
				position: absolute;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}

			.leaflet-map-pane, .leaflet-tile, .leaflet-marker-icon, .leaflet-marker-shadow, .leaflet-tile-pane, .leaflet-tile-container, .leaflet-overlay-pane, .leaflet-shadow-pane, .leaflet-marker-pane, .leaflet-popup-pane, .leaflet-overlay-pane svg, .leaflet-zoom-box, .leaflet-image-layer, .leaflet-layer {
				position: absolute;
				left: 0;
				top: 0;
			}
			.leaflet-container {
				overflow: hidden;
				-ms-touch-action: none;
			}
			.leaflet-tile, .leaflet-marker-icon, .leaflet-marker-shadow {
				-webkit-user-select: none;
				-moz-user-select: none;
				user-select: none;
				-webkit-user-drag: none;
			}
			.leaflet-marker-icon, .leaflet-marker-shadow {
				display: block;
			}
			/* map is broken in FF if you have max-width: 100% on tiles */
			.leaflet-container img {
				max-width: none !important;
			}
			/* stupid Android 2 doesn't understand "max-width: none" properly */
			.leaflet-container img.leaflet-image-layer {
				max-width: 15000px !important;
			}
			.leaflet-tile {
				filter: inherit;
				visibility: hidden;
			}
			.leaflet-tile-loaded {
				visibility: inherit;
			}
			.leaflet-zoom-box {
				width: 0;
				height: 0;
			}
			/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */
			.leaflet-overlay-pane svg {
				-moz-user-select: none;
			}

			.leaflet-tile-pane {
				z-index: 2;
			}
			.leaflet-objects-pane {
				z-index: 3;
			}
			.leaflet-overlay-pane {
				z-index: 4;
			}
			.leaflet-shadow-pane {
				z-index: 5;
			}
			.leaflet-marker-pane {
				z-index: 6;
			}
			.leaflet-popup-pane {
				z-index: 7;
			}

			.leaflet-vml-shape {
				width: 1px;
				height: 1px;
			}
			.lvml {
				behavior: url(#default#VML);
				display: inline-block;
				position: absolute;
			}

			/* control positioning */

			.leaflet-control {
				position: relative;
				z-index: 7;
				pointer-events: auto;
			}
			.leaflet-top, .leaflet-bottom {
				position: absolute;
				z-index: 1000;
				pointer-events: none;
			}
			.leaflet-top {
				top: 0;
			}
			.leaflet-right {
				right: 0;
			}
			.leaflet-bottom {
				bottom: 0;
			}
			.leaflet-left {
				left: 0;
			}
			.leaflet-control {
				float: left;
				clear: both;
			}
			.leaflet-right .leaflet-control {
				float: right;
			}
			.leaflet-top .leaflet-control {
				margin-top: 10px;
			}
			.leaflet-bottom .leaflet-control {
				margin-bottom: 10px;
			}
			.leaflet-left .leaflet-control {
				margin-left: 10px;
			}
			.leaflet-right .leaflet-control {
				margin-right: 10px;
			}

			/* zoom and fade animations */

			.leaflet-fade-anim .leaflet-tile, .leaflet-fade-anim .leaflet-popup {
				opacity: 0;
				-webkit-transition: opacity 0.2s linear;
				-moz-transition: opacity 0.2s linear;
				-o-transition: opacity 0.2s linear;
				transition: opacity 0.2s linear;
			}
			.leaflet-fade-anim .leaflet-tile-loaded, .leaflet-fade-anim .leaflet-map-pane .leaflet-popup {
				opacity: 1;
			}

			.leaflet-zoom-anim .leaflet-zoom-animated {
				-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);
				-moz-transition: -moz-transform 0.25s cubic-bezier(0,0,0.25,1);
				-o-transition: -o-transform 0.25s cubic-bezier(0,0,0.25,1);
				transition: transform 0.25s cubic-bezier(0,0,0.25,1);
			}
			.leaflet-zoom-anim .leaflet-tile, .leaflet-pan-anim .leaflet-tile, .leaflet-touching .leaflet-zoom-animated {
				-webkit-transition: none;
				-moz-transition: none;
				-o-transition: none;
				transition: none;
			}

			.leaflet-zoom-anim .leaflet-zoom-hide {
				visibility: hidden;
			}

			/* cursors */

			.leaflet-clickable {
				cursor: pointer;
			}
			.leaflet-container {
				cursor: -webkit-grab;
				cursor: -moz-grab;
			}
			.leaflet-popup-pane, .leaflet-control {
				cursor: auto;
			}
			.leaflet-dragging .leaflet-container, .leaflet-dragging .leaflet-clickable {
				cursor: move;
				cursor: -webkit-grabbing;
				cursor: -moz-grabbing;
			}

			/* visual tweaks */

			.leaflet-container {
				background: #ddd;
				outline: 0;
			}
			.leaflet-container a {
				color: #0078A8;
			}
			.leaflet-container a.leaflet-active {
				outline: 2px solid orange;
			}
			.leaflet-zoom-box {
				border: 2px dotted #38f;
				background: rgba(255,255,255,0.5);
			}

			/* general typography */
			.leaflet-container {
				font: 12px/1.5 "Helvetica Neue", Arial, Helvetica, sans-serif;
			}

			/* general toolbar styles */

			.leaflet-bar {
				box-shadow: 0 1px 5px rgba(0,0,0,0.65);
				border-radius: 4px;
			}
			.leaflet-bar a, .leaflet-bar a:hover {
				background-color: #fff;
				border-bottom: 1px solid #ccc;
				width: 26px;
				height: 26px;
				line-height: 26px;
				display: block;
				text-align: center;
				text-decoration: none;
				color: black;
			}
			.leaflet-bar a, .leaflet-control-layers-toggle {
				background-position: 50% 50%;
				background-repeat: no-repeat;
				display: block;
			}
			.leaflet-bar a:hover {
				background-color: #f4f4f4;
			}
			.leaflet-bar a:first-child {
				border-top-left-radius: 4px;
				border-top-right-radius: 4px;
			}
			.leaflet-bar a:last-child {
				border-bottom-left-radius: 4px;
				border-bottom-right-radius: 4px;
				border-bottom: none;
			}
			.leaflet-bar a.leaflet-disabled {
				cursor: default;
				background-color: #f4f4f4;
				color: #bbb;
			}

			.leaflet-touch .leaflet-bar a {
				width: 30px;
				height: 30px;
				line-height: 30px;
			}

			/* zoom control */

			.leaflet-control-zoom-in, .leaflet-control-zoom-out {
				font: bold 18px 'Lucida Console', Monaco, monospace;
				text-indent: 1px;
			}
			.leaflet-control-zoom-out {
				font-size: 20px;
			}

			.leaflet-touch .leaflet-control-zoom-in {
				font-size: 22px;
			}
			.leaflet-touch .leaflet-control-zoom-out {
				font-size: 24px;
			}

			/* layers control */

			.leaflet-control-layers {
				box-shadow: 0 1px 5px rgba(0,0,0,0.4);
				background: #fff;
				border-radius: 5px;
			}
			.leaflet-control-layers-toggle {
				background-image: url(images/layers.png);
				width: 36px;
				height: 36px;
			}
			.leaflet-retina .leaflet-control-layers-toggle {
				background-image: url(images/layers-2x.png);
				background-size: 26px 26px;
			}
			.leaflet-touch .leaflet-control-layers-toggle {
				width: 44px;
				height: 44px;
			}
			.leaflet-control-layers .leaflet-control-layers-list, .leaflet-control-layers-expanded .leaflet-control-layers-toggle {
				display: none;
			}
			.leaflet-control-layers-expanded .leaflet-control-layers-list {
				display: block;
				position: relative;
			}
			.leaflet-control-layers-expanded {
				padding: 6px 10px 6px 6px;
				color: #333;
				background: #fff;
			}
			.leaflet-control-layers-selector {
				margin-top: 2px;
				position: relative;
				top: 1px;
			}
			.leaflet-control-layers label {
				display: block;
			}
			.leaflet-control-layers-separator {
				height: 0;
				border-top: 1px solid #ddd;
				margin: 5px -10px 5px -6px;
			}

			/* attribution and scale controls */

			.leaflet-container .leaflet-control-attribution {
				background: #fff;
				background: rgba(255, 255, 255, 0.7);
				margin: 0;
			}
			.leaflet-control-attribution, .leaflet-control-scale-line {
				padding: 0 5px;
				color: #333;
			}
			.leaflet-control-attribution a {
				text-decoration: none;
			}
			.leaflet-control-attribution a:hover {
				text-decoration: underline;
			}
			.leaflet-container .leaflet-control-attribution, .leaflet-container .leaflet-control-scale {
				font-size: 11px;
			}
			.leaflet-left .leaflet-control-scale {
				margin-left: 5px;
			}
			.leaflet-bottom .leaflet-control-scale {
				margin-bottom: 5px;
			}
			.leaflet-control-scale-line {
				border: 2px solid #777;
				border-top: none;
				line-height: 1.1;
				padding: 2px 5px 1px;
				font-size: 11px;
				white-space: nowrap;
				overflow: hidden;
				-moz-box-sizing: content-box;
				box-sizing: content-box;
				background: #fff;
				background: rgba(255, 255, 255, 0.5);
			}
			.leaflet-control-scale-line:not(:first-child) {
			border-top: 2px solid #777;
			border-bottom: none;
			margin-top: -2px;
			}
			.leaflet-control-scale-line
			:not(:first-child):not(:last-child) {
				border-bottom: 2px solid #777;
			}

			.leaflet-touch .leaflet-control-attribution, .leaflet-touch .leaflet-control-layers, .leaflet-touch .leaflet-bar {
				box-shadow: none;
			}
			.leaflet-touch .leaflet-control-layers, .leaflet-touch .leaflet-bar {
				border: 2px solid rgba(0,0,0,0.2);
				background-clip: padding-box;
			}

			/* popup */

			.leaflet-popup {
				position: absolute;
				text-align: center;
			}
			.leaflet-popup-content-wrapper {
				padding: 1px;
				text-align: left;
				border-radius: 12px;
			}
			.leaflet-popup-content {
				margin: 13px 19px;
				line-height: 1.4;
			}
			.leaflet-popup-content p {
				margin: 18px 0;
			}
			.leaflet-popup-tip-container {
				margin: 0 auto;
				width: 40px;
				height: 20px;
				position: relative;
				overflow: hidden;
			}
			.leaflet-popup-tip {
				width: 17px;
				height: 17px;
				padding: 1px;
				margin: -10px auto 0;
				-webkit-transform: rotate(45deg);
				-moz-transform: rotate(45deg);
				-ms-transform: rotate(45deg);
				-o-transform: rotate(45deg);
				transform: rotate(45deg);
			}
			.leaflet-popup-content-wrapper, .leaflet-popup-tip {
				background: white;
				box-shadow: 0 3px 14px rgba(0,0,0,0.4);
			}
			.leaflet-container a.leaflet-popup-close-button {
				position: absolute;
				top: 0;
				right: 0;
				padding: 4px 4px 0 0;
				text-align: center;
				width: 18px;
				height: 14px;
				font: 16px/14px Tahoma, Verdana, sans-serif;
				color: #c3c3c3;
				text-decoration: none;
				font-weight: bold;
				background: transparent;
			}
			.leaflet-container a.leaflet-popup-close-button:hover {
				color: #999;
			}
			.leaflet-popup-scrolled {
				overflow: auto;
				border-bottom: 1px solid #ddd;
				border-top: 1px solid #ddd;
			}

			.leaflet-oldie .leaflet-popup-content-wrapper {
				zoom: 1;
			}
			.leaflet-oldie .leaflet-popup-tip {
				width: 24px;
				margin: 0 auto;
				-ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";
				filter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);
			}
			.leaflet-oldie .leaflet-popup-tip-container {
				margin-top: -1px;
			}

			.leaflet-oldie .leaflet-control-zoom, .leaflet-oldie .leaflet-control-layers, .leaflet-oldie .leaflet-popup-content-wrapper, .leaflet-oldie .leaflet-popup-tip {
				border: 1px solid #999;
			}

			.leaflet-div-icon {
				background: #fff;
				border: 1px solid #666;
			}

			/***
			 Spectrum Colorpicker v1.5.1
			 https://github.com/bgrins/spectrum
			 Author: Brian Grinstead
			 License: MIT
			 ***/

			.sp-container {
				position: absolute;
				top: 0;
				left: 0;
				display: inline-block;
				*display: inline;
				*zoom: 1;
				/* https://github.com/bgrins/spectrum/issues/40 */
				z-index: 9999994;
				overflow: hidden;
			}
			.sp-container.sp-flat {
				position: relative;
			}

			/* Fix for * { box-sizing: border-box; } */
			.sp-container, .sp-container * {
				-webkit-box-sizing: content-box;
				-moz-box-sizing: content-box;
				box-sizing: content-box;
			}

			/* http://ansciath.tumblr.com/post/7347495869/css-aspect-ratio */
			.sp-top {
				position: relative;
				width: 100%;
				display: inline-block;
			}
			.sp-top-inner {
				position: absolute;
				top: 0;
				left: 0;
				bottom: 0;
				right: 0;
			}
			.sp-color {
				position: absolute;
				top: 0;
				left: 0;
				bottom: 0;
				right: 20%;
			}
			.sp-hue {
				position: absolute;
				top: 0;
				right: 0;
				bottom: 0;
				left: 84%;
				height: 100%;
			}

			.sp-clear-enabled .sp-hue {
				top: 33px;
				height: 77.5%;
			}

			.sp-fill {
				padding-top: 80%;
			}
			.sp-sat, .sp-val {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
			}

			.sp-alpha-enabled .sp-top {
				margin-bottom: 18px;
			}
			.sp-alpha-enabled .sp-alpha {
				display: block;
			}
			.sp-alpha-handle {
				position: absolute;
				top: -4px;
				bottom: -4px;
				width: 6px;
				left: 50%;
				cursor: pointer;
				border: 1px solid black;
				background: white;
				opacity: .8;
			}
			.sp-alpha {
				display: none;
				position: absolute;
				bottom: -14px;
				right: 0;
				left: 0;
				height: 8px;
			}
			.sp-alpha-inner {
				border: solid 1px #333;
			}

			.sp-clear {
				display: none;
			}

			.sp-clear.sp-clear-display {
				background-position: center;
			}

			.sp-clear-enabled .sp-clear {
				display: block;
				position: absolute;
				top: 0px;
				right: 0;
				bottom: 0;
				left: 84%;
				height: 28px;
			}

			/* Don't allow text selection */
			.sp-container, .sp-replacer, .sp-preview, .sp-dragger, .sp-slider, .sp-alpha, .sp-clear, .sp-alpha-handle, .sp-container.sp-dragging .sp-input, .sp-container button {
				-webkit-user-select: none;
				-moz-user-select: -moz-none;
				-o-user-select: none;
				user-select: none;
			}

			.sp-container.sp-input-disabled .sp-input-container {
				display: none;
			}
			.sp-container.sp-buttons-disabled .sp-button-container {
				display: none;
			}
			.sp-container.sp-palette-buttons-disabled .sp-palette-button-container {
				display: none;
			}
			.sp-palette-only .sp-picker-container {
				display: none;
			}
			.sp-palette-disabled .sp-palette-container {
				display: none;
			}

			.sp-initial-disabled .sp-initial {
				display: none;
			}

			/* Gradients for hue, saturation and value instead of images.  Not pretty... but it works */
			.sp-sat {
				background-image: -webkit-gradient(linear,  0 0, 100% 0, from(#FFF), to(rgba(204, 154, 129, 0)));
				background-image: -webkit-linear-gradient(left, #FFF, rgba(204, 154, 129, 0));
				background-image: -moz-linear-gradient(left, #fff, rgba(204, 154, 129, 0));
				background-image: -o-linear-gradient(left, #fff, rgba(204, 154, 129, 0));
				background-image: -ms-linear-gradient(left, #fff, rgba(204, 154, 129, 0));
				background-image: linear-gradient(to right, #fff, rgba(204, 154, 129, 0));
				-ms-filter: "progid:DXImageTransform.Microsoft.gradient(GradientType = 1, startColorstr=#FFFFFFFF, endColorstr=#00CC9A81)";
				filter: progid:DXImageTransform.Microsoft.gradient(GradientType = 1, startColorstr='#FFFFFFFF', endColorstr='#00CC9A81');
			}
			.sp-val {
				background-image: -webkit-gradient(linear, 0 100%, 0 0, from(#000000), to(rgba(204, 154, 129, 0)));
				background-image: -webkit-linear-gradient(bottom, #000000, rgba(204, 154, 129, 0));
				background-image: -moz-linear-gradient(bottom, #000, rgba(204, 154, 129, 0));
				background-image: -o-linear-gradient(bottom, #000, rgba(204, 154, 129, 0));
				background-image: -ms-linear-gradient(bottom, #000, rgba(204, 154, 129, 0));
				background-image: linear-gradient(to top, #000, rgba(204, 154, 129, 0));
				-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#00CC9A81, endColorstr=#FF000000)";
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00CC9A81', endColorstr='#FF000000');
			}

			.sp-hue {
				background: -moz-linear-gradient(top, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);
				background: -ms-linear-gradient(top, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);
				background: -o-linear-gradient(top, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);
				background: -webkit-gradient(linear, left top, left bottom, from(#ff0000), color-stop(0.17, #ffff00), color-stop(0.33, #00ff00), color-stop(0.5, #00ffff), color-stop(0.67, #0000ff), color-stop(0.83, #ff00ff), to(#ff0000));
				background: -webkit-linear-gradient(top, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);
				background: linear-gradient(to bottom, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);
			}

			/* IE filters do not support multiple color stops.
			 Generate 6 divs, line them up, and do two color gradients for each.
			 Yes, really.
			 */
			.sp-1 {
				height: 17%;
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0000', endColorstr='#ffff00');
			}
			.sp-2 {
				height: 16%;
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffff00', endColorstr='#00ff00');
			}
			.sp-3 {
				height: 17%;
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00ff00', endColorstr='#00ffff');
			}
			.sp-4 {
				height: 17%;
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#00ffff', endColorstr='#0000ff');
			}
			.sp-5 {
				height: 16%;
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#0000ff', endColorstr='#ff00ff');
			}
			.sp-6 {
				height: 17%;
				filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff00ff', endColorstr='#ff0000');
			}

			.sp-hidden {
				display: none !important;
			}

			/* Clearfix hack */
			.sp-cf:before, .sp-cf:after {
				content: "";
				display: table;
			}
			.sp-cf:after {
				clear: both;
			}
			.sp-cf {
				*zoom: 1;
			}

			/* Mobile devices, make hue slider bigger so it is easier to slide */
			@media (max-device-width: 480px) {
				.sp-color {
					right: 40%;
				}
				.sp-hue {
					left: 63%;
				}
				.sp-fill {
					padding-top: 60%;
				}
			}
			.sp-dragger {
				border-radius: 5px;
				height: 5px;
				width: 5px;
				border: 1px solid #fff;
				background: #000;
				cursor: pointer;
				position: absolute;
				top: 0;
				left: 0;
			}
			.sp-slider {
				position: absolute;
				top: 0;
				cursor: pointer;
				height: 3px;
				left: -1px;
				right: -1px;
				border: 1px solid #000;
				background: white;
				opacity: .8;
			}

			/*
			 Theme authors:
			 Here are the basic themeable display options (colors, fonts, global widths).
			 See http://bgrins.github.io/spectrum/themes/ for instructions.
			 */

			.sp-container {
				border-radius: 0;
				background-color: #ECECEC;
				border: solid 1px #f0c49B;
				padding: 0;
			}
			.sp-container, .sp-container button, .sp-container input, .sp-color, .sp-hue, .sp-clear {
				font: normal 12px "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", Geneva, Verdana, sans-serif;
				-webkit-box-sizing: border-box;
				-moz-box-sizing: border-box;
				-ms-box-sizing: border-box;
				box-sizing: border-box;
			}
			.sp-top {
				margin-bottom: 3px;
			}
			.sp-color, .sp-hue, .sp-clear {
				border: solid 1px #666;
			}

			/* Input */
			.sp-input-container {
				float: right;
				width: 100px;
				margin-bottom: 4px;
			}
			.sp-initial-disabled  .sp-input-container {
				width: 100%;
			}
			.sp-input {
				font-size: 12px !important;
				border: 1px inset;
				padding: 4px 5px;
				margin: 0;
				width: 100%;
				background: transparent;
				border-radius: 3px;
				color: #222;
			}
			.sp-input:focus {
				border: 1px solid orange;
			}
			.sp-input.sp-validation-error {
				border: 1px solid red;
				background: #fdd;
			}
			.sp-picker-container, .sp-palette-container {
				float: left;
				position: relative;
				padding: 10px;
				padding-bottom: 300px;
				margin-bottom: -290px;
			}
			.sp-picker-container {
				width: 172px;
				border-left: solid 1px #fff;
			}

			/* Palettes */
			.sp-palette-container {
				border-right: solid 1px #ccc;
			}

			.sp-palette-only .sp-palette-container {
				border: 0;
			}

			.sp-palette .sp-thumb-el {
				display: block;
				position: relative;
				float: left;
				width: 24px;
				height: 15px;
				margin: 3px;
				cursor: pointer;
				border: solid 2px transparent;
			}
			.sp-palette .sp-thumb-el:hover, .sp-palette .sp-thumb-el.sp-thumb-active {
				border-color: orange;
			}
			.sp-thumb-el {
				position: relative;
			}

			/* Initial */
			.sp-initial {
				float: left;
				border: solid 1px #333;
			}
			.sp-initial span {
				width: 30px;
				height: 25px;
				border: none;
				display: block;
				float: left;
				margin: 0;
			}

			.sp-initial .sp-clear-display {
				background-position: center;
			}

			/* Buttons */
			.sp-palette-button-container, .sp-button-container {
				float: right;
			}

			/* Replacer (the little preview div that shows up instead of the <input>) */
			.sp-replacer {
				margin: 0;
				overflow: hidden;
				cursor: pointer;
				padding: 4px;
				display: inline-block;
				*zoom: 1;
				*display: inline;
				border: solid 1px #91765d;
				background: #eee;
				color: #333;
				vertical-align: middle;
			}
			.sp-replacer:hover, .sp-replacer.sp-active {
				border-color: #F0C49B;
				color: #111;
			}
			.sp-replacer.sp-disabled {
				cursor: default;
				border-color: silver;
				color: silver;
			}
			.sp-dd {
				padding: 2px 0;
				height: 16px;
				line-height: 16px;
				float: left;
				font-size: 10px;
			}
			.sp-preview {
				position: relative;
				width: 25px;
				height: 20px;
				border: solid 1px #222;
				margin-right: 5px;
				float: left;
				z-index: 0;
			}

			.sp-palette {
				*width: 220px;
				max-width: 220px;
			}
			.sp-palette .sp-thumb-el {
				width: 16px;
				height: 16px;
				margin: 2px 1px;
				border: solid 1px #d0d0d0;
			}

			.sp-container {
				padding-bottom: 0;
			}

			/* Buttons: http://hellohappy.org/css3-buttons/ */
			.sp-container button {
				background-color: #eeeeee;
				background-image: -webkit-linear-gradient(top, #eeeeee, #cccccc);
				background-image: -moz-linear-gradient(top, #eeeeee, #cccccc);
				background-image: -ms-linear-gradient(top, #eeeeee, #cccccc);
				background-image: -o-linear-gradient(top, #eeeeee, #cccccc);
				background-image: linear-gradient(to bottom, #eeeeee, #cccccc);
				border: 1px solid #ccc;
				border-bottom: 1px solid #bbb;
				border-radius: 3px;
				color: #333;
				font-size: 14px;
				line-height: 1;
				padding: 5px 4px;
				text-align: center;
				text-shadow: 0 1px 0 #eee;
				vertical-align: middle;
			}
			.sp-container button:hover {
				background-color: #dddddd;
				background-image: -webkit-linear-gradient(top, #dddddd, #bbbbbb);
				background-image: -moz-linear-gradient(top, #dddddd, #bbbbbb);
				background-image: -ms-linear-gradient(top, #dddddd, #bbbbbb);
				background-image: -o-linear-gradient(top, #dddddd, #bbbbbb);
				background-image: linear-gradient(to bottom, #dddddd, #bbbbbb);
				border: 1px solid #bbb;
				border-bottom: 1px solid #999;
				cursor: pointer;
				text-shadow: 0 1px 0 #ddd;
			}
			.sp-container button:active {
				border: 1px solid #aaa;
				border-bottom: 1px solid #888;
				-webkit-box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;
				-moz-box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;
				-ms-box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;
				-o-box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;
				box-shadow: inset 0 0 5px 2px #aaaaaa, 0 1px 0 0 #eeeeee;
			}
			.sp-cancel {
				font-size: 11px;
				color: #d93f3f !important;
				margin: 0;
				padding: 2px;
				margin-right: 5px;
				vertical-align: middle;
				text-decoration: none;
			}
			.sp-cancel:hover {
				color: #d93f3f !important;
				text-decoration: underline;
			}

			.sp-palette span:hover, .sp-palette span.sp-thumb-active {
				border-color: #000;
			}

			.sp-preview, .sp-alpha, .sp-thumb-el {
				position: relative;
				background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);
			}
			.sp-preview-inner, .sp-alpha-inner, .sp-thumb-inner {
				display: block;
				position: absolute;
				top: 0;
				left: 0;
				bottom: 0;
				right: 0;
			}

			.sp-palette .sp-thumb-inner {
				background-position: 50% 50%;
				background-repeat: no-repeat;
			}

			.sp-palette .sp-thumb-light.sp-thumb-active .sp-thumb-inner {
				background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIVJREFUeNpiYBhsgJFMffxAXABlN5JruT4Q3wfi/0DsT64h8UD8HmpIPCWG/KemIfOJCUB+Aoacx6EGBZyHBqI+WsDCwuQ9mhxeg2A210Ntfo8klk9sOMijaURm7yc1UP2RNCMbKE9ODK1HM6iegYLkfx8pligC9lCD7KmRof0ZhjQACDAAceovrtpVBRkAAAAASUVORK5CYII=);
			}

			.sp-palette .sp-thumb-dark.sp-thumb-active .sp-thumb-inner {
				background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjEwMPRyoQAAAMdJREFUOE+tkgsNwzAMRMugEAahEAahEAZhEAqlEAZhEAohEAYh81X2dIm8fKpEspLGvudPOsUYpxE2BIJCroJmEW9qJ+MKaBFhEMNabSy9oIcIPwrB+afvAUFoK4H0tMaQ3XtlrggDhOVVMuT4E5MMG0FBbCEYzjYT7OxLEvIHQLY2zWwQ3D+9luyOQTfKDiFD3iUIfPk8VqrKjgAiSfGFPecrg6HN6m/iBcwiDAo7WiBeawa+Kwh7tZoSCGLMqwlSAzVDhoK+6vH4G0P5wdkAAAAASUVORK5CYII=);
			}

			.sp-clear-display {
				background-repeat: no-repeat;
				background-position: center;
				background-image: url(data:image/gif;base64,R0lGODlhFAAUAPcAAAAAAJmZmZ2dnZ6enqKioqOjo6SkpKWlpaampqenp6ioqKmpqaqqqqurq/Hx8fLy8vT09PX19ff39/j4+Pn5+fr6+vv7+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAP8ALAAAAAAUABQAAAihAP9FoPCvoMGDBy08+EdhQAIJCCMybCDAAYUEARBAlFiQQoMABQhKUJBxY0SPICEYHBnggEmDKAuoPMjS5cGYMxHW3IiT478JJA8M/CjTZ0GgLRekNGpwAsYABHIypcAgQMsITDtWJYBR6NSqMico9cqR6tKfY7GeBCuVwlipDNmefAtTrkSzB1RaIAoXodsABiZAEFB06gIBWC1mLVgBa0AAOw==);
			}
		</style>

	</head>
	<body>

		<div id="map"></div>

		<!-- leaflet -->
		<script>
			/*
			 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
			 (c) 2010-2013, Vladimir Agafonkin
			 (c) 2010-2011, CloudMade
			 */! function(t, e, i) {
				var n = t.L,
				    o = {};
				o.version = "0.7.1", "object" == typeof module && "object" == typeof module.exports ? module.exports = o : "function" == typeof define && define.amd && define(o), o.noConflict = function() {
					return t.L = n, this
				}, t.L =
				o, o.Util = {
					extend : function(t) {
						var e,
						    i,
						    n,
						    o,
						    s = Array.prototype.slice.call(arguments, 1);
						for ( i = 0,
						n = s.length; n > i; i++) {
							o = s[i] || {};
							for (e in o)o.hasOwnProperty(e) && (t[e] = o[e])
						}
						return t
					},
					bind : function(t, e) {
						var i = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
						return function() {
							return t.apply(e, i || arguments)
						}
					},
					stamp : function() {
						var t = 0,
						    e = "_leaflet_id";
						return function(i) {
							return i[e] = i[e] || ++t, i[e]
						}
					}(),
					invokeEach : function(t, e, i) {
						var n,
						    o;
						if ("object" == typeof t) {
							o = Array.prototype.slice.call(arguments, 3);
							for (n in t)
							e.apply(i, [n, t[n]].concat(o));
							return !0
						}
						return !1
					},
					limitExecByInterval : function(t, e, i) {
						var n,
						    o;
						return function s() {
							var a = arguments;
							return n ? ( o = !0,
							void 0) : ( n = !0, setTimeout(function() {
								n = !1, o && (s.apply(i, a),
								o = !1)
							}, e), t.apply(i, a),
							void 0)
						}
					},
					falseFn : function() {
						return !1
					},
					formatNum : function(t, e) {
						var i = Math.pow(10, e || 5);
						return Math.round(t * i) / i
					},
					trim : function(t) {
						return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
					},
					splitWords : function(t) {
						return o.Util.trim(t).split(/\s+/)
					},
					setOptions : function(t, e) {
						return t.options = o.extend({}, t.options, e), t.options
					},
					getParamString : function(t, e, i) {
						var n = [];
						for (var o in t)
						n.push(encodeURIComponent( i ? o.toUpperCase() : o) + "=" + encodeURIComponent(t[o]));
						return (e && -1 !== e.indexOf("?") ? "&" : "?") + n.join("&")
					},
					template : function(t, e) {
						return t.replace(/\{ *([\w_]+) *\}/g, function(t, n) {
							var o = e[n];
							if (o === i)
								throw new Error("No value provided for variable " + t);
							return "function" == typeof o && ( o = o(e)), o
						})
					},
					isArray : Array.isArray ||
					function(t) {
						return "[object Array]" === Object.prototype.toString.call(t)
					},
					emptyImageUrl : "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
				}, function() {
					function e(e) {
						var i,
						    n,
						    o = ["webkit", "moz", "o", "ms"];
						for ( i = 0; i < o.length && !n; i++)
							n = t[o[i] + e];
						return n
					}

					function i(e) {
						var i = +new Date,
						    o = Math.max(0, 16 - (i - n));
						return n = i + o, t.setTimeout(e, o)
					}

					var n = 0,
					    s = t.requestAnimationFrame || e("RequestAnimationFrame") || i,
					    a = t.cancelAnimationFrame || e("CancelAnimationFrame") || e("CancelRequestAnimationFrame") ||
					function(e) {
						t.clearTimeout(e)
					};
					o.Util.requestAnimFrame = function(e, n, a, r) {
						return e = o.bind(e, n), a && s === i ? (e(),
						void 0) : s.call(t, e, r)
					}, o.Util.cancelAnimFrame = function(e) {
						e && a.call(t, e)
					}
				}(), o.extend = o.Util.extend, o.bind = o.Util.bind, o.stamp = o.Util.stamp, o.setOptions = o.Util.setOptions, o.Class = function() {
				}, o.Class.extend = function(t) {
					var e = function() {
						this.initialize && this.initialize.apply(this, arguments), this._initHooks && this.callInitHooks()
					},
					    i = function() {
					};
					i.prototype = this.prototype;
					var n = new i;
					n.constructor = e, e.prototype =
					n;
					for (var s in this)this.hasOwnProperty(s) && "prototype" !== s && (e[s] = this[s]);
					t.statics && (o.extend(e, t.statics),
					delete t.statics), t.includes && (o.Util.extend.apply(null, [n].concat(t.includes)),
					delete t.includes), t.options && n.options && (t.options = o.extend({}, n.options, t.options)), o.extend(n, t), n._initHooks = [];
					var a = this;
					return e.__super__ = a.prototype, n.callInitHooks = function() {
						if (!this._initHooksCalled) {
							a.prototype.callInitHooks && a.prototype.callInitHooks.call(this), this._initHooksCalled = !0;
							for (var t = 0,
							    e = n._initHooks.length; e > t; t++)
								n._initHooks[t].call(this)
						}
					}, e
				}, o.Class.include = function(t) {
					o.extend(this.prototype, t)
				}, o.Class.mergeOptions = function(t) {
					o.extend(this.prototype.options, t)
				}, o.Class.addInitHook = function(t) {
					var e = Array.prototype.slice.call(arguments, 1),
					    i = "function" == typeof t ? t : function() {
						this[t].apply(this, e)
					};
					this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i)
				};
				var s = "_leaflet_events";
				o.Mixin = {}, o.Mixin.Events = {
					addEventListener : function(t, e, i) {
						if (o.Util.invokeEach(t, this.addEventListener, this, e, i))
							return this;
						var n,
						    a,
						    r,
						    h,
						    l,
						    u,
						    c,
						    d = this[s] = this[s] || {},
						    p = i && i !== this && o.stamp(i);
						for ( t = o.Util.splitWords(t),
						n = 0,
						a = t.length; a > n; n++)
							r = {
								action : e,
								context : i || this
							},
							h = t[n], p ? ( l = h + "_idx",
							u = l + "_len",
							c = d[l] = d[l] || {}, c[p] || (c[p] = [], d[u] = (d[u] || 0) + 1), c[p].push(r)) : (d[h] = d[h] || [], d[h].push(r));
						return this
					},
					hasEventListeners : function(t) {
						var e = this[s];
						return !!e && ( t in e && e[t].length > 0 || t + "_idx" in e && e[t + "_idx_len"] > 0)
					},
					removeEventListener : function(t, e, i) {
						if (!this[s])
							return this;
						if (!t)
							return this.clearAllEventListeners();
						if (o.Util.invokeEach(t, this.removeEventListener, this, e, i))
							return this;
						var n,
						    a,
						    r,
						    h,
						    l,
						    u,
						    c,
						    d,
						    p,
						    _ = this[s],
						    m = i && i !== this && o.stamp(i);
						for ( t = o.Util.splitWords(t),
						n = 0,
						a = t.length; a > n; n++)
							if ( r = t[n],
							u = r + "_idx",
							c = u + "_len",
							d = _[u], e) {
								if ( h = m && d ? d[m] : _[r]) {
									for ( l = h.length - 1; l >= 0; l--)
										h[l].action !== e || i && h[l].context !== i || ( p = h.splice(l, 1), p[0].action = o.Util.falseFn);
									i && d && 0 === h.length && (
									delete d[m], _[c]--)
								}
							} else
								delete _[r],
								delete _[u],
								delete _[c];
						return this
					},
					clearAllEventListeners : function() {
						return
						delete this[s], this
					},
					fireEvent : function(t, e) {
						if (!this.hasEventListeners(t))
							return this;
						var i,
						    n,
						    a,
						    r,
						    h,
						    l = o.Util.extend({}, e, {
							type : t,
							target : this
						}),
						    u = this[s];
						if (u[t])
							for ( i = u[t].slice(),
							n = 0,
							a = i.length; a > n; n++)
								i[n].action.call(i[n].context, l);
						r = u[t + "_idx"];
						for (h in r)
						if ( i = r[h].slice())
							for ( n = 0,
							a = i.length; a > n; n++)
								i[n].action.call(i[n].context, l);
						return this
					},
					addOneTimeEventListener : function(t, e, i) {
						if (o.Util.invokeEach(t, this.addOneTimeEventListener, this, e, i))
							return this;
						var n = o.bind(function() {
							this.removeEventListener(t, e, i).removeEventListener(t, n, i)
						}, this);
						return this.addEventListener(t, e, i).addEventListener(t, n, i)
					}
				}, o.Mixin.Events.on = o.Mixin.Events.addEventListener, o.Mixin.Events.off = o.Mixin.Events.removeEventListener, o.Mixin.Events.once = o.Mixin.Events.addOneTimeEventListener, o.Mixin.Events.fire = o.Mixin.Events.fireEvent, function() {
					var n = "ActiveXObject" in t,
					    s = n && !e.addEventListener,
					    a = navigator.userAgent.toLowerCase(),
					    r = -1 !== a.indexOf("webkit"),
					    h = -1 !== a.indexOf("chrome"),
					    l = -1 !== a.indexOf("phantom"),
					    u = -1 !== a.indexOf("android"),
					    c = -1 !== a.search("android [23]"),
					    d = -1 !== a.indexOf("gecko"),
					    p = typeof orientation != i + "",
					    _ = t.navigator && t.navigator.msPointerEnabled && t.navigator.msMaxTouchPoints && !t.PointerEvent,
					    m = t.PointerEvent && t.navigator.pointerEnabled && t.navigator.maxTouchPoints || _,
					    f = "devicePixelRatio" in t && t.devicePixelRatio > 1 || "matchMedia" in t && t.matchMedia("(min-resolution:144dpi)") && t.matchMedia("(min-resolution:144dpi)").matches,
					    g = e.documentElement,
					    v = n && "transition" in g.style,
					    y = "WebKitCSSMatrix" in t && "m11" in new t.WebKitCSSMatrix && !c,
					    P = "MozPerspective" in g.style,
					    L = "OTransition" in g.style,
					    x = !t.L_DISABLE_3D && (v || y || P || L) && !l,
					    w = !t.L_NO_TOUCH && !l && function() {
						var t = "ontouchstart";
						if (m || t in g)
							return !0;
						var i = e.createElement("div"),
						    n = !1;
						return i.setAttribute ? (i.setAttribute(t, "return;"), "function" == typeof i[t] && ( n = !0), i.removeAttribute(t),
						i = null, n) : !1
					}();
					o.Browser = {
						ie : n,
						ielt9 : s,
						webkit : r,
						gecko : d && !r && !t.opera && !n,
						android : u,
						android23 : c,
						chrome : h,
						ie3d : v,
						webkit3d : y,
						gecko3d : P,
						opera3d : L,
						any3d : x,
						mobile : p,
						mobileWebkit : p && r,
						mobileWebkit3d : p && y,
						mobileOpera : p && t.opera,
						touch : w,
						msPointer : _,
						pointer : m,
						retina : f
					}
				}(), o.Point = function(t, e, i) {
					this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e
				}, o.Point.prototype = {
					clone : function() {
						return new o.Point(this.x, this.y)
					},
					add : function(t) {
						return this.clone()._add(o.point(t))
					},
					_add : function(t) {
						return this.x += t.x, this.y += t.y, this
					},
					subtract : function(t) {
						return this.clone()._subtract(o.point(t))
					},
					_subtract : function(t) {
						return this.x -= t.x, this.y -= t.y, this
					},
					divideBy : function(t) {
						return this.clone()._divideBy(t)
					},
					_divideBy : function(t) {
						return this.x /= t, this.y /= t, this
					},
					multiplyBy : function(t) {
						return this.clone()._multiplyBy(t)
					},
					_multiplyBy : function(t) {
						return this.x *= t, this.y *= t, this
					},
					round : function() {
						return this.clone()._round()
					},
					_round : function() {
						return this.x = Math.round(this.x), this.y = Math.round(this.y), this
					},
					floor : function() {
						return this.clone()._floor()
					},
					_floor : function() {
						return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
					},
					distanceTo : function(t) {
						t = o.point(t);
						var e = t.x - this.x,
						    i = t.y - this.y;
						return Math.sqrt(e * e + i * i)
					},
					equals : function(t) {
						return t = o.point(t), t.x === this.x && t.y === this.y
					},
					contains : function(t) {
						return t = o.point(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y)
					},
					toString : function() {
						return "Point(" + o.Util.formatNum(this.x) + ", " + o.Util.formatNum(this.y) + ")"
					}
				}, o.point = function(t, e, n) {
					return t instanceof o.Point ? t : o.Util.isArray(t) ? new o.Point(t[0], t[1]) : t === i || null === t ? t : new o.Point(t, e, n)
				}, o.Bounds = function(t, e) {
					if (t)
						for (var i = e ? [t, e] : t,
						    n = 0,
						    o = i.length; o > n; n++)
							this.extend(i[n])
				}, o.Bounds.prototype = {
					extend : function(t) {
						return t = o.point(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this
					},
					getCenter : function(t) {
						return new o.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t)
					},
					getBottomLeft : function() {
						return new o.Point(this.min.x, this.max.y)
					},
					getTopRight : function() {
						return new o.Point(this.max.x, this.min.y)
					},
					getSize : function() {
						return this.max.subtract(this.min)
					},
					contains : function(t) {
						var e,
						    i;
						return t = "number" == typeof t[0] || t instanceof o.Point ? o.point(t) : o.bounds(t), t instanceof o.Bounds ? ( e = t.min,
						i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y
					},
					intersects : function(t) {
						t = o.bounds(t);
						var e = this.min,
						    i = this.max,
						    n = t.min,
						    s = t.max,
						    a = s.x >= e.x && n.x <= i.x,
						    r = s.y >= e.y && n.y <= i.y;
						return a && r
					},
					isValid : function() {
						return !(!this.min || !this.max)
					}
				}, o.bounds = function(t, e) {
					return !t || t instanceof o.Bounds ? t : new o.Bounds(t, e)
				}, o.Transformation = function(t, e, i, n) {
					this._a = t, this._b =
					e, this._c =
					i, this._d =
					n
				}, o.Transformation.prototype = {
					transform : function(t, e) {
						return this._transform(t.clone(), e)
					},
					_transform : function(t, e) {
						return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t
					},
					untransform : function(t, e) {
						return e = e || 1, new o.Point((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c)
					}
				}, o.DomUtil = {
					get : function(t) {
						return "string" == typeof t ? e.getElementById(t) : t
					},
					getStyle : function(t, i) {
						var n = t.style[i];
						if (!n && t.currentStyle && ( n = t.currentStyle[i]), (!n || "auto" === n) && e.defaultView) {
							var o = e.defaultView.getComputedStyle(t, null);
							n = o ? o[i] : null
						}
						return "auto" === n ? null : n
					},
					getViewportOffset : function(t) {
						var i,
						    n = 0,
						    s = 0,
						    a =
						    t,
						    r = e.body,
						    h = e.documentElement;
						do {
							if (n += a.offsetTop || 0, s += a.offsetLeft || 0, n += parseInt(o.DomUtil.getStyle(a, "borderTopWidth"), 10) || 0, s += parseInt(o.DomUtil.getStyle(a, "borderLeftWidth"), 10) || 0,
								i = o.DomUtil.getStyle(a, "position"), a.offsetParent === r && "absolute" === i)
								break;
							if ("fixed" === i) {
								n += r.scrollTop || h.scrollTop || 0, s += r.scrollLeft || h.scrollLeft || 0;
								break
							}
							if ("relative" === i && !a.offsetLeft) {
								var l = o.DomUtil.getStyle(a, "width"),
								    u = o.DomUtil.getStyle(a, "max-width"),
								    c = a.getBoundingClientRect();
								("none" !== l || "none" !== u) && (s += c.left + a.clientLeft), n += c.top + (r.scrollTop || h.scrollTop || 0);
								break
							}
							a = a.offsetParent
						} while(a);
						a = t;
						do {
							if (a === r)
								break;
							n -= a.scrollTop || 0, s -= a.scrollLeft || 0,
							a = a.parentNode
						} while(a);
						return new o.Point(s, n)
					},
					documentIsLtr : function() {
						return o.DomUtil._docIsLtrCached || (o.DomUtil._docIsLtrCached = !0, o.DomUtil._docIsLtr = "ltr" === o.DomUtil.getStyle(e.body, "direction")), o.DomUtil._docIsLtr
					},
					create : function(t, i, n) {
						var o = e.createElement(t);
						return o.className = i, n && n.appendChild(o), o
					},
					hasClass : function(t, e) {
						if (t.classList !== i)
							return t.classList.contains(e);
						var n = o.DomUtil._getClass(t);
						return n.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(n)
					},
					addClass : function(t, e) {
						if (t.classList !== i)
							for (var n = o.Util.splitWords(e),
							    s = 0,
							    a = n.length; a > s; s++)
								t.classList.add(n[s]);
						else if (!o.DomUtil.hasClass(t, e)) {
							var r = o.DomUtil._getClass(t);
							o.DomUtil._setClass(t, ( r ? r + " " : "") + e)
						}
					},
					removeClass : function(t, e) {
						t.classList !== i ? t.classList.remove(e) : o.DomUtil._setClass(t, o.Util.trim((" " + o.DomUtil._getClass(t) + " ").replace(" " + e + " ", " ")))
					},
					_setClass : function(t, e) {
						t.className.baseVal === i ? t.className = e : t.className.baseVal = e
					},
					_getClass : function(t) {
						return t.className.baseVal === i ? t.className : t.className.baseVal
					},
					setOpacity : function(t, e) {
						if ("opacity" in t.style)
							t.style.opacity = e;
						else if ("filter" in t.style) {
							var i = !1,
							    n = "DXImageTransform.Microsoft.Alpha";
							try {
								i = t.filters.item(n)
							} catch(o) {
								if (1 === e)
									return
							}
							e = Math.round(100 * e), i ? (i.Enabled = 100 !== e, i.Opacity =
							e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")"
						}
					},
					testProp : function(t) {
						for (var i = e.documentElement.style,
						    n = 0; n < t.length; n++)
							if (t[n] in i)
								return t[n];
						return !1
					},
					getTranslateString : function(t) {
						var e = o.Browser.webkit3d,
						    i = "translate" + ( e ? "3d" : "") + "(",
						    n = ( e ? ",0" : "") + ")";
						return i + t.x + "px," + t.y + "px" + n
					},
					getScaleString : function(t, e) {
						var i = o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1 * t))),
						    n = " scale(" + t + ") ";
						return i + n
					},
					setPosition : function(t, e, i) {
						t._leaflet_pos = e, !i && o.Browser.any3d ? t.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(e) : (t.style.left = e.x + "px", t.style.top = e.y + "px")
					},
					getPosition : function(t) {
						return t._leaflet_pos
					}
				}, o.DomUtil.TRANSFORM = o.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]), o.DomUtil.TRANSITION = o.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), o.DomUtil.TRANSITION_END = "webkitTransition" === o.DomUtil.TRANSITION || "OTransition" === o.DomUtil.TRANSITION ? o.DomUtil.TRANSITION + "End" : "transitionend", function() {
					if ("onselectstart" in e)
						o.extend(o.DomUtil, {
							disableTextSelection : function() {
								o.DomEvent.on(t, "selectstart", o.DomEvent.preventDefault)
							},
							enableTextSelection : function() {
								o.DomEvent.off(t, "selectstart", o.DomEvent.preventDefault)
							}
						});
					else {
						var i = o.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
						o.extend(o.DomUtil, {
							disableTextSelection : function() {
								if (i) {
									var t = e.documentElement.style;
									this._userSelect = t[i], t[i] = "none"
								}
							},
							enableTextSelection : function() {
								i && (e.documentElement.style[i] = this._userSelect,
								delete this._userSelect)
							}
						})
					}
					o.extend(o.DomUtil, {
						disableImageDrag : function() {
							o.DomEvent.on(t, "dragstart", o.DomEvent.preventDefault)
						},
						enableImageDrag : function() {
							o.DomEvent.off(t, "dragstart", o.DomEvent.preventDefault)
						}
					})
				}(), o.LatLng = function(t, e, n) {
					if ( t = parseFloat(t),
						e = parseFloat(e), isNaN(t) || isNaN(e))
						throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
					this.lat = t, this.lng =
					e, n !== i && (this.alt = parseFloat(n))
				}, o.extend(o.LatLng, {
					DEG_TO_RAD : Math.PI / 180,
					RAD_TO_DEG : 180 / Math.PI,
					MAX_MARGIN : 1e-9
				}), o.LatLng.prototype = {
					equals : function(t) {
						if (!t)
							return !1;
						t = o.latLng(t);
						var e = Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng));
						return e <= o.LatLng.MAX_MARGIN
					},
					toString : function(t) {
						return "LatLng(" + o.Util.formatNum(this.lat, t) + ", " + o.Util.formatNum(this.lng, t) + ")"
					},
					distanceTo : function(t) {
						t = o.latLng(t);
						var e = 6378137,
						    i = o.LatLng.DEG_TO_RAD,
						    n = (t.lat - this.lat) * i,
						    s = (t.lng - this.lng) * i,
						    a = this.lat * i,
						    r = t.lat * i,
						    h = Math.sin(n / 2),
						    l = Math.sin(s / 2),
						    u = h * h + l * l * Math.cos(a) * Math.cos(r);
						return 2 * e * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u))
					},
					wrap : function(t, e) {
						var i = this.lng;
						return t = t || -180,
						e = e || 180,
						i = (i + e) % (e - t) + (t > i || i === e ? e : t), new o.LatLng(this.lat, i)
					}
				}, o.latLng = function(t, e) {
					return t instanceof o.LatLng ? t : o.Util.isArray(t) ? "number" == typeof t[0] || "string" == typeof t[0] ? new o.LatLng(t[0], t[1], t[2]) : null : t === i || null === t ? t : "object" == typeof t && "lat" in t ? new o.LatLng(t.lat, "lng" in t ? t.lng : t.lon) : e === i ? null : new o.LatLng(t, e)
				}, o.LatLngBounds = function(t, e) {
					if (t)
						for (var i = e ? [t, e] : t,
						    n = 0,
						    o = i.length; o > n; n++)
							this.extend(i[n])
				}, o.LatLngBounds.prototype = {
					extend : function(t) {
						if (!t)
							return this;
						var e = o.latLng(t);
						return t = null !== e ? e : o.latLngBounds(t), t instanceof o.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(t.lat, this._southWest.lat), this._southWest.lng = Math.min(t.lng, this._southWest.lng), this._northEast.lat = Math.max(t.lat, this._northEast.lat), this._northEast.lng = Math.max(t.lng, this._northEast.lng)) : (this._southWest = new o.LatLng(t.lat, t.lng), this._northEast = new o.LatLng(t.lat, t.lng)) : t instanceof o.LatLngBounds && (this.extend(t._southWest), this.extend(t._northEast)), this
					},
					pad : function(t) {
						var e = this._southWest,
						    i = this._northEast,
						    n = Math.abs(e.lat - i.lat) * t,
						    s = Math.abs(e.lng - i.lng) * t;
						return new o.LatLngBounds(new o.LatLng(e.lat - n, e.lng - s), new o.LatLng(i.lat + n, i.lng + s))
					},
					getCenter : function() {
						return new o.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2)
					},
					getSouthWest : function() {
						return this._southWest
					},
					getNorthEast : function() {
						return this._northEast
					},
					getNorthWest : function() {
						return new o.LatLng(this.getNorth(), this.getWest())
					},
					getSouthEast : function() {
						return new o.LatLng(this.getSouth(), this.getEast())
					},
					getWest : function() {
						return this._southWest.lng
					},
					getSouth : function() {
						return this._southWest.lat
					},
					getEast : function() {
						return this._northEast.lng
					},
					getNorth : function() {
						return this._northEast.lat
					},
					contains : function(t) {
						t = "number" == typeof t[0] || t instanceof o.LatLng ? o.latLng(t) : o.latLngBounds(t);
						var e,
						    i,
						    n = this._southWest,
						    s = this._northEast;
						return t instanceof o.LatLngBounds ? ( e = t.getSouthWest(),
						i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && i.lat <= s.lat && e.lng >= n.lng && i.lng <= s.lng
					},
					intersects : function(t) {
						t = o.latLngBounds(t);
						var e = this._southWest,
						    i = this._northEast,
						    n = t.getSouthWest(),
						    s = t.getNorthEast(),
						    a = s.lat >= e.lat && n.lat <= i.lat,
						    r = s.lng >= e.lng && n.lng <= i.lng;
						return a && r
					},
					toBBoxString : function() {
						return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
					},
					equals : function(t) {
						return t ? ( t = o.latLngBounds(t), this._southWest.equals(t.getSouthWest()) && this._northEast.equals(t.getNorthEast())) : !1
					},
					isValid : function() {
						return !(!this._southWest || !this._northEast)
					}
				}, o.latLngBounds = function(t, e) {
					return !t || t instanceof o.LatLngBounds ? t : new o.LatLngBounds(t, e)
				}, o.Projection = {}, o.Projection.SphericalMercator = {
					MAX_LATITUDE : 85.0511287798,
					project : function(t) {
						var e = o.LatLng.DEG_TO_RAD,
						    i = this.MAX_LATITUDE,
						    n = Math.max(Math.min(i, t.lat), -i),
						    s = t.lng * e,
						    a = n * e;
						return a = Math.log(Math.tan(Math.PI / 4 + a / 2)), new o.Point(s, a)
					},
					unproject : function(t) {
						var e = o.LatLng.RAD_TO_DEG,
						    i = t.x * e,
						    n = (2 * Math.atan(Math.exp(t.y)) - Math.PI / 2) * e;
						return new o.LatLng(n, i)
					}
				}, o.Projection.LonLat = {
					project : function(t) {
						return new o.Point(t.lng, t.lat)
					},
					unproject : function(t) {
						return new o.LatLng(t.y, t.x)
					}
				}, o.CRS = {
					latLngToPoint : function(t, e) {
						var i = this.projection.project(t),
						    n = this.scale(e);
						return this.transformation._transform(i, n)
					},
					pointToLatLng : function(t, e) {
						var i = this.scale(e),
						    n = this.transformation.untransform(t, i);
						return this.projection.unproject(n)
					},
					project : function(t) {
						return this.projection.project(t)
					},
					scale : function(t) {
						return 256 * Math.pow(2, t)
					},
					getSize : function(t) {
						var e = this.scale(t);
						return o.point(e, e)
					}
				}, o.CRS.Simple = o.extend({}, o.CRS, {
					projection : o.Projection.LonLat,
					transformation : new o.Transformation(1, 0, -1, 0),
					scale : function(t) {
						return Math.pow(2, t)
					}
				}), o.CRS.EPSG3857 = o.extend({}, o.CRS, {
					code : "EPSG:3857",
					projection : o.Projection.SphericalMercator,
					transformation : new o.Transformation(.5 / Math.PI, .5, -.5 / Math.PI, .5),
					project : function(t) {
						var e = this.projection.project(t),
						    i = 6378137;
						return e.multiplyBy(i)
					}
				}), o.CRS.EPSG900913 = o.extend({}, o.CRS.EPSG3857, {
					code : "EPSG:900913"
				}), o.CRS.EPSG4326 = o.extend({}, o.CRS, {
					code : "EPSG:4326",
					projection : o.Projection.LonLat,
					transformation : new o.Transformation(1 / 360, .5, -1 / 360, .5)
				}), o.Map = o.Class.extend({
					includes : o.Mixin.Events,
					options : {
						crs : o.CRS.EPSG3857,
						fadeAnimation : o.DomUtil.TRANSITION && !o.Browser.android23,
						trackResize : !0,
						markerZoomAnimation : o.DomUtil.TRANSITION && o.Browser.any3d
					},
					initialize : function(t, e) {
						e = o.setOptions(this, e), this._initContainer(t), this._initLayout(), this._onResize = o.bind(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), e.center && e.zoom !== i && this.setView(o.latLng(e.center), e.zoom, {
							reset : !0
						}), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._tileLayersNum = 0, this.callInitHooks(), this._addLayers(e.layers)
					},
					setView : function(t, e) {
						return e = e === i ? this.getZoom() : e, this._resetView(o.latLng(t), this._limitZoom(e)), this
					},
					setZoom : function(t, e) {
						return this._loaded ? this.setView(this.getCenter(), t, {
							zoom : e
						}) : (this._zoom = this._limitZoom(t), this)
					},
					zoomIn : function(t, e) {
						return this.setZoom(this._zoom + (t || 1), e)
					},
					zoomOut : function(t, e) {
						return this.setZoom(this._zoom - (t || 1), e)
					},
					setZoomAround : function(t, e, i) {
						var n = this.getZoomScale(e),
						    s = this.getSize().divideBy(2),
						    a = t instanceof o.Point ? t : this.latLngToContainerPoint(t),
						    r = a.subtract(s).multiplyBy(1 - 1 / n),
						    h = this.containerPointToLatLng(s.add(r));
						return this.setView(h, e, {
							zoom : i
						})
					},
					fitBounds : function(t, e) {
						e = e || {},
						t = t.getBounds ? t.getBounds() : o.latLngBounds(t);
						var i = o.point(e.paddingTopLeft || e.padding || [0, 0]),
						    n = o.point(e.paddingBottomRight || e.padding || [0, 0]),
						    s = this.getBoundsZoom(t, !1, i.add(n)),
						    a = n.subtract(i).divideBy(2),
						    r = this.project(t.getSouthWest(), s),
						    h = this.project(t.getNorthEast(), s),
						    l = this.unproject(r.add(h).divideBy(2).add(a), s);
						return s = e && e.maxZoom ? Math.min(e.maxZoom, s) : s, this.setView(l, s, e)
					},
					fitWorld : function(t) {
						return this.fitBounds([[-90, -180], [90, 180]], t)
					},
					panTo : function(t, e) {
						return this.setView(t, this._zoom, {
							pan : e
						})
					},
					panBy : function(t) {
						return this.fire("movestart"), this._rawPanBy(o.point(t)), this.fire("move"), this.fire("moveend")
					},
					setMaxBounds : function(t) {
						return t = o.latLngBounds(t), this.options.maxBounds =
						t, t ? (this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds, this)) : this.off("moveend", this._panInsideMaxBounds, this)
					},
					panInsideBounds : function(t, e) {
						var i = this.getCenter(),
						    n = this._limitCenter(i, this._zoom, t);
						return i.equals(n) ? this : this.panTo(n, e)
					},
					addLayer : function(t) {
						var e = o.stamp(t);
						return this._layers[e] ? this : (this._layers[e] = t, !t.options || isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[e] = t, this._updateZoomLevels()), this.options.zoomAnimation && o.TileLayer && t instanceof o.TileLayer && (this._tileLayersNum++, this._tileLayersToLoad++, t.on("load", this._onTileLayerLoad, this)), this._loaded && this._layerAdd(t), this)
					},
					removeLayer : function(t) {
						var e = o.stamp(t);
						return this._layers[e] ? (this._loaded && t.onRemove(this),
						delete this._layers[e], this._loaded && this.fire("layerremove", {
							layer : t
						}), this._zoomBoundLayers[e] && (
						delete this._zoomBoundLayers[e], this._updateZoomLevels()), this.options.zoomAnimation && o.TileLayer && t instanceof o.TileLayer && (this._tileLayersNum--, this._tileLayersToLoad--, t.off("load", this._onTileLayerLoad, this)), this) : this
					},
					hasLayer : function(t) {
						return t ? o.stamp(t) in this._layers : !1
					},
					eachLayer : function(t, e) {
						for (var i in this._layers)
						t.call(e, this._layers[i]);
						return this
					},
					invalidateSize : function(t) {
						if (!this._loaded)
							return this;
						t = o.extend({
							animate : !1,
							pan : !0
						}, t === !0 ? {
							animate : !0
						} : t);
						var e = this.getSize();
						this._sizeChanged = !0, this._initialCenter = null;
						var i = this.getSize(),
						    n = e.divideBy(2).round(),
						    s = i.divideBy(2).round(),
						    a = n.subtract(s);
						return a.x || a.y ? (t.animate && t.pan ? this.panBy(a) : (t.pan && this._rawPanBy(a), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(o.bind(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
							oldSize : e,
							newSize : i
						})) : this
					},
					addHandler : function(t, e) {
						if (!e)
							return this;
						var i = this[t] = new e(this);
						return this._handlers.push(i), this.options[t] && i.enable(), this
					},
					remove : function() {
						this._loaded && this.fire("unload"), this._initEvents("off");
						try {
							delete this._container._leaflet
						} catch(t) {
							this._container._leaflet = i
						}
						return this._clearPanes(), this._clearControlPos && this._clearControlPos(), this._clearHandlers(), this
					},
					getCenter : function() {
						return this._checkIfLoaded(), this._initialCenter && !this._moved() ? this._initialCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
					},
					getZoom : function() {
						return this._zoom
					},
					getBounds : function() {
						var t = this.getPixelBounds(),
						    e = this.unproject(t.getBottomLeft()),
						    i = this.unproject(t.getTopRight());
						return new o.LatLngBounds(e, i)
					},
					getMinZoom : function() {
						return this.options.minZoom === i ? this._layersMinZoom === i ? 0 : this._layersMinZoom : this.options.minZoom
					},
					getMaxZoom : function() {
						return this.options.maxZoom === i ? this._layersMaxZoom === i ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
					},
					getBoundsZoom : function(t, e, i) {
						t = o.latLngBounds(t);
						var n,
						    s = this.getMinZoom() - ( e ? 1 : 0),
						    a = this.getMaxZoom(),
						    r = this.getSize(),
						    h = t.getNorthWest(),
						    l = t.getSouthEast(),
						    u = !0;
						i = o.point(i || [0, 0]);
						do s++,
							n = this.project(l, s).subtract(this.project(h, s)).add(i),
							u = e ? n.x < r.x || n.y < r.y : r.contains(n);
						while(u&&a>=s);
						return u && e ? null : e ? s : s - 1
					},
					getSize : function() {
						return (!this._size || this._sizeChanged) && (this._size = new o.Point(this._container.clientWidth, this._container.clientHeight), this._sizeChanged = !1), this._size.clone()
					},
					getPixelBounds : function() {
						var t = this._getTopLeftPoint();
						return new o.Bounds(t, t.add(this.getSize()))
					},
					getPixelOrigin : function() {
						return this._checkIfLoaded(), this._initialTopLeftPoint
					},
					getPanes : function() {
						return this._panes
					},
					getContainer : function() {
						return this._container
					},
					getZoomScale : function(t) {
						var e = this.options.crs;
						return e.scale(t) / e.scale(this._zoom)
					},
					getScaleZoom : function(t) {
						return this._zoom + Math.log(t) / Math.LN2
					},
					project : function(t, e) {
						return e = e === i ? this._zoom : e, this.options.crs.latLngToPoint(o.latLng(t), e)
					},
					unproject : function(t, e) {
						return e = e === i ? this._zoom : e, this.options.crs.pointToLatLng(o.point(t), e)
					},
					layerPointToLatLng : function(t) {
						var e = o.point(t).add(this.getPixelOrigin());
						return this.unproject(e)
					},
					latLngToLayerPoint : function(t) {
						var e = this.project(o.latLng(t))._round();
						return e._subtract(this.getPixelOrigin())
					},
					containerPointToLayerPoint : function(t) {
						return o.point(t).subtract(this._getMapPanePos())
					},
					layerPointToContainerPoint : function(t) {
						return o.point(t).add(this._getMapPanePos())
					},
					containerPointToLatLng : function(t) {
						var e = this.containerPointToLayerPoint(o.point(t));
						return this.layerPointToLatLng(e)
					},
					latLngToContainerPoint : function(t) {
						return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))
					},
					mouseEventToContainerPoint : function(t) {
						return o.DomEvent.getMousePosition(t, this._container)
					},
					mouseEventToLayerPoint : function(t) {
						return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))
					},
					mouseEventToLatLng : function(t) {
						return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))
					},
					_initContainer : function(t) {
						var e = this._container = o.DomUtil.get(t);
						if (!e)
							throw new Error("Map container not found.");
						if (e._leaflet)
							throw new Error("Map container is already initialized.");
						e._leaflet = !0
					},
					_initLayout : function() {
						var t = this._container;
						o.DomUtil.addClass(t, "leaflet-container" + (o.Browser.touch ? " leaflet-touch" : "") + (o.Browser.retina ? " leaflet-retina" : "") + (o.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));
						var e = o.DomUtil.getStyle(t, "position");
						"absolute" !== e && "relative" !== e && "fixed" !== e && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos()
					},
					_initPanes : function() {
						var t = this._panes = {};
						this._mapPane = t.mapPane = this._createPane("leaflet-map-pane", this._container), this._tilePane = t.tilePane = this._createPane("leaflet-tile-pane", this._mapPane), t.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane), t.shadowPane = this._createPane("leaflet-shadow-pane"), t.overlayPane = this._createPane("leaflet-overlay-pane"), t.markerPane = this._createPane("leaflet-marker-pane"), t.popupPane = this._createPane("leaflet-popup-pane");
						var e = " leaflet-zoom-hide";
						this.options.markerZoomAnimation || (o.DomUtil.addClass(t.markerPane, e), o.DomUtil.addClass(t.shadowPane, e), o.DomUtil.addClass(t.popupPane, e))
					},
					_createPane : function(t, e) {
						return o.DomUtil.create("div", t, e || this._panes.objectsPane)
					},
					_clearPanes : function() {
						this._container.removeChild(this._mapPane)
					},
					_addLayers : function(t) {
						t = t ? o.Util.isArray(t) ? t : [t] : [];
						for (var e = 0,
						    i = t.length; i > e; e++)
							this.addLayer(t[e])
					},
					_resetView : function(t, e, i, n) {
						var s = this._zoom !== e;
						n || (this.fire("movestart"), s && this.fire("zoomstart")), this._zoom =
						e, this._initialCenter =
						t, this._initialTopLeftPoint = this._getNewTopLeftPoint(t), i ? this._initialTopLeftPoint._add(this._getMapPanePos()) : o.DomUtil.setPosition(this._mapPane, new o.Point(0, 0)), this._tileLayersToLoad = this._tileLayersNum;
						var a = !this._loaded;
						this._loaded = !0, a && (this.fire("load"), this.eachLayer(this._layerAdd, this)), this.fire("viewreset", {
							hard : !i
						}), this.fire("move"), (s || n) && this.fire("zoomend"), this.fire("moveend", {
							hard : !i
						})
					},
					_rawPanBy : function(t) {
						o.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(t))
					},
					_getZoomSpan : function() {
						return this.getMaxZoom() - this.getMinZoom()
					},
					_updateZoomLevels : function() {
						var t,
						    e = 1 / 0,
						    n = -1 / 0,
						    o = this._getZoomSpan();
						for (t in this._zoomBoundLayers) {
							var s = this._zoomBoundLayers[t];
							isNaN(s.options.minZoom) || ( e = Math.min(e, s.options.minZoom)), isNaN(s.options.maxZoom) || ( n = Math.max(n, s.options.maxZoom))
						}
						t === i ? this._layersMaxZoom = this._layersMinZoom = i : (this._layersMaxZoom = n, this._layersMinZoom =
						e), o !== this._getZoomSpan() && this.fire("zoomlevelschange")
					},
					_panInsideMaxBounds : function() {
						this.panInsideBounds(this.options.maxBounds)
					},
					_checkIfLoaded : function() {
						if (!this._loaded)
							throw new Error("Set map center and zoom first.")
					},
					_initEvents : function(e) {
						if (o.DomEvent) {
							e = e || "on", o.DomEvent[e](this._container, "click", this._onMouseClick, this);
							var i,
							    n,
							    s = ["dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu"];
							for ( i = 0,
							n = s.length; n > i; i++)
								o.DomEvent[e](this._container, s[i], this._fireMouseEvent, this);
							this.options.trackResize && o.DomEvent[e](t, "resize", this._onResize, this)
						}
					},
					_onResize : function() {
						o.Util.cancelAnimFrame(this._resizeRequest), this._resizeRequest = o.Util.requestAnimFrame(function() {
							this.invalidateSize({
								debounceMoveend : !0
							})
						}, this, !1, this._container)
					},
					_onMouseClick : function(t) {
						!this._loaded || !t._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || o.DomEvent._skipped(t) || (this.fire("preclick"), this._fireMouseEvent(t))
					},
					_fireMouseEvent : function(t) {
						if (this._loaded && !o.DomEvent._skipped(t)) {
							var e = t.type;
							if ( e = "mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e, this.hasEventListeners(e)) {
								"contextmenu" === e && o.DomEvent.preventDefault(t);
								var i = this.mouseEventToContainerPoint(t),
								    n = this.containerPointToLayerPoint(i),
								    s = this.layerPointToLatLng(n);
								this.fire(e, {
									latlng : s,
									layerPoint : n,
									containerPoint : i,
									originalEvent : t
								})
							}
						}
					},
					_onTileLayerLoad : function() {
						this._tileLayersToLoad--, this._tileLayersNum && !this._tileLayersToLoad && this.fire("tilelayersload")
					},
					_clearHandlers : function() {
						for (var t = 0,
						    e = this._handlers.length; e > t; t++)
							this._handlers[t].disable()
					},
					whenReady : function(t, e) {
						return this._loaded ? t.call(e || this, this) : this.on("load", t, e), this
					},
					_layerAdd : function(t) {
						t.onAdd(this), this.fire("layeradd", {
							layer : t
						})
					},
					_getMapPanePos : function() {
						return o.DomUtil.getPosition(this._mapPane)
					},
					_moved : function() {
						var t = this._getMapPanePos();
						return t && !t.equals([0, 0])
					},
					_getTopLeftPoint : function() {
						return this.getPixelOrigin().subtract(this._getMapPanePos())
					},
					_getNewTopLeftPoint : function(t, e) {
						var i = this.getSize()._divideBy(2);
						return this.project(t, e)._subtract(i)._round()
					},
					_latLngToNewLayerPoint : function(t, e, i) {
						var n = this._getNewTopLeftPoint(i, e).add(this._getMapPanePos());
						return this.project(t, e)._subtract(n)
					},
					_getCenterLayerPoint : function() {
						return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
					},
					_getCenterOffset : function(t) {
						return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())
					},
					_limitCenter : function(t, e, i) {
						if (!i)
							return t;
						var n = this.project(t, e),
						    s = this.getSize().divideBy(2),
						    a = new o.Bounds(n.subtract(s), n.add(s)),
						    r = this._getBoundsOffset(a, i, e);
						return this.unproject(n.add(r), e)
					},
					_limitOffset : function(t, e) {
						if (!e)
							return t;
						var i = this.getPixelBounds(),
						    n = new o.Bounds(i.min.add(t), i.max.add(t));
						return t.add(this._getBoundsOffset(n, e))
					},
					_getBoundsOffset : function(t, e, i) {
						var n = this.project(e.getNorthWest(), i).subtract(t.min),
						    s = this.project(e.getSouthEast(), i).subtract(t.max),
						    a = this._rebound(n.x, -s.x),
						    r = this._rebound(n.y, -s.y);
						return new o.Point(a, r)
					},
					_rebound : function(t, e) {
						return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e))
					},
					_limitZoom : function(t) {
						var e = this.getMinZoom(),
						    i = this.getMaxZoom();
						return Math.max(e, Math.min(i, t))
					}
				}), o.map = function(t, e) {
					return new o.Map(t, e)
				}, o.Projection.Mercator = {
					MAX_LATITUDE : 85.0840591556,
					R_MINOR : 6356752.314245179,
					R_MAJOR : 6378137,
					project : function(t) {
						var e = o.LatLng.DEG_TO_RAD,
						    i = this.MAX_LATITUDE,
						    n = Math.max(Math.min(i, t.lat), -i),
						    s = this.R_MAJOR,
						    a = this.R_MINOR,
						    r = t.lng * e * s,
						    h = n * e,
						    l = a / s,
						    u = Math.sqrt(1 - l * l),
						    c = u * Math.sin(h);
						c = Math.pow((1 - c) / (1 + c), .5 * u);
						var d = Math.tan(.5 * (.5 * Math.PI - h)) / c;
						return h = -s * Math.log(d), new o.Point(r, h)
					},
					unproject : function(t) {
						for (var e,
						    i = o.LatLng.RAD_TO_DEG,
						    n = this.R_MAJOR,
						    s = this.R_MINOR,
						    a = t.x * i / n,
						    r = s / n,
						    h = Math.sqrt(1 - r * r),
						    l = Math.exp(-t.y / n),
						    u = Math.PI / 2 - 2 * Math.atan(l),
						    c = 15,
						    d = 1e-7,
						    p =
						    c,
						    _ = .1; Math.abs(_) > d && --p > 0; )
							e = h * Math.sin(u),
							_ = Math.PI / 2 - 2 * Math.atan(l * Math.pow((1 - e) / (1 + e), .5 * h)) - u, u += _;
						return new o.LatLng(u * i, a)
					}
				}, o.CRS.EPSG3395 = o.extend({}, o.CRS, {
					code : "EPSG:3395",
					projection : o.Projection.Mercator,
					transformation : function() {
						var t = o.Projection.Mercator,
						    e = t.R_MAJOR,
						    i = .5 / (Math.PI * e);
						return new o.Transformation(i, .5, -i, .5)
					}()
				}), o.TileLayer = o.Class.extend({
					includes : o.Mixin.Events,
					options : {
						minZoom : 0,
						maxZoom : 18,
						tileSize : 256,
						subdomains : "abc",
						errorTileUrl : "",
						attribution : "",
						zoomOffset : 0,
						opacity : 1,
						unloadInvisibleTiles : o.Browser.mobile,
						updateWhenIdle : o.Browser.mobile
					},
					initialize : function(t, e) {
						e = o.setOptions(this, e), e.detectRetina && o.Browser.retina && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomOffset++, e.minZoom > 0 && e.minZoom--, this.options.maxZoom--), e.bounds && (e.bounds = o.latLngBounds(e.bounds)), this._url =
						t;
						var i = this.options.subdomains;
						"string" == typeof i && (this.options.subdomains = i.split(""))
					},
					onAdd : function(t) {
						this._map = t, this._animated = t._zoomAnimated, this._initContainer(), this._createTileProto(), t.on({
							viewreset : this._reset,
							moveend : this._update
						}, this), this._animated && t.on({
							zoomanim : this._animateZoom,
							zoomend : this._endZoomAnim
						}, this), this.options.updateWhenIdle || (this._limitedUpdate = o.Util.limitExecByInterval(this._update, 150, this), t.on("move", this._limitedUpdate, this)), this._reset(), this._update()
					},
					addTo : function(t) {
						return t.addLayer(this), this
					},
					onRemove : function(t) {
						this._container.parentNode.removeChild(this._container), t.off({
							viewreset : this._reset,
							moveend : this._update
						}, this), this._animated && t.off({
							zoomanim : this._animateZoom,
							zoomend : this._endZoomAnim
						}, this), this.options.updateWhenIdle || t.off("move", this._limitedUpdate, this), this._container = null, this._map = null
					},
					bringToFront : function() {
						var t = this._map._panes.tilePane;
						return this._container && (t.appendChild(this._container), this._setAutoZIndex(t, Math.max)), this
					},
					bringToBack : function() {
						var t = this._map._panes.tilePane;
						return this._container && (t.insertBefore(this._container, t.firstChild), this._setAutoZIndex(t, Math.min)), this
					},
					getAttribution : function() {
						return this.options.attribution
					},
					getContainer : function() {
						return this._container
					},
					setOpacity : function(t) {
						return this.options.opacity = t, this._map && this._updateOpacity(), this
					},
					setZIndex : function(t) {
						return this.options.zIndex = t, this._updateZIndex(), this
					},
					setUrl : function(t, e) {
						return this._url = t, e || this.redraw(), this
					},
					redraw : function() {
						return this._map && (this._reset({
							hard : !0
						}), this._update()), this
					},
					_updateZIndex : function() {
						this._container && this.options.zIndex !== i && (this._container.style.zIndex = this.options.zIndex)
					},
					_setAutoZIndex : function(t, e) {
						var i,
						    n,
						    o,
						    s = t.children,
						    a = -e(1 / 0, -1 / 0);
						for ( n = 0,
						o = s.length; o > n; n++)
							s[n] !== this._container && ( i = parseInt(s[n].style.zIndex, 10), isNaN(i) || ( a = e(a, i)));
						this.options.zIndex = this._container.style.zIndex = (isFinite(a) ? a : 0) + e(1, -1)
					},
					_updateOpacity : function() {
						var t,
						    e = this._tiles;
						if (o.Browser.ielt9)
							for (t in e)
							o.DomUtil.setOpacity(e[t], this.options.opacity);
						else
							o.DomUtil.setOpacity(this._container, this.options.opacity)
					},
					_initContainer : function() {
						var t = this._map._panes.tilePane;
						if (!this._container) {
							if (this._container = o.DomUtil.create("div", "leaflet-layer"), this._updateZIndex(), this._animated) {
								var e = "leaflet-tile-container";
								this._bgBuffer = o.DomUtil.create("div", e, this._container), this._tileContainer = o.DomUtil.create("div", e, this._container)
							} else
								this._tileContainer = this._container;
							t.appendChild(this._container), this.options.opacity < 1 && this._updateOpacity()
						}
					},
					_reset : function(t) {
						for (var e in this._tiles)
						this.fire("tileunload", {
							tile : this._tiles[e]
						});
						this._tiles = {}, this._tilesToLoad = 0, this.options.reuseTiles && (this._unusedTiles = []), this._tileContainer.innerHTML = "", this._animated && t && t.hard && this._clearBgBuffer(), this._initContainer()
					},
					_getTileSize : function() {
						var t = this._map,
						    e = t.getZoom() + this.options.zoomOffset,
						    i = this.options.maxNativeZoom,
						    n = this.options.tileSize;
						return i && e > i && ( n = Math.round(t.getZoomScale(e) / t.getZoomScale(i) * n)), n
					},
					_update : function() {
						if (this._map) {
							var t = this._map.getPixelBounds(),
							    e = this._map.getZoom(),
							    i = this.options.tileSize;
							if (!(e > this.options.maxZoom || e < this.options.minZoom)) {
								var n = o.bounds(t.min.divideBy(i)._floor(), t.max.divideBy(i)._floor());
								this._addTilesFromCenterOut(n), (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(n)
							}
						}
					},
					_addTilesFromCenterOut : function(t) {
						var i,
						    n,
						    s,
						    a = [],
						    r = t.getCenter();
						for ( i = t.min.y; i <= t.max.y; i++)
							for ( n = t.min.x; n <= t.max.x; n++)
								s = new o.Point(n, i), this._tileShouldBeLoaded(s) && a.push(s);
						var h = a.length;
						if (0 !== h) {
							a.sort(function(t, e) {
								return t.distanceTo(r) - e.distanceTo(r)
							});
							var l = e.createDocumentFragment();
							for (this._tilesToLoad || this.fire("loading"), this._tilesToLoad += h,
							n = 0; h > n; n++)
								this._addTile(a[n], l);
							this._tileContainer.appendChild(l)
						}
					},
					_tileShouldBeLoaded : function(t) {
						if (t.x + ":" + t.y in this._tiles)
							return !1;
						var e = this.options;
						if (!e.continuousWorld) {
							var i = this._getWrapTileNum();
							if (e.noWrap && (t.x < 0 || t.x >= i.x) || t.y < 0 || t.y >= i.y)
								return !1
						}
						if (e.bounds) {
							var n = e.tileSize,
							    o = t.multiplyBy(n),
							    s = o.add([n, n]),
							    a = this._map.unproject(o),
							    r = this._map.unproject(s);
							if (e.continuousWorld || e.noWrap || ( a = a.wrap(),
								r = r.wrap()), !e.bounds.intersects([a, r]))
								return !1
						}
						return !0
					},
					_removeOtherTiles : function(t) {
						var e,
						    i,
						    n,
						    o;
						for (o in this._tiles) e = o.split(":"),
						i = parseInt(e[0], 10),
						n = parseInt(e[1], 10), (i < t.min.x || i > t.max.x || n < t.min.y || n > t.max.y) && this._removeTile(o)
					},
					_removeTile : function(t) {
						var e = this._tiles[t];
						this.fire("tileunload", {
							tile : e,
							url : e.src
						}), this.options.reuseTiles ? (o.DomUtil.removeClass(e, "leaflet-tile-loaded"), this._unusedTiles.push(e)) : e.parentNode === this._tileContainer && this._tileContainer.removeChild(e), o.Browser.android || (e.onload = null, e.src = o.Util.emptyImageUrl),
						delete this._tiles[t]
					},
					_addTile : function(t, e) {
						var i = this._getTilePos(t),
						    n = this._getTile();
						o.DomUtil.setPosition(n, i, o.Browser.chrome), this._tiles[t.x + ":" + t.y] =
						n, this._loadTile(n, t), n.parentNode !== this._tileContainer && e.appendChild(n)
					},
					_getZoomForUrl : function() {
						var t = this.options,
						    e = this._map.getZoom();
						return t.zoomReverse && ( e = t.maxZoom - e), e + t.zoomOffset
					},
					_getTilePos : function(t) {
						var e = this._map.getPixelOrigin(),
						    i = this.options.tileSize;
						return t.multiplyBy(i).subtract(e)
					},
					getTileUrl : function(t) {
						return o.Util.template(this._url, o.extend({
							s : this._getSubdomain(t),
							z : t.z,
							x : t.x,
							y : t.y
						}, this.options))
					},
					_getWrapTileNum : function() {
						var t = this._map.options.crs,
						    e = t.getSize(this._map.getZoom());
						return e.divideBy(this.options.tileSize)
					},
					_adjustTilePoint : function(t) {
						var e = this._getWrapTileNum();
						this.options.continuousWorld || this.options.noWrap || (t.x = (t.x % e.x + e.x) % e.x), this.options.tms && (t.y = e.y - t.y - 1), t.z = this._getZoomForUrl()
					},
					_getSubdomain : function(t) {
						var e = Math.abs(t.x + t.y) % this.options.subdomains.length;
						return this.options.subdomains[e]
					},
					_createTileProto : function() {
						var t = this._tileImg = o.DomUtil.create("img", "leaflet-tile");
						t.style.width = t.style.height = this.options.tileSize + "px", t.galleryimg = "no"
					},
					_getTile : function() {
						if (this.options.reuseTiles && this._unusedTiles.length > 0) {
							var t = this._unusedTiles.pop();
							return this._resetTile(t), t
						}
						return this._createTile()
					},
					_resetTile : function() {
					},
					_createTile : function() {
						var t = this._tileImg.cloneNode(!1);
						return t.onselectstart = t.onmousemove = o.Util.falseFn, o.Browser.ielt9 && this.options.opacity !== i && o.DomUtil.setOpacity(t, this.options.opacity), o.Browser.mobileWebkit3d && (t.style.WebkitBackfaceVisibility = "hidden"), t
					},
					_loadTile : function(t, e) {
						t._layer = this, t.onload = this._tileOnLoad, t.onerror = this._tileOnError, this._adjustTilePoint(e), t.src = this.getTileUrl(e), this.fire("tileloadstart", {
							tile : t,
							url : t.src
						})
					},
					_tileLoaded : function() {
						this._tilesToLoad--, this._animated && o.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated"), this._tilesToLoad || (this.fire("load"), this._animated && (clearTimeout(this._clearBgBufferTimer), this._clearBgBufferTimer = setTimeout(o.bind(this._clearBgBuffer, this), 500)))
					},
					_tileOnLoad : function() {
						var t = this._layer;
						this.src !== o.Util.emptyImageUrl && (o.DomUtil.addClass(this, "leaflet-tile-loaded"), t.fire("tileload", {
							tile : this,
							url : this.src
						})), t._tileLoaded()
					},
					_tileOnError : function() {
						var t = this._layer;
						t.fire("tileerror", {
							tile : this,
							url : this.src
						});
						var e = t.options.errorTileUrl;
						e && (this.src = e), t._tileLoaded()
					}
				}), o.tileLayer = function(t, e) {
					return new o.TileLayer(t, e)
				}, o.TileLayer.WMS = o.TileLayer.extend({
					defaultWmsParams : {
						service : "WMS",
						request : "GetMap",
						version : "1.1.1",
						layers : "",
						styles : "",
						format : "image/jpeg",
						transparent : !1
					},
					initialize : function(t, e) {
						this._url = t;
						var i = o.extend({}, this.defaultWmsParams),
						    n = e.tileSize || this.options.tileSize;
						i.width = i.height = e.detectRetina && o.Browser.retina ? 2 * n : n;
						for (var s in e)this.options.hasOwnProperty(s) || "crs" === s || (i[s] = e[s]);
						this.wmsParams = i, o.setOptions(this, e)
					},
					onAdd : function(t) {
						this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
						var e = this._wmsVersion >= 1.3 ? "crs" : "srs";
						this.wmsParams[e] = this._crs.code, o.TileLayer.prototype.onAdd.call(this, t)
					},
					getTileUrl : function(t) {
						var e = this._map,
						    i = this.options.tileSize,
						    n = t.multiplyBy(i),
						    s = n.add([i, i]),
						    a = this._crs.project(e.unproject(n, t.z)),
						    r = this._crs.project(e.unproject(s, t.z)),
						    h = this._wmsVersion >= 1.3 && this._crs === o.CRS.EPSG4326 ? [r.y, a.x, a.y, r.x].join(",") : [a.x, r.y, r.x, a.y].join(","),
						    l = o.Util.template(this._url, {
							s : this._getSubdomain(t)
						});
						return l + o.Util.getParamString(this.wmsParams, l, !0) + "&BBOX=" + h
					},
					setParams : function(t, e) {
						return o.extend(this.wmsParams, t), e || this.redraw(), this
					}
				}), o.tileLayer.wms = function(t, e) {
					return new o.TileLayer.WMS(t, e)
				}, o.TileLayer.Canvas = o.TileLayer.extend({
					options : {
						async : !1
					},
					initialize : function(t) {
						o.setOptions(this, t)
					},
					redraw : function() {
						this._map && (this._reset({
							hard : !0
						}), this._update());
						for (var t in this._tiles)
						this._redrawTile(this._tiles[t]);
						return this
					},
					_redrawTile : function(t) {
						this.drawTile(t, t._tilePoint, this._map._zoom)
					},
					_createTileProto : function() {
						var t = this._canvasProto = o.DomUtil.create("canvas", "leaflet-tile");
						t.width = t.height = this.options.tileSize
					},
					_createTile : function() {
						var t = this._canvasProto.cloneNode(!1);
						return t.onselectstart = t.onmousemove = o.Util.falseFn, t
					},
					_loadTile : function(t, e) {
						t._layer = this, t._tilePoint =
						e, this._redrawTile(t), this.options.async || this.tileDrawn(t)
					},
					drawTile : function() {
					},
					tileDrawn : function(t) {
						this._tileOnLoad.call(t)
					}
				}), o.tileLayer.canvas = function(t) {
					return new o.TileLayer.Canvas(t)
				}, o.ImageOverlay = o.Class.extend({
					includes : o.Mixin.Events,
					options : {
						opacity : 1
					},
					initialize : function(t, e, i) {
						this._url = t, this._bounds = o.latLngBounds(e), o.setOptions(this, i)
					},
					onAdd : function(t) {
						this._map = t, this._image || this._initImage(), t._panes.overlayPane.appendChild(this._image), t.on("viewreset", this._reset, this), t.options.zoomAnimation && o.Browser.any3d && t.on("zoomanim", this._animateZoom, this), this._reset()
					},
					onRemove : function(t) {
						t.getPanes().overlayPane.removeChild(this._image), t.off("viewreset", this._reset, this), t.options.zoomAnimation && t.off("zoomanim", this._animateZoom, this)
					},
					addTo : function(t) {
						return t.addLayer(this), this
					},
					setOpacity : function(t) {
						return this.options.opacity = t, this._updateOpacity(), this
					},
					bringToFront : function() {
						return this._image && this._map._panes.overlayPane.appendChild(this._image), this
					},
					bringToBack : function() {
						var t = this._map._panes.overlayPane;
						return this._image && t.insertBefore(this._image, t.firstChild), this
					},
					setUrl : function(t) {
						this._url = t, this._image.src = this._url
					},
					getAttribution : function() {
						return this.options.attribution
					},
					_initImage : function() {
						this._image = o.DomUtil.create("img", "leaflet-image-layer"), this._map.options.zoomAnimation && o.Browser.any3d ? o.DomUtil.addClass(this._image, "leaflet-zoom-animated") : o.DomUtil.addClass(this._image, "leaflet-zoom-hide"), this._updateOpacity(), o.extend(this._image, {
							galleryimg : "no",
							onselectstart : o.Util.falseFn,
							onmousemove : o.Util.falseFn,
							onload : o.bind(this._onImageLoad, this),
							src : this._url
						})
					},
					_animateZoom : function(t) {
						var e = this._map,
						    i = this._image,
						    n = e.getZoomScale(t.zoom),
						    s = this._bounds.getNorthWest(),
						    a = this._bounds.getSouthEast(),
						    r = e._latLngToNewLayerPoint(s, t.zoom, t.center),
						    h = e._latLngToNewLayerPoint(a, t.zoom, t.center)._subtract(r),
						    l = r._add(h._multiplyBy(.5 * (1 - 1 / n)));
						i.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(l) + " scale(" + n + ") "
					},
					_reset : function() {
						var t = this._image,
						    e = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
						    i = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);
						o.DomUtil.setPosition(t, e), t.style.width = i.x + "px", t.style.height = i.y + "px"
					},
					_onImageLoad : function() {
						this.fire("load")
					},
					_updateOpacity : function() {
						o.DomUtil.setOpacity(this._image, this.options.opacity)
					}
				}), o.imageOverlay = function(t, e, i) {
					return new o.ImageOverlay(t, e, i)
				}, o.Icon = o.Class.extend({
					options : {
						className : ""
					},
					initialize : function(t) {
						o.setOptions(this, t)
					},
					createIcon : function(t) {
						return this._createIcon("icon", t)
					},
					createShadow : function(t) {
						return this._createIcon("shadow", t)
					},
					_createIcon : function(t, e) {
						var i = this._getIconUrl(t);
						if (!i) {
							if ("icon" === t)
								throw new Error("iconUrl not set in Icon options (see the docs).");
							return null
						}
						var n;
						return n = e && "IMG" === e.tagName ? this._createImg(i, e) : this._createImg(i), this._setIconStyles(n, t), n
					},
					_setIconStyles : function(t, e) {
						var i,
						    n = this.options,
						    s = o.point(n[e + "Size"]);
						i = "shadow" === e ? o.point(n.shadowAnchor || n.iconAnchor) : o.point(n.iconAnchor), !i && s && ( i = s.divideBy(2, !0)), t.className = "leaflet-marker-" + e + " " + n.className, i && (t.style.marginLeft = -i.x + "px", t.style.marginTop = -i.y + "px"), s && (t.style.width = s.x + "px", t.style.height = s.y + "px")
					},
					_createImg : function(t, i) {
						return i = i || e.createElement("img"), i.src =
						t, i
					},
					_getIconUrl : function(t) {
						return o.Browser.retina && this.options[t + "RetinaUrl"] ? this.options[t + "RetinaUrl"] : this.options[t + "Url"]
					}
				}), o.icon = function(t) {
					return new o.Icon(t)
				}, o.Icon.Default = o.Icon.extend({
					options : {
						iconSize : [25, 41],
						iconAnchor : [12, 41],
						popupAnchor : [1, -34],
						shadowSize : [41, 41]
					},
					_getIconUrl : function(t) {
						var e = t + "Url";
						if (this.options[e])
							return this.options[e];
						o.Browser.retina && "icon" === t && (t += "-2x");
						var i = o.Icon.Default.imagePath;
						if (!i)
							throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
						return i + "/marker-" + t + ".png"
					}
				}), o.Icon.Default.imagePath = function() {
					var t,
					    i,
					    n,
					    o,
					    s,
					    a = e.getElementsByTagName("script"),
					    r = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
					for ( t = 0,
					i = a.length; i > t; t++)
						if ( n = a[t].src,
							o = n.match(r))
							return s = n.split(r)[0], ( s ? s + "/" : "") + "images"
				}(), o.Marker = o.Class.extend({
					includes : o.Mixin.Events,
					options : {
						icon : new o.Icon.Default,
						title : "",
						alt : "",
						clickable : !0,
						draggable : !1,
						keyboard : !0,
						zIndexOffset : 0,
						opacity : 1,
						riseOnHover : !1,
						riseOffset : 250
					},
					initialize : function(t, e) {
						o.setOptions(this, e), this._latlng = o.latLng(t)
					},
					onAdd : function(t) {
						this._map = t, t.on("viewreset", this.update, this), this._initIcon(), this.update(), this.fire("add"), t.options.zoomAnimation && t.options.markerZoomAnimation && t.on("zoomanim", this._animateZoom, this)
					},
					addTo : function(t) {
						return t.addLayer(this), this
					},
					onRemove : function(t) {
						this.dragging && this.dragging.disable(), this._removeIcon(), this._removeShadow(), this.fire("remove"), t.off({
							viewreset : this.update,
							zoomanim : this._animateZoom
						}, this), this._map = null
					},
					getLatLng : function() {
						return this._latlng
					},
					setLatLng : function(t) {
						return this._latlng = o.latLng(t), this.update(), this.fire("move", {
							latlng : this._latlng
						})
					},
					setZIndexOffset : function(t) {
						return this.options.zIndexOffset = t, this.update(), this
					},
					setIcon : function(t) {
						return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup), this
					},
					update : function() {
						if (this._icon) {
							var t = this._map.latLngToLayerPoint(this._latlng).round();
							this._setPos(t)
						}
						return this
					},
					_initIcon : function() {
						var t = this.options,
						    e = this._map,
						    i = e.options.zoomAnimation && e.options.markerZoomAnimation,
						    n = i ? "leaflet-zoom-animated" : "leaflet-zoom-hide",
						    s = t.icon.createIcon(this._icon),
						    a = !1;
						s !== this._icon && (this._icon && this._removeIcon(),
						a = !0, t.title && (s.title = t.title), t.alt && (s.alt = t.alt)), o.DomUtil.addClass(s, n), t.keyboard && (s.tabIndex = "0"), this._icon =
						s, this._initInteraction(), t.riseOnHover && o.DomEvent.on(s, "mouseover", this._bringToFront, this).on(s, "mouseout", this._resetZIndex, this);
						var r = t.icon.createShadow(this._shadow),
						    h = !1;
						r !== this._shadow && (this._removeShadow(),
						h = !0), r && o.DomUtil.addClass(r, n), this._shadow =
						r, t.opacity < 1 && this._updateOpacity();
						var l = this._map._panes;
						a && l.markerPane.appendChild(this._icon), r && h && l.shadowPane.appendChild(this._shadow)
					},
					_removeIcon : function() {
						this.options.riseOnHover && o.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex), this._map._panes.markerPane.removeChild(this._icon), this._icon = null
					},
					_removeShadow : function() {
						this._shadow && this._map._panes.shadowPane.removeChild(this._shadow), this._shadow = null
					},
					_setPos : function(t) {
						o.DomUtil.setPosition(this._icon, t), this._shadow && o.DomUtil.setPosition(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex()
					},
					_updateZIndex : function(t) {
						this._icon.style.zIndex = this._zIndex + t
					},
					_animateZoom : function(t) {
						var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
						this._setPos(e)
					},
					_initInteraction : function() {
						if (this.options.clickable) {
							var t = this._icon,
							    e = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu"];
							o.DomUtil.addClass(t, "leaflet-clickable"), o.DomEvent.on(t, "click", this._onMouseClick, this), o.DomEvent.on(t, "keypress", this._onKeyPress, this);
							for (var i = 0; i < e.length; i++)
								o.DomEvent.on(t, e[i], this._fireMouseEvent, this);
							o.Handler.MarkerDrag && (this.dragging = new o.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable())
						}
					},
					_onMouseClick : function(t) {
						var e = this.dragging && this.dragging.moved();
						(this.hasEventListeners(t.type) || e) && o.DomEvent.stopPropagation(t), e || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(t.type, {
							originalEvent : t,
							latlng : this._latlng
						})
					},
					_onKeyPress : function(t) {
						13 === t.keyCode && this.fire("click", {
							originalEvent : t,
							latlng : this._latlng
						})
					},
					_fireMouseEvent : function(t) {
						this.fire(t.type, {
							originalEvent : t,
							latlng : this._latlng
						}), "contextmenu" === t.type && this.hasEventListeners(t.type) && o.DomEvent.preventDefault(t), "mousedown" !== t.type ? o.DomEvent.stopPropagation(t) : o.DomEvent.preventDefault(t)
					},
					setOpacity : function(t) {
						return this.options.opacity = t, this._map && this._updateOpacity(), this
					},
					_updateOpacity : function() {
						o.DomUtil.setOpacity(this._icon, this.options.opacity), this._shadow && o.DomUtil.setOpacity(this._shadow, this.options.opacity)
					},
					_bringToFront : function() {
						this._updateZIndex(this.options.riseOffset)
					},
					_resetZIndex : function() {
						this._updateZIndex(0)
					}
				}), o.marker = function(t, e) {
					return new o.Marker(t, e)
				}, o.DivIcon = o.Icon.extend({
					options : {
						iconSize : [12, 12],
						className : "leaflet-div-icon",
						html : !1
					},
					createIcon : function(t) {
						var i = t && "DIV" === t.tagName ? t : e.createElement("div"),
						    n = this.options;
						return i.innerHTML = n.html !== !1 ? n.html : "", n.bgPos && (i.style.backgroundPosition = -n.bgPos.x + "px " + -n.bgPos.y + "px"), this._setIconStyles(i, "icon"), i
					},
					createShadow : function() {
						return null
					}
				}), o.divIcon = function(t) {
					return new o.DivIcon(t)
				}, o.Map.mergeOptions({
					closePopupOnClick : !0
				}), o.Popup = o.Class.extend({
					includes : o.Mixin.Events,
					options : {
						minWidth : 50,
						maxWidth : 300,
						autoPan : !0,
						closeButton : !0,
						offset : [0, 7],
						autoPanPadding : [5, 5],
						keepInView : !1,
						className : "",
						zoomAnimation : !0
					},
					initialize : function(t, e) {
						o.setOptions(this, t), this._source =
						e, this._animated = o.Browser.any3d && this.options.zoomAnimation, this._isOpen = !1
					},
					onAdd : function(t) {
						this._map = t, this._container || this._initLayout();
						var e = t.options.fadeAnimation;
						e && o.DomUtil.setOpacity(this._container, 0), t._panes.popupPane.appendChild(this._container), t.on(this._getEvents(), this), this.update(), e && o.DomUtil.setOpacity(this._container, 1), this.fire("open"), t.fire("popupopen", {
							popup : this
						}), this._source && this._source.fire("popupopen", {
							popup : this
						})
					},
					addTo : function(t) {
						return t.addLayer(this), this
					},
					openOn : function(t) {
						return t.openPopup(this), this
					},
					onRemove : function(t) {
						t._panes.popupPane.removeChild(this._container), o.Util.falseFn(this._container.offsetWidth), t.off(this._getEvents(), this), t.options.fadeAnimation && o.DomUtil.setOpacity(this._container, 0), this._map = null, this.fire("close"), t.fire("popupclose", {
							popup : this
						}), this._source && this._source.fire("popupclose", {
							popup : this
						})
					},
					getLatLng : function() {
						return this._latlng
					},
					setLatLng : function(t) {
						return this._latlng = o.latLng(t), this._map && (this._updatePosition(), this._adjustPan()), this
					},
					getContent : function() {
						return this._content
					},
					setContent : function(t) {
						return this._content = t, this.update(), this
					},
					update : function() {
						this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan())
					},
					_getEvents : function() {
						var t = {
							viewreset : this._updatePosition
						};
						return this._animated && (t.zoomanim = this._zoomAnimation), ("closeOnClick" in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t
					},
					_close : function() {
						this._map && this._map.closePopup(this)
					},
					_initLayout : function() {
						var t,
						    e = "leaflet-popup",
						    i = e + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"),
						    n = this._container = o.DomUtil.create("div", i);
						this.options.closeButton && ( t = this._closeButton = o.DomUtil.create("a", e + "-close-button", n), t.href = "#close", t.innerHTML = "&#215;", o.DomEvent.disableClickPropagation(t), o.DomEvent.on(t, "click", this._onCloseButtonClick, this));
						var s = this._wrapper = o.DomUtil.create("div", e + "-content-wrapper", n);
						o.DomEvent.disableClickPropagation(s), this._contentNode = o.DomUtil.create("div", e + "-content", s), o.DomEvent.disableScrollPropagation(this._contentNode), o.DomEvent.on(s, "contextmenu", o.DomEvent.stopPropagation), this._tipContainer = o.DomUtil.create("div", e + "-tip-container", n), this._tip = o.DomUtil.create("div", e + "-tip", this._tipContainer)
					},
					_updateContent : function() {
						if (this._content) {
							if ("string" == typeof this._content)
								this._contentNode.innerHTML = this._content;
							else {
								for (; this._contentNode.hasChildNodes(); )
									this._contentNode.removeChild(this._contentNode.firstChild);
								this._contentNode.appendChild(this._content)
							}
							this.fire("contentupdate")
						}
					},
					_updateLayout : function() {
						var t = this._contentNode,
						    e = t.style;
						e.width = "", e.whiteSpace = "nowrap";
						var i = t.offsetWidth;
						i = Math.min(i, this.options.maxWidth),
						i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = "";
						var n = t.offsetHeight,
						    s = this.options.maxHeight,
						    a = "leaflet-popup-scrolled";
						s && n > s ? (e.height = s + "px", o.DomUtil.addClass(t, a)) : o.DomUtil.removeClass(t, a), this._containerWidth = this._container.offsetWidth
					},
					_updatePosition : function() {
						if (this._map) {
							var t = this._map.latLngToLayerPoint(this._latlng),
							    e = this._animated,
							    i = o.point(this.options.offset);
							e && o.DomUtil.setPosition(this._container, t), this._containerBottom = -i.y - ( e ? 0 : t.y), this._containerLeft = -Math.round(this._containerWidth / 2) + i.x + ( e ? 0 : t.x), this._container.style.bottom = this._containerBottom + "px", this._container.style.left = this._containerLeft + "px"
						}
					},
					_zoomAnimation : function(t) {
						var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
						o.DomUtil.setPosition(this._container, e)
					},
					_adjustPan : function() {
						if (this.options.autoPan) {
							var t = this._map,
							    e = this._container.offsetHeight,
							    i = this._containerWidth,
							    n = new o.Point(this._containerLeft, -e - this._containerBottom);
							this._animated && n._add(o.DomUtil.getPosition(this._container));
							var s = t.layerPointToContainerPoint(n),
							    a = o.point(this.options.autoPanPadding),
							    r = o.point(this.options.autoPanPaddingTopLeft || a),
							    h = o.point(this.options.autoPanPaddingBottomRight || a),
							    l = t.getSize(),
							    u = 0,
							    c = 0;
							s.x + i + h.x > l.x && ( u = s.x + i - l.x + h.x), s.x - u - r.x < 0 && ( u = s.x - r.x), s.y + e + h.y > l.y && ( c = s.y + e - l.y + h.y), s.y - c - r.y < 0 && ( c = s.y - r.y), (u || c) && t.fire("autopanstart").panBy([u, c])
						}
					},
					_onCloseButtonClick : function(t) {
						this._close(), o.DomEvent.stop(t)
					}
				}), o.popup = function(t, e) {
					return new o.Popup(t, e)
				}, o.Map.include({
					openPopup : function(t, e, i) {
						if (this.closePopup(), !( t instanceof o.Popup)) {
							var n = t;
							t = new o.Popup(i).setLatLng(e).setContent(n)
						}
						return t._isOpen = !0, this._popup =
						t, this.addLayer(t)
					},
					closePopup : function(t) {
						return t && t !== this._popup || ( t = this._popup, this._popup = null), t && (this.removeLayer(t), t._isOpen = !1), this
					}
				}), o.Marker.include({
					openPopup : function() {
						return this._popup && this._map && !this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng), this._map.openPopup(this._popup)), this
					},
					closePopup : function() {
						return this._popup && this._popup._close(), this
					},
					togglePopup : function() {
						return this._popup && (this._popup._isOpen ? this.closePopup() : this.openPopup()), this
					},
					bindPopup : function(t, e) {
						var i = o.point(this.options.icon.options.popupAnchor || [0, 0]);
						return i = i.add(o.Popup.prototype.options.offset), e && e.offset && ( i = i.add(e.offset)),
						e = o.extend({
							offset : i
						}, e), this._popupHandlersAdded || (this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this), this._popupHandlersAdded = !0), t instanceof o.Popup ? (o.setOptions(t, e), this._popup =
						t) : this._popup = new o.Popup(e, this).setContent(t), this
					},
					setPopupContent : function(t) {
						return this._popup && this._popup.setContent(t), this
					},
					unbindPopup : function() {
						return this._popup && (this._popup = null, this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this), this._popupHandlersAdded = !1), this
					},
					getPopup : function() {
						return this._popup
					},
					_movePopup : function(t) {
						this._popup.setLatLng(t.latlng)
					}
				}), o.LayerGroup = o.Class.extend({
					initialize : function(t) {
						this._layers = {};
						var e,
						    i;
						if (t)
							for ( e = 0,
							i = t.length; i > e; e++)
								this.addLayer(t[e])
					},
					addLayer : function(t) {
						var e = this.getLayerId(t);
						return this._layers[e] = t, this._map && this._map.addLayer(t), this
					},
					removeLayer : function(t) {
						var e = t in this._layers ? t : this.getLayerId(t);
						return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]),
						delete this._layers[e], this
					},
					hasLayer : function(t) {
						return t ? t in this._layers || this.getLayerId(t) in this._layers : !1
					},
					clearLayers : function() {
						return this.eachLayer(this.removeLayer, this), this
					},
					invoke : function(t) {
						var e,
						    i,
						    n = Array.prototype.slice.call(arguments, 1);
						for (e in this._layers) i = this._layers[e], i[t] && i[t].apply(i, n);
						return this
					},
					onAdd : function(t) {
						this._map = t, this.eachLayer(t.addLayer, t)
					},
					onRemove : function(t) {
						this.eachLayer(t.removeLayer, t), this._map = null
					},
					addTo : function(t) {
						return t.addLayer(this), this
					},
					eachLayer : function(t, e) {
						for (var i in this._layers)
						t.call(e, this._layers[i]);
						return this
					},
					getLayer : function(t) {
						return this._layers[t]
					},
					getLayers : function() {
						var t = [];
						for (var e in this._layers)
						t.push(this._layers[e]);
						return t
					},
					setZIndex : function(t) {
						return this.invoke("setZIndex", t)
					},
					getLayerId : function(t) {
						return o.stamp(t)
					}
				}), o.layerGroup = function(t) {
					return new o.LayerGroup(t)
				}, o.FeatureGroup = o.LayerGroup.extend({
					includes : o.Mixin.Events,
					statics : {
						EVENTS : "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"
					},
					addLayer : function(t) {
						return this.hasLayer(t) ? this : ("on" in t && t.on(o.FeatureGroup.EVENTS, this._propagateEvent, this), o.LayerGroup.prototype.addLayer.call(this, t), this._popupContent && t.bindPopup && t.bindPopup(this._popupContent, this._popupOptions), this.fire("layeradd", {
							layer : t
						}))
					},
					removeLayer : function(t) {
						return this.hasLayer(t) ? ( t in this._layers && ( t = this._layers[t]), t.off(o.FeatureGroup.EVENTS, this._propagateEvent, this), o.LayerGroup.prototype.removeLayer.call(this, t), this._popupContent && this.invoke("unbindPopup"), this.fire("layerremove", {
							layer : t
						})) : this
					},
					bindPopup : function(t, e) {
						return this._popupContent = t, this._popupOptions =
						e, this.invoke("bindPopup", t, e)
					},
					openPopup : function(t) {
						for (var e in this._layers) {
							this._layers[e].openPopup(t);
							break
						}
						return this
					},
					setStyle : function(t) {
						return this.invoke("setStyle", t)
					},
					bringToFront : function() {
						return this.invoke("bringToFront")
					},
					bringToBack : function() {
						return this.invoke("bringToBack")
					},
					getBounds : function() {
						var t = new o.LatLngBounds;
						return this.eachLayer(function(e) {
							t.extend( e instanceof o.Marker ? e.getLatLng() : e.getBounds())
						}), t
					},
					_propagateEvent : function(t) {
						t = o.extend({
							layer : t.target,
							target : this
						}, t), this.fire(t.type, t)
					}
				}), o.featureGroup = function(t) {
					return new o.FeatureGroup(t)
				}, o.Path = o.Class.extend({
					includes : [o.Mixin.Events],
					statics : {
						CLIP_PADDING : function() {
							var e = o.Browser.mobile ? 1280 : 2e3,
							    i = (e / Math.max(t.outerWidth, t.outerHeight) - 1) / 2;
							return Math.max(0, Math.min(.5, i))
						}()
					},
					options : {
						stroke : !0,
						color : "#0033ff",
						dashArray : null,
						lineCap : null,
						lineJoin : null,
						weight : 5,
						opacity : .5,
						fill : !1,
						fillColor : null,
						fillOpacity : .2,
						clickable : !0
					},
					initialize : function(t) {
						o.setOptions(this, t)
					},
					onAdd : function(t) {
						this._map = t, this._container || (this._initElements(), this._initEvents()), this.projectLatlngs(), this._updatePath(), this._container && this._map._pathRoot.appendChild(this._container), this.fire("add"), t.on({
							viewreset : this.projectLatlngs,
							moveend : this._updatePath
						}, this)
					},
					addTo : function(t) {
						return t.addLayer(this), this
					},
					onRemove : function(t) {
						t._pathRoot.removeChild(this._container), this.fire("remove"), this._map = null, o.Browser.vml && (this._container = null, this._stroke = null, this._fill = null), t.off({
							viewreset : this.projectLatlngs,
							moveend : this._updatePath
						}, this)
					},
					projectLatlngs : function() {
					},
					setStyle : function(t) {
						return o.setOptions(this, t), this._container && this._updateStyle(), this
					},
					redraw : function() {
						return this._map && (this.projectLatlngs(), this._updatePath()), this
					}
				}), o.Map.include({
					_updatePathViewport : function() {
						var t = o.Path.CLIP_PADDING,
						    e = this.getSize(),
						    i = o.DomUtil.getPosition(this._mapPane),
						    n = i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),
						    s = n.add(e.multiplyBy(1 + 2 * t)._round());
						this._pathViewport = new o.Bounds(n, s)
					}
				}), o.Path.SVG_NS = "http://www.w3.org/2000/svg", o.Browser.svg = !(!e.createElementNS || !e.createElementNS(o.Path.SVG_NS, "svg").createSVGRect), o.Path = o.Path.extend({
					statics : {
						SVG : o.Browser.svg
					},
					bringToFront : function() {
						var t = this._map._pathRoot,
						    e = this._container;
						return e && t.lastChild !== e && t.appendChild(e), this
					},
					bringToBack : function() {
						var t = this._map._pathRoot,
						    e = this._container,
						    i = t.firstChild;
						return e && i !== e && t.insertBefore(e, i), this
					},
					getPathString : function() {
					},
					_createElement : function(t) {
						return e.createElementNS(o.Path.SVG_NS, t)
					},
					_initElements : function() {
						this._map._initPathRoot(), this._initPath(), this._initStyle()
					},
					_initPath : function() {
						this._container = this._createElement("g"), this._path = this._createElement("path"), this.options.className && o.DomUtil.addClass(this._path, this.options.className), this._container.appendChild(this._path)
					},
					_initStyle : function() {
						this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"), this._path.setAttribute("stroke-linecap", "round")), this.options.fill && this._path.setAttribute("fill-rule", "evenodd"), this.options.pointerEvents && this._path.setAttribute("pointer-events", this.options.pointerEvents), this.options.clickable || this.options.pointerEvents || this._path.setAttribute("pointer-events", "none"), this._updateStyle()
					},
					_updateStyle : function() {
						this.options.stroke ? (this._path.setAttribute("stroke", this.options.color), this._path.setAttribute("stroke-opacity", this.options.opacity), this._path.setAttribute("stroke-width", this.options.weight), this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray"), this.options.lineCap && this._path.setAttribute("stroke-linecap", this.options.lineCap), this.options.lineJoin && this._path.setAttribute("stroke-linejoin", this.options.lineJoin)) : this._path.setAttribute("stroke", "none"), this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color), this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none")
					},
					_updatePath : function() {
						var t = this.getPathString();
						t || ( t = "M0 0"), this._path.setAttribute("d", t)
					},
					_initEvents : function() {
						if (this.options.clickable) {
							(o.Browser.svg || !o.Browser.vml) && o.DomUtil.addClass(this._path, "leaflet-clickable"), o.DomEvent.on(this._container, "click", this._onMouseClick, this);
							for (var t = ["dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu"],
							    e = 0; e < t.length; e++)
								o.DomEvent.on(this._container, t[e], this._fireMouseEvent, this)
						}
					},
					_onMouseClick : function(t) {
						this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(t)
					},
					_fireMouseEvent : function(t) {
						if (this.hasEventListeners(t.type)) {
							var e = this._map,
							    i = e.mouseEventToContainerPoint(t),
							    n = e.containerPointToLayerPoint(i),
							    s = e.layerPointToLatLng(n);
							this.fire(t.type, {
								latlng : s,
								layerPoint : n,
								containerPoint : i,
								originalEvent : t
							}), "contextmenu" === t.type && o.DomEvent.preventDefault(t), "mousemove" !== t.type && o.DomEvent.stopPropagation(t)
						}
					}
				}), o.Map.include({
					_initPathRoot : function() {
						this._pathRoot || (this._pathRoot = o.Path.prototype._createElement("svg"), this._panes.overlayPane.appendChild(this._pathRoot), this.options.zoomAnimation && o.Browser.any3d ? (o.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated"), this.on({
							zoomanim : this._animatePathZoom,
							zoomend : this._endPathZoom
						})) : o.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide"), this.on("moveend", this._updateSvgViewport), this._updateSvgViewport())
					},
					_animatePathZoom : function(t) {
						var e = this.getZoomScale(t.zoom),
						    i = this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);
						this._pathRoot.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(i) + " scale(" + e + ") ", this._pathZooming = !0
					},
					_endPathZoom : function() {
						this._pathZooming = !1
					},
					_updateSvgViewport : function() {
						if (!this._pathZooming) {
							this._updatePathViewport();
							var t = this._pathViewport,
							    e = t.min,
							    i = t.max,
							    n = i.x - e.x,
							    s = i.y - e.y,
							    a = this._pathRoot,
							    r = this._panes.overlayPane;
							o.Browser.mobileWebkit && r.removeChild(a), o.DomUtil.setPosition(a, e), a.setAttribute("width", n), a.setAttribute("height", s), a.setAttribute("viewBox", [e.x, e.y, n, s].join(" ")), o.Browser.mobileWebkit && r.appendChild(a)
						}
					}
				}), o.Path.include({
					bindPopup : function(t, e) {
						return t instanceof o.Popup ? this._popup = t : ((!this._popup || e) && (this._popup = new o.Popup(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this), this._popupHandlersAdded = !0), this
					},
					unbindPopup : function() {
						return this._popup && (this._popup = null, this.off("click", this._openPopup).off("remove", this.closePopup), this._popupHandlersAdded = !1), this
					},
					openPopup : function(t) {
						return this._popup && ( t = t || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)], this._openPopup({
							latlng : t
						})), this
					},
					closePopup : function() {
						return this._popup && this._popup._close(), this
					},
					_openPopup : function(t) {
						this._popup.setLatLng(t.latlng), this._map.openPopup(this._popup)
					}
				}), o.Browser.vml = !o.Browser.svg && function() {
					try {
						var t = e.createElement("div");
						t.innerHTML = '<v:shape adj="1"/>';
						var i = t.firstChild;
						return i.style.behavior = "url(#default#VML)", i && "object" == typeof i.adj
					} catch(n) {
						return !1
					}
				}(), o.Path = o.Browser.svg || !o.Browser.vml ? o.Path : o.Path.extend({
					statics : {
						VML : !0,
						CLIP_PADDING : .02
					},
					_createElement : function() {
						try {
							return e.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
							function(t) {
								return e.createElement("<lvml:" + t + ' class="lvml">')
							}

						} catch(t) {
							return function(t) {
								return e.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
							}
						}
					}(),
					_initPath : function() {
						var t = this._container = this._createElement("shape");
						o.DomUtil.addClass(t, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : "")), this.options.clickable && o.DomUtil.addClass(t, "leaflet-clickable"), t.coordsize = "1 1", this._path = this._createElement("path"), t.appendChild(this._path), this._map._pathRoot.appendChild(t)
					},
					_initStyle : function() {
						this._updateStyle()
					},
					_updateStyle : function() {
						var t = this._stroke,
						    e = this._fill,
						    i = this.options,
						    n = this._container;
						n.stroked = i.stroke, n.filled = i.fill, i.stroke ? (t || ( t = this._stroke = this._createElement("stroke"), t.endcap = "round", n.appendChild(t)), t.weight = i.weight + "px", t.color = i.color, t.opacity = i.opacity, t.dashStyle = i.dashArray ? o.Util.isArray(i.dashArray) ? i.dashArray.join(" ") : i.dashArray.replace(/( *, *)/g, " ") : "", i.lineCap && (t.endcap = i.lineCap.replace("butt", "flat")), i.lineJoin && (t.joinstyle = i.lineJoin)) : t && (n.removeChild(t), this._stroke = null), i.fill ? (e || ( e = this._fill = this._createElement("fill"), n.appendChild(e)), e.color = i.fillColor || i.color, e.opacity = i.fillOpacity) : e && (n.removeChild(e), this._fill = null)
					},
					_updatePath : function() {
						var t = this._container.style;
						t.display = "none", this._path.v = this.getPathString() + " ", t.display = ""
					}
				}), o.Map.include(o.Browser.svg || !o.Browser.vml ? {} : {
					_initPathRoot : function() {
						if (!this._pathRoot) {
							var t = this._pathRoot = e.createElement("div");
							t.className = "leaflet-vml-container", this._panes.overlayPane.appendChild(t), this.on("moveend", this._updatePathViewport), this._updatePathViewport()
						}
					}
				}), o.Browser.canvas = function() {
					return !!e.createElement("canvas").getContext
				}(), o.Path = o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? o.Path : o.Path.extend({
					statics : {
						CANVAS : !0,
						SVG : !1
					},
					redraw : function() {
						return this._map && (this.projectLatlngs(), this._requestUpdate()), this
					},
					setStyle : function(t) {
						return o.setOptions(this, t), this._map && (this._updateStyle(), this._requestUpdate()), this
					},
					onRemove : function(t) {
						t.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this), this.options.clickable && (this._map.off("click", this._onClick, this), this._map.off("mousemove", this._onMouseMove, this)), this._requestUpdate(), this._map = null
					},
					_requestUpdate : function() {
						this._map && !o.Path._updateRequest && (o.Path._updateRequest = o.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
					},
					_fireMapMoveEnd : function() {
						o.Path._updateRequest = null, this.fire("moveend")
					},
					_initElements : function() {
						this._map._initPathRoot(), this._ctx = this._map._canvasCtx
					},
					_updateStyle : function() {
						var t = this.options;
						t.stroke && (this._ctx.lineWidth = t.weight, this._ctx.strokeStyle = t.color), t.fill && (this._ctx.fillStyle = t.fillColor || t.color)
					},
					_drawPath : function() {
						var t,
						    e,
						    i,
						    n,
						    s,
						    a;
						for (this._ctx.beginPath(),
						t = 0,
						i = this._parts.length; i > t; t++) {
							for ( e = 0,
							n = this._parts[t].length; n > e; e++)
								s = this._parts[t][e],
								a = (0 === e ? "move" : "line") + "To", this._ctx[a](s.x, s.y);
							this instanceof o.Polygon && this._ctx.closePath()
						}
					},
					_checkIfEmpty : function() {
						return !this._parts.length
					},
					_updatePath : function() {
						if (!this._checkIfEmpty()) {
							var t = this._ctx,
							    e = this.options;
							this._drawPath(), t.save(), this._updateStyle(), e.fill && (t.globalAlpha = e.fillOpacity, t.fill()), e.stroke && (t.globalAlpha = e.opacity, t.stroke()), t.restore()
						}
					},
					_initEvents : function() {
						this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this), this._map.on("click", this._onClick, this))
					},
					_onClick : function(t) {
						this._containsPoint(t.layerPoint) && this.fire("click", t)
					},
					_onMouseMove : function(t) {
						this._map && !this._map._animatingZoom && (this._containsPoint(t.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer", this._mouseInside = !0, this.fire("mouseover", t)) : this._mouseInside && (this._ctx.canvas.style.cursor = "", this._mouseInside = !1, this.fire("mouseout", t)))
					}
				}), o.Map.include(o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? {} : {
					_initPathRoot : function() {
						var t,
						    i = this._pathRoot;
						i || ( i = this._pathRoot = e.createElement("canvas"), i.style.position = "absolute",
						t = this._canvasCtx = i.getContext("2d"), t.lineCap = "round", t.lineJoin = "round", this._panes.overlayPane.appendChild(i), this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated", this.on("zoomanim", this._animatePathZoom), this.on("zoomend", this._endPathZoom)), this.on("moveend", this._updateCanvasViewport), this._updateCanvasViewport())
					},
					_updateCanvasViewport : function() {
						if (!this._pathZooming) {
							this._updatePathViewport();
							var t = this._pathViewport,
							    e = t.min,
							    i = t.max.subtract(e),
							    n = this._pathRoot;
							o.DomUtil.setPosition(n, e), n.width = i.x, n.height = i.y, n.getContext("2d").translate(-e.x, -e.y)
						}
					}
				}), o.LineUtil = {
					simplify : function(t, e) {
						if (!e || !t.length)
							return t.slice();
						var i = e * e;
						return t = this._reducePoints(t, i),
						t = this._simplifyDP(t, i)
					},
					pointToSegmentDistance : function(t, e, i) {
						return Math.sqrt(this._sqClosestPointOnSegment(t, e, i, !0))
					},
					closestPointOnSegment : function(t, e, i) {
						return this._sqClosestPointOnSegment(t, e, i)
					},
					_simplifyDP : function(t, e) {
						var n = t.length,
						    o = typeof Uint8Array != i + "" ? Uint8Array : Array,
						    s = new o(n);
						s[0] = s[n - 1] = 1, this._simplifyDPStep(t, s, e, 0, n - 1);
						var a,
						    r = [];
						for ( a = 0; n > a; a++)
							s[a] && r.push(t[a]);
						return r
					},
					_simplifyDPStep : function(t, e, i, n, o) {
						var s,
						    a,
						    r,
						    h = 0;
						for ( a = n + 1; o - 1 >= a; a++)
							r = this._sqClosestPointOnSegment(t[a], t[n], t[o], !0), r > h && ( s = a,
							h =
							r);
						h > i && (e[s] = 1, this._simplifyDPStep(t, e, i, n, s), this._simplifyDPStep(t, e, i, s, o))
					},
					_reducePoints : function(t, e) {
						for (var i = [t[0]],
						    n = 1,
						    o = 0,
						    s = t.length; s > n; n++)
							this._sqDist(t[n], t[o]) > e && (i.push(t[n]),
							o =
							n);
						return s - 1 > o && i.push(t[s - 1]), i
					},
					clipSegment : function(t, e, i, n) {
						var o,
						    s,
						    a,
						    r = n ? this._lastCode : this._getBitCode(t, i),
						    h = this._getBitCode(e, i);
						for (this._lastCode = h; ; ) {
							if (!(r | h))
								return [t, e];
							if (r & h)
								return !1;
							o = r || h,
							s = this._getEdgeIntersection(t, e, o, i),
							a = this._getBitCode(s, i), o === r ? ( t = s,
							r =
							a) : ( e = s,
							h =
							a)
						}
					},
					_getEdgeIntersection : function(t, e, i, n) {
						var s = e.x - t.x,
						    a = e.y - t.y,
						    r = n.min,
						    h = n.max;
						return 8 & i ? new o.Point(t.x + s * (h.y - t.y) / a, h.y) : 4 & i ? new o.Point(t.x + s * (r.y - t.y) / a, r.y) : 2 & i ? new o.Point(h.x, t.y + a * (h.x - t.x) / s) : 1 & i ? new o.Point(r.x, t.y + a * (r.x - t.x) / s) :
						void 0
					},
					_getBitCode : function(t, e) {
						var i = 0;
						return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i
					},
					_sqDist : function(t, e) {
						var i = e.x - t.x,
						    n = e.y - t.y;
						return i * i + n * n
					},
					_sqClosestPointOnSegment : function(t, e, i, n) {
						var s,
						    a = e.x,
						    r = e.y,
						    h = i.x - a,
						    l = i.y - r,
						    u = h * h + l * l;
						return u > 0 && ( s = ((t.x - a) * h + (t.y - r) * l) / u, s > 1 ? ( a = i.x,
						r = i.y) : s > 0 && (a += h * s, r += l * s)),
						h = t.x - a,
						l = t.y - r, n ? h * h + l * l : new o.Point(a, r)
					}
				}, o.Polyline = o.Path.extend({
					initialize : function(t, e) {
						o.Path.prototype.initialize.call(this, e), this._latlngs = this._convertLatLngs(t)
					},
					options : {
						smoothFactor : 1,
						noClip : !1
					},
					projectLatlngs : function() {
						this._originalPoints = [];
						for (var t = 0,
						    e = this._latlngs.length; e > t; t++)
							this._originalPoints[t] = this._map.latLngToLayerPoint(this._latlngs[t])
					},
					getPathString : function() {
						for (var t = 0,
						    e = this._parts.length,
						    i = ""; e > t; t++)
							i += this._getPathPartStr(this._parts[t]);
						return i
					},
					getLatLngs : function() {
						return this._latlngs
					},
					setLatLngs : function(t) {
						return this._latlngs = this._convertLatLngs(t), this.redraw()
					},
					addLatLng : function(t) {
						return this._latlngs.push(o.latLng(t)), this.redraw()
					},
					spliceLatLngs : function() {
						var t = [].splice.apply(this._latlngs, arguments);
						return this._convertLatLngs(this._latlngs, !0), this.redraw(), t
					},
					closestLayerPoint : function(t) {
						for (var e,
						    i,
						    n = 1 / 0,
						    s = this._parts,
						    a = null,
						    r = 0,
						    h = s.length; h > r; r++)
							for (var l = s[r],
							    u = 1,
							    c = l.length; c > u; u++) {
								e = l[u - 1],
								i = l[u];
								var d = o.LineUtil._sqClosestPointOnSegment(t, e, i, !0);
								n > d && ( n = d,
								a = o.LineUtil._sqClosestPointOnSegment(t, e, i))
							}
						return a && (a.distance = Math.sqrt(n)), a
					},
					getBounds : function() {
						return new o.LatLngBounds(this.getLatLngs())
					},
					_convertLatLngs : function(t, e) {
						var i,
						    n,
						    s = e ? t : [];
						for ( i = 0,
						n = t.length; n > i; i++) {
							if (o.Util.isArray(t[i]) && "number" != typeof t[i][0])
								return;
							s[i] = o.latLng(t[i])
						}
						return s
					},
					_initEvents : function() {
						o.Path.prototype._initEvents.call(this)
					},
					_getPathPartStr : function(t) {
						for (var e,
						    i = o.Path.VML,
						    n = 0,
						    s = t.length,
						    a = ""; s > n; n++)
							e = t[n], i && e._round(), a += ( n ? "L" : "M") + e.x + " " + e.y;
						return a
					},
					_clipPoints : function() {
						var t,
						    e,
						    i,
						    n = this._originalPoints,
						    s = n.length;
						if (this.options.noClip)
							return this._parts = [n],
							void 0;
						this._parts = [];
						var a = this._parts,
						    r = this._map._pathViewport,
						    h = o.LineUtil;
						for ( t = 0,
						e = 0; s - 1 > t; t++)
							i = h.clipSegment(n[t], n[t + 1], r, t), i && (a[e] = a[e] || [], a[e].push(i[0]), (i[1] !== n[t + 1] || t === s - 2) && (a[e].push(i[1]), e++))
					},
					_simplifyPoints : function() {
						for (var t = this._parts,
						    e = o.LineUtil,
						    i = 0,
						    n = t.length; n > i; i++)
							t[i] = e.simplify(t[i], this.options.smoothFactor)
					},
					_updatePath : function() {
						this._map && (this._clipPoints(), this._simplifyPoints(), o.Path.prototype._updatePath.call(this))
					}
				}), o.polyline = function(t, e) {
					return new o.Polyline(t, e)
				}, o.PolyUtil = {}, o.PolyUtil.clipPolygon = function(t, e) {
					var i,
					    n,
					    s,
					    a,
					    r,
					    h,
					    l,
					    u,
					    c,
					    d = [1, 4, 2, 8],
					    p = o.LineUtil;
					for ( n = 0,
					l = t.length; l > n; n++)
						t[n]._code = p._getBitCode(t[n], e);
					for ( a = 0; 4 > a; a++) {
						for ( u = d[a],
						i = [],
						n = 0,
						l = t.length,
						s = l - 1; l > n; s = n++)
							r = t[n],
							h = t[s], r._code & u ? h._code & u || ( c = p._getEdgeIntersection(h, r, u, e), c._code = p._getBitCode(c, e), i.push(c)) : (h._code & u && ( c = p._getEdgeIntersection(h, r, u, e), c._code = p._getBitCode(c, e), i.push(c)), i.push(r));
						t = i
					}
					return t
				}, o.Polygon = o.Polyline.extend({
					options : {
						fill : !0
					},
					initialize : function(t, e) {
						o.Polyline.prototype.initialize.call(this, t, e), this._initWithHoles(t)
					},
					_initWithHoles : function(t) {
						var e,
						    i,
						    n;
						if (t && o.Util.isArray(t[0]) && "number" != typeof t[0][0])
							for (this._latlngs = this._convertLatLngs(t[0]), this._holes = t.slice(1),
							e = 0,
							i = this._holes.length; i > e; e++)
								n = this._holes[e] = this._convertLatLngs(this._holes[e]), n[0].equals(n[n.length - 1]) && n.pop();
						t = this._latlngs, t.length >= 2 && t[0].equals(t[t.length - 1]) && t.pop()
					},
					projectLatlngs : function() {
						if (o.Polyline.prototype.projectLatlngs.call(this), this._holePoints = [], this._holes) {
							var t,
							    e,
							    i,
							    n;
							for ( t = 0,
							i = this._holes.length; i > t; t++)
								for (this._holePoints[t] = [],
								e = 0,
								n = this._holes[t].length; n > e; e++)
									this._holePoints[t][e] = this._map.latLngToLayerPoint(this._holes[t][e])
						}
					},
					setLatLngs : function(t) {
						return t && o.Util.isArray(t[0]) && "number" != typeof t[0][0] ? (this._initWithHoles(t), this.redraw()) : o.Polyline.prototype.setLatLngs.call(this, t)
					},
					_clipPoints : function() {
						var t = this._originalPoints,
						    e = [];
						if (this._parts = [t].concat(this._holePoints), !this.options.noClip) {
							for (var i = 0,
							    n = this._parts.length; n > i; i++) {
								var s = o.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
								s.length && e.push(s)
							}
							this._parts = e
						}
					},
					_getPathPartStr : function(t) {
						var e = o.Polyline.prototype._getPathPartStr.call(this, t);
						return e + (o.Browser.svg ? "z" : "x")
					}
				}), o.polygon = function(t, e) {
					return new o.Polygon(t, e)
				}, function() {
					function t(t) {
						return o.FeatureGroup.extend({
							initialize : function(t, e) {
								this._layers = {}, this._options =
								e, this.setLatLngs(t)
							},
							setLatLngs : function(e) {
								var i = 0,
								    n = e.length;
								for (this.eachLayer(function(t) {
									n > i ? t.setLatLngs(e[i++]) : this.removeLayer(t)
								}, this); n > i; )
									this.addLayer(new t(e[i++], this._options));
								return this
							},
							getLatLngs : function() {
								var t = [];
								return this.eachLayer(function(e) {
									t.push(e.getLatLngs())
								}), t
							}
						})
					}


					o.MultiPolyline = t(o.Polyline), o.MultiPolygon = t(o.Polygon), o.multiPolyline = function(t, e) {
						return new o.MultiPolyline(t, e)
					}, o.multiPolygon = function(t, e) {
						return new o.MultiPolygon(t, e)
					}
				}(), o.Rectangle = o.Polygon.extend({
					initialize : function(t, e) {
						o.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(t), e)
					},
					setBounds : function(t) {
						this.setLatLngs(this._boundsToLatLngs(t))
					},
					_boundsToLatLngs : function(t) {
						return t = o.latLngBounds(t), [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]
					}
				}), o.rectangle = function(t, e) {
					return new o.Rectangle(t, e)
				}, o.Circle = o.Path.extend({
					initialize : function(t, e, i) {
						o.Path.prototype.initialize.call(this, i), this._latlng = o.latLng(t), this._mRadius =
						e
					},
					options : {
						fill : !0
					},
					setLatLng : function(t) {
						return this._latlng = o.latLng(t), this.redraw()
					},
					setRadius : function(t) {
						return this._mRadius = t, this.redraw()
					},
					projectLatlngs : function() {
						var t = this._getLngRadius(),
						    e = this._latlng,
						    i = this._map.latLngToLayerPoint([e.lat, e.lng - t]);
						this._point = this._map.latLngToLayerPoint(e), this._radius = Math.max(this._point.x - i.x, 1)
					},
					getBounds : function() {
						var t = this._getLngRadius(),
						    e = this._mRadius / 40075017 * 360,
						    i = this._latlng;
						return new o.LatLngBounds([i.lat - e, i.lng - t], [i.lat + e, i.lng + t])
					},
					getLatLng : function() {
						return this._latlng
					},
					getPathString : function() {
						var t = this._point,
						    e = this._radius;
						return this._checkIfEmpty() ? "" : o.Browser.svg ? "M" + t.x + "," + (t.y - e) + "A" + e + "," + e + ",0,1,1," + (t.x - .1) + "," + (t.y - e) + " z" : (t._round(),
						e = Math.round(e), "AL " + t.x + "," + t.y + " " + e + "," + e + " 0,23592600")
					},
					getRadius : function() {
						return this._mRadius
					},
					_getLatRadius : function() {
						return this._mRadius / 40075017 * 360
					},
					_getLngRadius : function() {
						return this._getLatRadius() / Math.cos(o.LatLng.DEG_TO_RAD * this._latlng.lat)
					},
					_checkIfEmpty : function() {
						if (!this._map)
							return !1;
						var t = this._map._pathViewport,
						    e = this._radius,
						    i = this._point;
						return i.x - e > t.max.x || i.y - e > t.max.y || i.x + e < t.min.x || i.y + e < t.min.y
					}
				}), o.circle = function(t, e, i) {
					return new o.Circle(t, e, i)
				}, o.CircleMarker = o.Circle.extend({
					options : {
						radius : 10,
						weight : 2
					},
					initialize : function(t, e) {
						o.Circle.prototype.initialize.call(this, t, null, e), this._radius = this.options.radius
					},
					projectLatlngs : function() {
						this._point = this._map.latLngToLayerPoint(this._latlng)
					},
					_updateStyle : function() {
						o.Circle.prototype._updateStyle.call(this), this.setRadius(this.options.radius)
					},
					setLatLng : function(t) {
						return o.Circle.prototype.setLatLng.call(this, t), this._popup && this._popup._isOpen && this._popup.setLatLng(t), this
					},
					setRadius : function(t) {
						return this.options.radius = this._radius = t, this.redraw()
					},
					getRadius : function() {
						return this._radius
					}
				}), o.circleMarker = function(t, e) {
					return new o.CircleMarker(t, e)
				}, o.Polyline.include(o.Path.CANVAS ? {
					_containsPoint : function(t, e) {
						var i,
						    n,
						    s,
						    a,
						    r,
						    h,
						    l,
						    u = this.options.weight / 2;
						for (o.Browser.touch && (u += 10),
						i = 0,
						a = this._parts.length; a > i; i++)
							for ( l = this._parts[i],
							n = 0,
							r = l.length,
							s = r - 1; r > n; s = n++)
								if ((e || 0 !== n) && ( h = o.LineUtil.pointToSegmentDistance(t, l[s], l[n]), u >= h))
									return !0;
						return !1
					}
				} : {}), o.Polygon.include(o.Path.CANVAS ? {
					_containsPoint : function(t) {
						var e,
						    i,
						    n,
						    s,
						    a,
						    r,
						    h,
						    l,
						    u = !1;
						if (o.Polyline.prototype._containsPoint.call(this, t, !0))
							return !0;
						for ( s = 0,
						h = this._parts.length; h > s; s++)
							for ( e = this._parts[s],
							a = 0,
							l = e.length,
							r = l - 1; l > a; r = a++)
								i = e[a],
								n = e[r], i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && ( u = !u);
						return u
					}
				} : {}), o.Circle.include(o.Path.CANVAS ? {
					_drawPath : function() {
						var t = this._point;
						this._ctx.beginPath(), this._ctx.arc(t.x, t.y, this._radius, 0, 2 * Math.PI, !1)
					},
					_containsPoint : function(t) {
						var e = this._point,
						    i = this.options.stroke ? this.options.weight / 2 : 0;
						return t.distanceTo(e) <= this._radius + i
					}
				} : {}), o.CircleMarker.include(o.Path.CANVAS ? {
					_updateStyle : function() {
						o.Path.prototype._updateStyle.call(this)
					}
				} : {}), o.GeoJSON = o.FeatureGroup.extend({
					initialize : function(t, e) {
						o.setOptions(this, e), this._layers = {}, t && this.addData(t)
					},
					addData : function(t) {
						var e,
						    i,
						    n,
						    s = o.Util.isArray(t) ? t : t.features;
						if (s) {
							for ( e = 0,
							i = s.length; i > e; e++)
								n = s[e], (n.geometries || n.geometry || n.features || n.coordinates) && this.addData(s[e]);
							return this
						}
						var a = this.options;
						if (!a.filter || a.filter(t)) {
							var r = o.GeoJSON.geometryToLayer(t, a.pointToLayer, a.coordsToLatLng, a);
							return r.feature = o.GeoJSON.asFeature(t), r.defaultOptions = r.options, this.resetStyle(r), a.onEachFeature && a.onEachFeature(t, r), this.addLayer(r)
						}
					},
					resetStyle : function(t) {
						var e = this.options.style;
						e && (o.Util.extend(t.options, t.defaultOptions), this._setLayerStyle(t, e))
					},
					setStyle : function(t) {
						this.eachLayer(function(e) {
							this._setLayerStyle(e, t)
						}, this)
					},
					_setLayerStyle : function(t, e) {
						"function" == typeof e && ( e = e(t.feature)), t.setStyle && t.setStyle(e)
					}
				}), o.extend(o.GeoJSON, {
					geometryToLayer : function(t, e, i, n) {
						var s,
						    a,
						    r,
						    h,
						    l = "Feature" === t.type ? t.geometry : t,
						    u = l.coordinates,
						    c = [];
						switch(i=i||this.coordsToLatLng,l.type) {
						case"Point":
							return s = i(u), e ? e(t, s) : new o.Marker(s);
						case"MultiPoint":
							for ( r = 0,
							h = u.length; h > r; r++)
								s = i(u[r]), c.push( e ? e(t, s) : new o.Marker(s));
							return new o.FeatureGroup(c);
						case"LineString":
							return a = this.coordsToLatLngs(u, 0, i), new o.Polyline(a, n);
						case"Polygon":
							if (2 === u.length && !u[1].length)
								throw new Error("Invalid GeoJSON object.");
							return a = this.coordsToLatLngs(u, 1, i), new o.Polygon(a, n);
						case"MultiLineString":
							return a = this.coordsToLatLngs(u, 1, i), new o.MultiPolyline(a, n);
						case"MultiPolygon":
							return a = this.coordsToLatLngs(u, 2, i), new o.MultiPolygon(a, n);
						case"GeometryCollection":
							for ( r = 0,
							h = l.geometries.length; h > r; r++)
								c.push(this.geometryToLayer({
									geometry : l.geometries[r],
									type : "Feature",
									properties : t.properties
								}, e, i, n));
							return new o.FeatureGroup(c);
						default:
							throw new Error("Invalid GeoJSON object.")
						}
					},
					coordsToLatLng : function(t) {
						return new o.LatLng(t[1], t[0], t[2])
					},
					coordsToLatLngs : function(t, e, i) {
						var n,
						    o,
						    s,
						    a = [];
						for ( o = 0,
						s = t.length; s > o; o++)
							n = e ? this.coordsToLatLngs(t[o], e - 1, i) : (i || this.coordsToLatLng)(t[o]), a.push(n);
						return a
					},
					latLngToCoords : function(t) {
						var e = [t.lng, t.lat];
						return t.alt !== i && e.push(t.alt), e
					},
					latLngsToCoords : function(t) {
						for (var e = [],
						    i = 0,
						    n = t.length; n > i; i++)
							e.push(o.GeoJSON.latLngToCoords(t[i]));
						return e
					},
					getFeature : function(t, e) {
						return t.feature ? o.extend({}, t.feature, {
							geometry : e
						}) : o.GeoJSON.asFeature(e)
					},
					asFeature : function(t) {
						return "Feature" === t.type ? t : {
							type : "Feature",
							properties : {},
							geometry : t
						}
					}
				});
				var a = {
					toGeoJSON : function() {
						return o.GeoJSON.getFeature(this, {
							type : "Point",
							coordinates : o.GeoJSON.latLngToCoords(this.getLatLng())
						})
					}
				};
				o.Marker.include(a), o.Circle.include(a), o.CircleMarker.include(a), o.Polyline.include({
					toGeoJSON : function() {
						return o.GeoJSON.getFeature(this, {
							type : "LineString",
							coordinates : o.GeoJSON.latLngsToCoords(this.getLatLngs())
						})
					}
				}), o.Polygon.include({
					toGeoJSON : function() {
						var t,
						    e,
						    i,
						    n = [o.GeoJSON.latLngsToCoords(this.getLatLngs())];
						if (n[0].push(n[0][0]), this._holes)
							for ( t = 0,
							e = this._holes.length; e > t; t++)
								i = o.GeoJSON.latLngsToCoords(this._holes[t]), i.push(i[0]), n.push(i);
						return o.GeoJSON.getFeature(this, {
							type : "Polygon",
							coordinates : n
						})
					}
				}), function() {
					function t(t) {
						return function() {
							var e = [];
							return this.eachLayer(function(t) {
								e.push(t.toGeoJSON().geometry.coordinates)
							}), o.GeoJSON.getFeature(this, {
								type : t,
								coordinates : e
							})
						}
					}


					o.MultiPolyline.include({
						toGeoJSON : t("MultiLineString")
					}), o.MultiPolygon.include({
						toGeoJSON : t("MultiPolygon")
					}), o.LayerGroup.include({
						toGeoJSON : function() {
							var e,
							    i = this.feature && this.feature.geometry,
							    n = [];
							if (i && "MultiPoint" === i.type)
								return t("MultiPoint").call(this);
							var s = i && "GeometryCollection" === i.type;
							return this.eachLayer(function(t) {
								t.toGeoJSON && ( e = t.toGeoJSON(), n.push( s ? e.geometry : o.GeoJSON.asFeature(e)))
							}), s ? o.GeoJSON.getFeature(this, {
								geometries : n,
								type : "GeometryCollection"
							}) : {
								type : "FeatureCollection",
								features : n
							}
						}
					})
				}(), o.geoJson = function(t, e) {
					return new o.GeoJSON(t, e)
				}, o.DomEvent = {
					addListener : function(t, e, i, n) {
						var s,
						    a,
						    r,
						    h = o.stamp(i),
						    l = "_leaflet_" + e + h;
						return t[l] ? this : ( s = function(e) {
							return i.call(n || t, e || o.DomEvent._getEvent())
						}, o.Browser.pointer && 0 === e.indexOf("touch") ? this.addPointerListener(t, e, s, h) : (o.Browser.touch && "dblclick" === e && this.addDoubleTapListener && this.addDoubleTapListener(t, s, h), "addEventListener" in t ? "mousewheel" === e ? (t.addEventListener("DOMMouseScroll", s, !1), t.addEventListener(e, s, !1)) : "mouseenter" === e || "mouseleave" === e ? ( a = s,
						r = "mouseenter" === e ? "mouseover" : "mouseout",
						s = function(e) {
							return o.DomEvent._checkMouse(t, e) ? a(e) :
							void 0
						}, t.addEventListener(r, s, !1)) : "click" === e && o.Browser.android ? ( a = s,
						s = function(t) {
							return o.DomEvent._filterClick(t, a)
						}, t.addEventListener(e, s, !1)) : t.addEventListener(e, s, !1) : "attachEvent" in t && t.attachEvent("on" + e, s), t[l] =
						s, this))
					},
					removeListener : function(t, e, i) {
						var n = o.stamp(i),
						    s = "_leaflet_" + e + n,
						    a = t[s];
						return a ? (o.Browser.pointer && 0 === e.indexOf("touch") ? this.removePointerListener(t, e, n) : o.Browser.touch && "dblclick" === e && this.removeDoubleTapListener ? this.removeDoubleTapListener(t, n) : "removeEventListener" in t ? "mousewheel" === e ? (t.removeEventListener("DOMMouseScroll", a, !1), t.removeEventListener(e, a, !1)) : "mouseenter" === e || "mouseleave" === e ? t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseout", a, !1) : t.removeEventListener(e, a, !1) : "detachEvent" in t && t.detachEvent("on" + e, a), t[s] = null, this) : this
					},
					stopPropagation : function(t) {
						return t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0, o.DomEvent._skipped(t), this
					},
					disableScrollPropagation : function(t) {
						var e = o.DomEvent.stopPropagation;
						return o.DomEvent.on(t, "mousewheel", e).on(t, "MozMousePixelScroll", e)
					},
					disableClickPropagation : function(t) {
						for (var e = o.DomEvent.stopPropagation,
						    i = o.Draggable.START.length - 1; i >= 0; i--)
							o.DomEvent.on(t, o.Draggable.START[i], e);
						return o.DomEvent.on(t, "click", o.DomEvent._fakeStop).on(t, "dblclick", e)
					},
					preventDefault : function(t) {
						return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this
					},
					stop : function(t) {
						return o.DomEvent.preventDefault(t).stopPropagation(t)
					},
					getMousePosition : function(t, i) {
						var n = e.body,
						    s = e.documentElement,
						    a = o.DomUtil.documentIsLtr() ? t.pageX ? t.pageX - n.scrollLeft - s.scrollLeft : t.clientX : o.Browser.gecko ? t.pageX - n.scrollLeft - s.scrollLeft : t.pageX ? t.pageX - n.scrollLeft + s.scrollLeft : t.clientX,
						    r = t.pageY ? t.pageY - n.scrollTop - s.scrollTop : t.clientY,
						    h = new o.Point(a, r);
						if (!i)
							return h;
						var l = i.getBoundingClientRect(),
						    u = l.left - i.clientLeft,
						    c = l.top - i.clientTop;
						return h._subtract(new o.Point(u, c))
					},
					getWheelDelta : function(t) {
						var e = 0;
						return t.wheelDelta && ( e = t.wheelDelta / 120), t.detail && ( e = -t.detail / 3), e
					},
					_skipEvents : {},
					_fakeStop : function(t) {
						o.DomEvent._skipEvents[t.type] = !0
					},
					_skipped : function(t) {
						var e = this._skipEvents[t.type];
						return this._skipEvents[t.type] = !1, e
					},
					_checkMouse : function(t, e) {
						var i = e.relatedTarget;
						if (!i)
							return !0;
						try {
							for (; i && i !== t; )
								i = i.parentNode
						} catch(n) {
							return !1
						}
						return i !== t
					},
					_getEvent : function() {
						var e = t.event;
						if (!e)
							for (var i = arguments.callee.caller; i && ( e = i.arguments[0], !e || t.Event !== e.constructor); )
								i = i.caller;
						return e
					},
					_filterClick : function(t, e) {
						var i = t.timeStamp || t.originalEvent.timeStamp,
						    n = o.DomEvent._lastClick && i - o.DomEvent._lastClick;
						return n && n > 100 && 1e3 > n || t.target._simulatedClick && !t._simulated ? (o.DomEvent.stop(t),
						void 0) : (o.DomEvent._lastClick = i, e(t))
					}
				}, o.DomEvent.on = o.DomEvent.addListener, o.DomEvent.off = o.DomEvent.removeListener, o.Draggable = o.Class.extend({
					includes : o.Mixin.Events,
					statics : {
						START : o.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
						END : {
							mousedown : "mouseup",
							touchstart : "touchend",
							pointerdown : "touchend",
							MSPointerDown : "touchend"
						},
						MOVE : {
							mousedown : "mousemove",
							touchstart : "touchmove",
							pointerdown : "touchmove",
							MSPointerDown : "touchmove"
						}
					},
					initialize : function(t, e) {
						this._element = t, this._dragStartTarget = e || t
					},
					enable : function() {
						if (!this._enabled) {
							for (var t = o.Draggable.START.length - 1; t >= 0; t--)
								o.DomEvent.on(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);
							this._enabled = !0
						}
					},
					disable : function() {
						if (this._enabled) {
							for (var t = o.Draggable.START.length - 1; t >= 0; t--)
								o.DomEvent.off(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);
							this._enabled = !1, this._moved = !1
						}
					},
					_onDown : function(t) {
						if (this._moved = !1, !(t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || (o.DomEvent.stopPropagation(t), o.Draggable._disabled || (o.DomUtil.disableImageDrag(), o.DomUtil.disableTextSelection(), this._moving)))) {
							var i = t.touches ? t.touches[0] : t;
							this._startPoint = new o.Point(i.clientX, i.clientY), this._startPos = this._newPos = o.DomUtil.getPosition(this._element), o.DomEvent.on(e, o.Draggable.MOVE[t.type], this._onMove, this).on(e, o.Draggable.END[t.type], this._onUp, this)
						}
					},
					_onMove : function(t) {
						if (t.touches && t.touches.length > 1)
							return this._moved = !0,
							void 0;
						var i = t.touches && 1 === t.touches.length ? t.touches[0] : t,
						    n = new o.Point(i.clientX, i.clientY),
						    s = n.subtract(this._startPoint);
						(s.x || s.y) && (o.DomEvent.preventDefault(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = o.DomUtil.getPosition(this._element).subtract(s), o.DomUtil.addClass(e.body, "leaflet-dragging"), o.DomUtil.addClass(t.target || t.srcElement, "leaflet-drag-target")), this._newPos = this._startPos.add(s), this._moving = !0, o.Util.cancelAnimFrame(this._animRequest), this._animRequest = o.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget))
					},
					_updatePosition : function() {
						this.fire("predrag"), o.DomUtil.setPosition(this._element, this._newPos), this.fire("drag")
					},
					_onUp : function(t) {
						o.DomUtil.removeClass(e.body, "leaflet-dragging"), o.DomUtil.removeClass(t.target || t.srcElement, "leaflet-drag-target");
						for (var i in o.Draggable.MOVE)
						o.DomEvent.off(e, o.Draggable.MOVE[i], this._onMove).off(e, o.Draggable.END[i], this._onUp);
						o.DomUtil.enableImageDrag(), o.DomUtil.enableTextSelection(), this._moved && this._moving && (o.Util.cancelAnimFrame(this._animRequest), this.fire("dragend", {
							distance : this._newPos.distanceTo(this._startPos)
						})), this._moving = !1
					}
				}), o.Handler = o.Class.extend({
					initialize : function(t) {
						this._map = t
					},
					enable : function() {
						this._enabled || (this._enabled = !0, this.addHooks())
					},
					disable : function() {
						this._enabled && (this._enabled = !1, this.removeHooks())
					},
					enabled : function() {
						return !!this._enabled
					}
				}), o.Map.mergeOptions({
					dragging : !0,
					inertia : !o.Browser.android23,
					inertiaDeceleration : 3400,
					inertiaMaxSpeed : 1 / 0,
					inertiaThreshold : o.Browser.touch ? 32 : 18,
					easeLinearity : .25,
					worldCopyJump : !1
				}), o.Map.Drag = o.Handler.extend({
					addHooks : function() {
						if (!this._draggable) {
							var t = this._map;
							this._draggable = new o.Draggable(t._mapPane, t._container), this._draggable.on({
								dragstart : this._onDragStart,
								drag : this._onDrag,
								dragend : this._onDragEnd
							}, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this), t.on("viewreset", this._onViewReset, this), t.whenReady(this._onViewReset, this))
						}
						this._draggable.enable()
					},
					removeHooks : function() {
						this._draggable.disable()
					},
					moved : function() {
						return this._draggable && this._draggable._moved
					},
					_onDragStart : function() {
						var t = this._map;
						t._panAnim && t._panAnim.stop(), t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = [])
					},
					_onDrag : function() {
						if (this._map.options.inertia) {
							var t = this._lastTime = +new Date,
							    e = this._lastPos = this._draggable._newPos;
							this._positions.push(e), this._times.push(t), t - this._times[0] > 200 && (this._positions.shift(), this._times.shift())
						}
						this._map.fire("move").fire("drag")
					},
					_onViewReset : function() {
						var t = this._map.getSize()._divideBy(2),
						    e = this._map.latLngToLayerPoint([0, 0]);
						this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.project([0, 180]).x
					},
					_onPreDrag : function() {
						var t = this._worldWidth,
						    e = Math.round(t / 2),
						    i = this._initialWorldOffset,
						    n = this._draggable._newPos.x,
						    o = (n - e + i) % t + e - i,
						    s = (n + e + i) % t - e - i,
						    a = Math.abs(o + i) < Math.abs(s + i) ? o : s;
						this._draggable._newPos.x = a
					},
					_onDragEnd : function(t) {
						var e = this._map,
						    i = e.options,
						    n = +new Date - this._lastTime,
						    s = !i.inertia || n > i.inertiaThreshold || !this._positions[0];
						if (e.fire("dragend", t), s)
							e.fire("moveend");
						else {
							var a = this._lastPos.subtract(this._positions[0]),
							    r = (this._lastTime + n - this._times[0]) / 1e3,
							    h = i.easeLinearity,
							    l = a.multiplyBy(h / r),
							    u = l.distanceTo([0, 0]),
							    c = Math.min(i.inertiaMaxSpeed, u),
							    d = l.multiplyBy(c / u),
							    p = c / (i.inertiaDeceleration * h),
							    _ = d.multiplyBy(-p / 2).round();
							_.x && _.y ? ( _ = e._limitOffset(_, e.options.maxBounds), o.Util.requestAnimFrame(function() {
								e.panBy(_, {
									duration : p,
									easeLinearity : h,
									noMoveStart : !0
								})
							})) : e.fire("moveend")
						}
					}
				}), o.Map.addInitHook("addHandler", "dragging", o.Map.Drag), o.Map.mergeOptions({
					doubleClickZoom : !0
				}), o.Map.DoubleClickZoom = o.Handler.extend({
					addHooks : function() {
						this._map.on("dblclick", this._onDoubleClick, this)
					},
					removeHooks : function() {
						this._map.off("dblclick", this._onDoubleClick, this)
					},
					_onDoubleClick : function(t) {
						var e = this._map,
						    i = e.getZoom() + (t.originalEvent.shiftKey ? -1 : 1);
						"center" === e.options.doubleClickZoom ? e.setZoom(i) : e.setZoomAround(t.containerPoint, i)
					}
				}), o.Map.addInitHook("addHandler", "doubleClickZoom", o.Map.DoubleClickZoom), o.Map.mergeOptions({
					scrollWheelZoom : !0
				}), o.Map.ScrollWheelZoom = o.Handler.extend({
					addHooks : function() {
						o.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this), o.DomEvent.on(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault), this._delta = 0
					},
					removeHooks : function() {
						o.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll), o.DomEvent.off(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault)
					},
					_onWheelScroll : function(t) {
						var e = o.DomEvent.getWheelDelta(t);
						this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date);
						var i = Math.max(40 - (+new Date - this._startTime), 0);
						clearTimeout(this._timer), this._timer = setTimeout(o.bind(this._performZoom, this), i), o.DomEvent.preventDefault(t), o.DomEvent.stopPropagation(t)
					},
					_performZoom : function() {
						var t = this._map,
						    e = this._delta,
						    i = t.getZoom();
						e = e > 0 ? Math.ceil(e) : Math.floor(e),
						e = Math.max(Math.min(e, 4), -4),
						e = t._limitZoom(i + e) - i, this._delta = 0, this._startTime = null, e && ("center" === t.options.scrollWheelZoom ? t.setZoom(i + e) : t.setZoomAround(this._lastMousePos, i + e))
					}
				}), o.Map.addInitHook("addHandler", "scrollWheelZoom", o.Map.ScrollWheelZoom), o.extend(o.DomEvent, {
					_touchstart : o.Browser.msPointer ? "MSPointerDown" : o.Browser.pointer ? "pointerdown" : "touchstart",
					_touchend : o.Browser.msPointer ? "MSPointerUp" : o.Browser.pointer ? "pointerup" : "touchend",
					addDoubleTapListener : function(t, i, n) {
						function s(t) {
							var e;
							if (o.Browser.pointer ? (_.push(t.pointerId),
							e = _.length) : e = t.touches.length, !(e > 1)) {
								var i = Date.now(),
								    n = i - (r || i);
								h = t.touches ? t.touches[0] : t,
								l = n > 0 && u >= n,
								r =
								i
							}
						}

						function a(t) {
							if (o.Browser.pointer) {
								var e = _.indexOf(t.pointerId);
								if (-1 === e)
									return;
								_.splice(e, 1)
							}
							if (l) {
								if (o.Browser.pointer) {
									var n,
									    s = {};
									for (var a in h) n = h[a], s[a] = "function" == typeof n ? n.bind(h) : n;
									h = s
								}
								h.type = "dblclick", i(h),
								r = null
							}
						}

						var r,
						    h,
						    l = !1,
						    u = 250,
						    c = "_leaflet_",
						    d = this._touchstart,
						    p = this._touchend,
						    _ = [];
						t[c + d + n] = s, t[c + p + n] =
						a;
						var m = o.Browser.pointer ? e.documentElement : t;
						return t.addEventListener(d, s, !1), m.addEventListener(p, a, !1), o.Browser.pointer && m.addEventListener(o.DomEvent.POINTER_CANCEL, a, !1), this
					},
					removeDoubleTapListener : function(t, i) {
						var n = "_leaflet_";
						return t.removeEventListener(this._touchstart, t[n + this._touchstart + i], !1), (o.Browser.pointer ? e.documentElement : t).removeEventListener(this._touchend, t[n + this._touchend + i], !1), o.Browser.pointer && e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL, t[n + this._touchend + i], !1), this
					}
				}), o.extend(o.DomEvent, {
					POINTER_DOWN : o.Browser.msPointer ? "MSPointerDown" : "pointerdown",
					POINTER_MOVE : o.Browser.msPointer ? "MSPointerMove" : "pointermove",
					POINTER_UP : o.Browser.msPointer ? "MSPointerUp" : "pointerup",
					POINTER_CANCEL : o.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
					_pointers : [],
					_pointerDocumentListener : !1,
					addPointerListener : function(t, e, i, n) {
						switch(e) {
						case"touchstart":
							return this.addPointerListenerStart(t, e, i, n);
						case"touchend":
							return this.addPointerListenerEnd(t, e, i, n);
						case"touchmove":
							return this.addPointerListenerMove(t, e, i, n);
						default:
							throw "Unknown touch event type"
						}
					},
					addPointerListenerStart : function(t, i, n, s) {
						var a = "_leaflet_",
						    r = this._pointers,
						    h = function(t) {
							o.DomEvent.preventDefault(t);
							for (var e = !1,
							    i = 0; i < r.length; i++)
								if (r[i].pointerId === t.pointerId) {
									e = !0;
									break
								}
							e || r.push(t), t.touches = r.slice(), t.changedTouches = [t], n(t)
						};
						if (t[a + "touchstart" + s] = h, t.addEventListener(this.POINTER_DOWN, h, !1), !this._pointerDocumentListener) {
							var l = function(t) {
								for (var e = 0; e < r.length; e++)
									if (r[e].pointerId === t.pointerId) {
										r.splice(e, 1);
										break
									}
							};
							e.documentElement.addEventListener(this.POINTER_UP, l, !1), e.documentElement.addEventListener(this.POINTER_CANCEL, l, !1), this._pointerDocumentListener = !0
						}
						return this
					},
					addPointerListenerMove : function(t, e, i, n) {
						function o(t) {
							if (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) {
								for (var e = 0; e < a.length; e++)
									if (a[e].pointerId === t.pointerId) {
										a[e] = t;
										break
									}
								t.touches = a.slice(), t.changedTouches = [t], i(t)
							}
						}

						var s = "_leaflet_",
						    a = this._pointers;
						return t[s + "touchmove" + n] = o, t.addEventListener(this.POINTER_MOVE, o, !1), this
					},
					addPointerListenerEnd : function(t, e, i, n) {
						var o = "_leaflet_",
						    s = this._pointers,
						    a = function(t) {
							for (var e = 0; e < s.length; e++)
								if (s[e].pointerId === t.pointerId) {
									s.splice(e, 1);
									break
								}
							t.touches = s.slice(), t.changedTouches = [t], i(t)
						};
						return t[o + "touchend" + n] = a, t.addEventListener(this.POINTER_UP, a, !1), t.addEventListener(this.POINTER_CANCEL, a, !1), this
					},
					removePointerListener : function(t, e, i) {
						var n = "_leaflet_",
						    o = t[n + e + i];
						switch(e) {
						case"touchstart":
							t.removeEventListener(this.POINTER_DOWN, o, !1);
							break;
						case"touchmove":
							t.removeEventListener(this.POINTER_MOVE, o, !1);
							break;
						case"touchend":
							t.removeEventListener(this.POINTER_UP, o, !1), t.removeEventListener(this.POINTER_CANCEL, o, !1)
						}
						return this
					}
				}), o.Map.mergeOptions({
					touchZoom : o.Browser.touch && !o.Browser.android23,
					bounceAtZoomLimits : !0
				}), o.Map.TouchZoom = o.Handler.extend({
					addHooks : function() {
						o.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
					},
					removeHooks : function() {
						o.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
					},
					_onTouchStart : function(t) {
						var i = this._map;
						if (t.touches && 2 === t.touches.length && !i._animatingZoom && !this._zooming) {
							var n = i.mouseEventToLayerPoint(t.touches[0]),
							    s = i.mouseEventToLayerPoint(t.touches[1]),
							    a = i._getCenterLayerPoint();
							this._startCenter = n.add(s)._divideBy(2), this._startDist = n.distanceTo(s), this._moved = !1, this._zooming = !0, this._centerOffset = a.subtract(this._startCenter), i._panAnim && i._panAnim.stop(), o.DomEvent.on(e, "touchmove", this._onTouchMove, this).on(e, "touchend", this._onTouchEnd, this), o.DomEvent.preventDefault(t)
						}
					},
					_onTouchMove : function(t) {
						var e = this._map;
						if (t.touches && 2 === t.touches.length && this._zooming) {
							var i = e.mouseEventToLayerPoint(t.touches[0]),
							    n = e.mouseEventToLayerPoint(t.touches[1]);
							this._scale = i.distanceTo(n) / this._startDist, this._delta = i._add(n)._divideBy(2)._subtract(this._startCenter), 1 !== this._scale && (e.options.bounceAtZoomLimits || !(e.getZoom() === e.getMinZoom() && this._scale < 1 || e.getZoom() === e.getMaxZoom() && this._scale > 1)) && (this._moved || (o.DomUtil.addClass(e._mapPane, "leaflet-touching"), e.fire("movestart").fire("zoomstart"), this._moved = !0), o.Util.cancelAnimFrame(this._animRequest), this._animRequest = o.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container), o.DomEvent.preventDefault(t))
						}
					},
					_updateOnMove : function() {
						var t = this._map,
						    e = this._getScaleOrigin(),
						    i = t.layerPointToLatLng(e),
						    n = t.getScaleZoom(this._scale);
						t._animateZoom(i, n, this._startCenter, this._scale, this._delta)
					},
					_onTouchEnd : function() {
						if (!this._moved || !this._zooming)
							return this._zooming = !1,
							void 0;
						var t = this._map;
						this._zooming = !1, o.DomUtil.removeClass(t._mapPane, "leaflet-touching"), o.Util.cancelAnimFrame(this._animRequest), o.DomEvent.off(e, "touchmove", this._onTouchMove).off(e, "touchend", this._onTouchEnd);
						var i = this._getScaleOrigin(),
						    n = t.layerPointToLatLng(i),
						    s = t.getZoom(),
						    a = t.getScaleZoom(this._scale) - s,
						    r = a > 0 ? Math.ceil(a) : Math.floor(a),
						    h = t._limitZoom(s + r),
						    l = t.getZoomScale(h) / this._scale;
						t._animateZoom(n, h, i, l)
					},
					_getScaleOrigin : function() {
						var t = this._centerOffset.subtract(this._delta).divideBy(this._scale);
						return this._startCenter.add(t)
					}
				}), o.Map.addInitHook("addHandler", "touchZoom", o.Map.TouchZoom), o.Map.mergeOptions({
					tap : !0,
					tapTolerance : 15
				}), o.Map.Tap = o.Handler.extend({
					addHooks : function() {
						o.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
					},
					removeHooks : function() {
						o.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
					},
					_onDown : function(t) {
						if (t.touches) {
							if (o.DomEvent.preventDefault(t), this._fireClick = !0, t.touches.length > 1)
								return this._fireClick = !1, clearTimeout(this._holdTimeout),
								void 0;
							var i = t.touches[0],
							    n = i.target;
							this._startPos = this._newPos = new o.Point(i.clientX, i.clientY), n.tagName && "a" === n.tagName.toLowerCase() && o.DomUtil.addClass(n, "leaflet-active"), this._holdTimeout = setTimeout(o.bind(function() {
								this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", i))
							}, this), 1e3), o.DomEvent.on(e, "touchmove", this._onMove, this).on(e, "touchend", this._onUp, this)
						}
					},
					_onUp : function(t) {
						if (clearTimeout(this._holdTimeout), o.DomEvent.off(e, "touchmove", this._onMove, this).off(e, "touchend", this._onUp, this), this._fireClick && t && t.changedTouches) {
							var i = t.changedTouches[0],
							    n = i.target;
							n && n.tagName && "a" === n.tagName.toLowerCase() && o.DomUtil.removeClass(n, "leaflet-active"), this._isTapValid() && this._simulateEvent("click", i)
						}
					},
					_isTapValid : function() {
						return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
					},
					_onMove : function(t) {
						var e = t.touches[0];
						this._newPos = new o.Point(e.clientX, e.clientY)
					},
					_simulateEvent : function(i, n) {
						var o = e.createEvent("MouseEvents");
						o._simulated = !0, n.target._simulatedClick = !0, o.initMouseEvent(i, !0, !0, t, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(o)
					}
				}), o.Browser.touch && !o.Browser.pointer && o.Map.addInitHook("addHandler", "tap", o.Map.Tap), o.Map.mergeOptions({
					boxZoom : !0
				}), o.Map.BoxZoom = o.Handler.extend({
					initialize : function(t) {
						this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._moved = !1
					},
					addHooks : function() {
						o.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
					},
					removeHooks : function() {
						o.DomEvent.off(this._container, "mousedown", this._onMouseDown), this._moved = !1
					},
					moved : function() {
						return this._moved
					},
					_onMouseDown : function(t) {
						return this._moved = !1, !t.shiftKey || 1 !== t.which && 1 !== t.button ? !1 : (o.DomUtil.disableTextSelection(), o.DomUtil.disableImageDrag(), this._startLayerPoint = this._map.mouseEventToLayerPoint(t), o.DomEvent.on(e, "mousemove", this._onMouseMove, this).on(e, "mouseup", this._onMouseUp, this).on(e, "keydown", this._onKeyDown, this),
						void 0)
					},
					_onMouseMove : function(t) {
						this._moved || (this._box = o.DomUtil.create("div", "leaflet-zoom-box", this._pane), o.DomUtil.setPosition(this._box, this._startLayerPoint), this._container.style.cursor = "crosshair", this._map.fire("boxzoomstart"));
						var e = this._startLayerPoint,
						    i = this._box,
						    n = this._map.mouseEventToLayerPoint(t),
						    s = n.subtract(e),
						    a = new o.Point(Math.min(n.x, e.x), Math.min(n.y, e.y));
						o.DomUtil.setPosition(i, a), this._moved = !0, i.style.width = Math.max(0, Math.abs(s.x) - 4) + "px", i.style.height = Math.max(0, Math.abs(s.y) - 4) + "px"
					},
					_finish : function() {
						this._moved && (this._pane.removeChild(this._box), this._container.style.cursor = ""), o.DomUtil.enableTextSelection(), o.DomUtil.enableImageDrag(), o.DomEvent.off(e, "mousemove", this._onMouseMove).off(e, "mouseup", this._onMouseUp).off(e, "keydown", this._onKeyDown)
					},
					_onMouseUp : function(t) {
						this._finish();
						var e = this._map,
						    i = e.mouseEventToLayerPoint(t);
						if (!this._startLayerPoint.equals(i)) {
							var n = new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint), e.layerPointToLatLng(i));
							e.fitBounds(n), e.fire("boxzoomend", {
								boxZoomBounds : n
							})
						}
					},
					_onKeyDown : function(t) {
						27 === t.keyCode && this._finish()
					}
				}), o.Map.addInitHook("addHandler", "boxZoom", o.Map.BoxZoom), o.Map.mergeOptions({
					keyboard : !0,
					keyboardPanOffset : 80,
					keyboardZoomOffset : 1
				}), o.Map.Keyboard = o.Handler.extend({
					keyCodes : {
						left : [37],
						right : [39],
						down : [40],
						up : [38],
						zoomIn : [187, 107, 61, 171],
						zoomOut : [189, 109, 173]
					},
					initialize : function(t) {
						this._map = t, this._setPanOffset(t.options.keyboardPanOffset), this._setZoomOffset(t.options.keyboardZoomOffset)
					},
					addHooks : function() {
						var t = this._map._container;
						-1 === t.tabIndex && (t.tabIndex = "0"), o.DomEvent.on(t, "focus", this._onFocus, this).on(t, "blur", this._onBlur, this).on(t, "mousedown", this._onMouseDown, this), this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this)
					},
					removeHooks : function() {
						this._removeHooks();
						var t = this._map._container;
						o.DomEvent.off(t, "focus", this._onFocus, this).off(t, "blur", this._onBlur, this).off(t, "mousedown", this._onMouseDown, this), this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this)
					},
					_onMouseDown : function() {
						if (!this._focused) {
							var i = e.body,
							    n = e.documentElement,
							    o = i.scrollTop || n.scrollTop,
							    s = i.scrollLeft || n.scrollLeft;
							this._map._container.focus(), t.scrollTo(s, o)
						}
					},
					_onFocus : function() {
						this._focused = !0, this._map.fire("focus")
					},
					_onBlur : function() {
						this._focused = !1, this._map.fire("blur")
					},
					_setPanOffset : function(t) {
						var e,
						    i,
						    n = this._panKeys = {},
						    o = this.keyCodes;
						for ( e = 0,
						i = o.left.length; i > e; e++)
							n[o.left[e]] = [-1 * t, 0];
						for ( e = 0,
						i = o.right.length; i > e; e++)
							n[o.right[e]] = [t, 0];
						for ( e = 0,
						i = o.down.length; i > e; e++)
							n[o.down[e]] = [0, t];
						for ( e = 0,
						i = o.up.length; i > e; e++)
							n[o.up[e]] = [0, -1 * t]
					},
					_setZoomOffset : function(t) {
						var e,
						    i,
						    n = this._zoomKeys = {},
						    o = this.keyCodes;
						for ( e = 0,
						i = o.zoomIn.length; i > e; e++)
							n[o.zoomIn[e]] = t;
						for ( e = 0,
						i = o.zoomOut.length; i > e; e++)
							n[o.zoomOut[e]] = -t
					},
					_addHooks : function() {
						o.DomEvent.on(e, "keydown", this._onKeyDown, this)
					},
					_removeHooks : function() {
						o.DomEvent.off(e, "keydown", this._onKeyDown, this)
					},
					_onKeyDown : function(t) {
						var e = t.keyCode,
						    i = this._map;
						if ( e in this._panKeys) {
							if (i._panAnim && i._panAnim._inProgress)
								return;
							i.panBy(this._panKeys[e]), i.options.maxBounds && i.panInsideBounds(i.options.maxBounds)
						} else {
							if (!( e in this._zoomKeys))
								return;
							i.setZoom(i.getZoom() + this._zoomKeys[e])
						}
						o.DomEvent.stop(t)
					}
				}), o.Map.addInitHook("addHandler", "keyboard", o.Map.Keyboard), o.Handler.MarkerDrag = o.Handler.extend({
					initialize : function(t) {
						this._marker = t
					},
					addHooks : function() {
						var t = this._marker._icon;
						this._draggable || (this._draggable = new o.Draggable(t, t)), this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this), this._draggable.enable(), o.DomUtil.addClass(this._marker._icon, "leaflet-marker-draggable")
					},
					removeHooks : function() {
						this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this), this._draggable.disable(), o.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable")
					},
					moved : function() {
						return this._draggable && this._draggable._moved
					},
					_onDragStart : function() {
						this._marker.closePopup().fire("movestart").fire("dragstart")
					},
					_onDrag : function() {
						var t = this._marker,
						    e = t._shadow,
						    i = o.DomUtil.getPosition(t._icon),
						    n = t._map.layerPointToLatLng(i);
						e && o.DomUtil.setPosition(e, i), t._latlng =
						n, t.fire("move", {
							latlng : n
						}).fire("drag")
					},
					_onDragEnd : function(t) {
						this._marker.fire("moveend").fire("dragend", t)
					}
				}), o.Control = o.Class.extend({
					options : {
						position : "topright"
					},
					initialize : function(t) {
						o.setOptions(this, t)
					},
					getPosition : function() {
						return this.options.position
					},
					setPosition : function(t) {
						var e = this._map;
						return e && e.removeControl(this), this.options.position =
						t, e && e.addControl(this), this
					},
					getContainer : function() {
						return this._container
					},
					addTo : function(t) {
						this._map = t;
						var e = this._container = this.onAdd(t),
						    i = this.getPosition(),
						    n = t._controlCorners[i];
						return o.DomUtil.addClass(e, "leaflet-control"), -1 !== i.indexOf("bottom") ? n.insertBefore(e, n.firstChild) : n.appendChild(e), this
					},
					removeFrom : function(t) {
						var e = this.getPosition(),
						    i = t._controlCorners[e];
						return i.removeChild(this._container), this._map = null, this.onRemove && this.onRemove(t), this
					},
					_refocusOnMap : function() {
						this._map && this._map.getContainer().focus()
					}
				}), o.control = function(t) {
					return new o.Control(t)
				}, o.Map.include({
					addControl : function(t) {
						return t.addTo(this), this
					},
					removeControl : function(t) {
						return t.removeFrom(this), this
					},
					_initControlPos : function() {
						function t(t, s) {
							var a = i + t + " " + i + s;
							e[t + s] = o.DomUtil.create("div", a, n)
						}

						var e = this._controlCorners = {},
						    i = "leaflet-",
						    n = this._controlContainer = o.DomUtil.create("div", i + "control-container", this._container);
						t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right")
					},
					_clearControlPos : function() {
						this._container.removeChild(this._controlContainer)
					}
				}), o.Control.Zoom = o.Control.extend({
					options : {
						position : "topleft",
						zoomInText : "+",
						zoomInTitle : "Zoom in",
						zoomOutText : "-",
						zoomOutTitle : "Zoom out"
					},
					onAdd : function(t) {
						var e = "leaflet-control-zoom",
						    i = o.DomUtil.create("div", e + " leaflet-bar");
						return this._map = t, this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, e + "-in", i, this._zoomIn, this), this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, e + "-out", i, this._zoomOut, this), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i
					},
					onRemove : function(t) {
						t.off("zoomend zoomlevelschange", this._updateDisabled, this)
					},
					_zoomIn : function(t) {
						this._map.zoomIn(t.shiftKey ? 3 : 1)
					},
					_zoomOut : function(t) {
						this._map.zoomOut(t.shiftKey ? 3 : 1)
					},
					_createButton : function(t, e, i, n, s, a) {
						var r = o.DomUtil.create("a", i, n);
						r.innerHTML = t, r.href = "#", r.title =
						e;
						var h = o.DomEvent.stopPropagation;
						return o.DomEvent.on(r, "click", h).on(r, "mousedown", h).on(r, "dblclick", h).on(r, "click", o.DomEvent.preventDefault).on(r, "click", s, a).on(r, "click", this._refocusOnMap, a), r
					},
					_updateDisabled : function() {
						var t = this._map,
						    e = "leaflet-disabled";
						o.DomUtil.removeClass(this._zoomInButton, e), o.DomUtil.removeClass(this._zoomOutButton, e), t._zoom === t.getMinZoom() && o.DomUtil.addClass(this._zoomOutButton, e), t._zoom === t.getMaxZoom() && o.DomUtil.addClass(this._zoomInButton, e)
					}
				}), o.Map.mergeOptions({
					zoomControl : !0
				}), o.Map.addInitHook(function() {
					this.options.zoomControl && (this.zoomControl = new o.Control.Zoom, this.addControl(this.zoomControl))
				}), o.control.zoom = function(t) {
					return new o.Control.Zoom(t)
				}, o.Control.Attribution = o.Control.extend({
					options : {
						position : "bottomright",
						prefix : '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
					},
					initialize : function(t) {
						o.setOptions(this, t), this._attributions = {}
					},
					onAdd : function(t) {
						this._container = o.DomUtil.create("div", "leaflet-control-attribution"), o.DomEvent.disableClickPropagation(this._container);
						for (var e in t._layers)
						t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());
						return t.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this), this._update(), this._container
					},
					onRemove : function(t) {
						t.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove)
					},
					setPrefix : function(t) {
						return this.options.prefix = t, this._update(), this
					},
					addAttribution : function(t) {
						return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) :
						void 0
					},
					removeAttribution : function(t) {
						return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) :
						void 0
					},
					_update : function() {
						if (this._map) {
							var t = [];
							for (var e in this._attributions)
							this._attributions[e] && t.push(e);
							var i = [];
							this.options.prefix && i.push(this.options.prefix), t.length && i.push(t.join(", ")), this._container.innerHTML = i.join(" | ")
						}
					},
					_onLayerAdd : function(t) {
						t.layer.getAttribution && this.addAttribution(t.layer.getAttribution())
					},
					_onLayerRemove : function(t) {
						t.layer.getAttribution && this.removeAttribution(t.layer.getAttribution())
					}
				}), o.Map.mergeOptions({
					attributionControl : !0
				}), o.Map.addInitHook(function() {
					this.options.attributionControl && (this.attributionControl = (new o.Control.Attribution).addTo(this))
				}), o.control.attribution = function(t) {
					return new o.Control.Attribution(t)
				}, o.Control.Scale = o.Control.extend({
					options : {
						position : "bottomleft",
						maxWidth : 100,
						metric : !0,
						imperial : !0,
						updateWhenIdle : !1
					},
					onAdd : function(t) {
						this._map = t;
						var e = "leaflet-control-scale",
						    i = o.DomUtil.create("div", e),
						    n = this.options;
						return this._addScales(n, e, i), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), i
					},
					onRemove : function(t) {
						t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
					},
					_addScales : function(t, e, i) {
						t.metric && (this._mScale = o.DomUtil.create("div", e + "-line", i)), t.imperial && (this._iScale = o.DomUtil.create("div", e + "-line", i))
					},
					_update : function() {
						var t = this._map.getBounds(),
						    e = t.getCenter().lat,
						    i = 6378137 * Math.PI * Math.cos(e * Math.PI / 180),
						    n = i * (t.getNorthEast().lng - t.getSouthWest().lng) / 180,
						    o = this._map.getSize(),
						    s = this.options,
						    a = 0;
						o.x > 0 && ( a = n * (s.maxWidth / o.x)), this._updateScales(s, a)
					},
					_updateScales : function(t, e) {
						t.metric && e && this._updateMetric(e), t.imperial && e && this._updateImperial(e)
					},
					_updateMetric : function(t) {
						var e = this._getRoundNum(t);
						this._mScale.style.width = this._getScaleWidth(e / t) + "px", this._mScale.innerHTML = 1e3 > e ? e + " m" : e / 1e3 + " km"
					},
					_updateImperial : function(t) {
						var e,
						    i,
						    n,
						    o = 3.2808399 * t,
						    s = this._iScale;
						o > 5280 ? ( e = o / 5280,
						i = this._getRoundNum(e), s.style.width = this._getScaleWidth(i / e) + "px", s.innerHTML = i + " mi") : ( n = this._getRoundNum(o), s.style.width = this._getScaleWidth(n / o) + "px", s.innerHTML = n + " ft")
					},
					_getScaleWidth : function(t) {
						return Math.round(this.options.maxWidth * t) - 10
					},
					_getRoundNum : function(t) {
						var e = Math.pow(10, (Math.floor(t) + "").length - 1),
						    i = t / e;
						return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1, e * i
					}
				}), o.control.scale = function(t) {
					return new o.Control.Scale(t)
				}, o.Control.Layers = o.Control.extend({
					options : {
						collapsed : !0,
						position : "topright",
						autoZIndex : !0
					},
					initialize : function(t, e, i) {
						o.setOptions(this, i), this._layers = {}, this._lastZIndex = 0, this._handlingClick = !1;
						for (var n in t)
						this._addLayer(t[n], n);
						for (n in e)
						this._addLayer(e[n], n, !0)
					},
					onAdd : function(t) {
						return this._initLayout(), this._update(), t.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this), this._container
					},
					onRemove : function(t) {
						t.off("layeradd", this._onLayerChange).off("layerremove", this._onLayerChange)
					},
					addBaseLayer : function(t, e) {
						return this._addLayer(t, e), this._update(), this
					},
					addOverlay : function(t, e) {
						return this._addLayer(t, e, !0), this._update(), this
					},
					removeLayer : function(t) {
						var e = o.stamp(t);
						return
						delete this._layers[e], this._update(), this
					},
					_initLayout : function() {
						var t = "leaflet-control-layers",
						    e = this._container = o.DomUtil.create("div", t);
						e.setAttribute("aria-haspopup", !0), o.Browser.touch ? o.DomEvent.on(e, "click", o.DomEvent.stopPropagation) : o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);
						var i = this._form = o.DomUtil.create("form", t + "-list");
						if (this.options.collapsed) {
							o.Browser.android || o.DomEvent.on(e, "mouseover", this._expand, this).on(e, "mouseout", this._collapse, this);
							var n = this._layersLink = o.DomUtil.create("a", t + "-toggle", e);
							n.href = "#", n.title = "Layers", o.Browser.touch ? o.DomEvent.on(n, "click", o.DomEvent.stop).on(n, "click", this._expand, this) : o.DomEvent.on(n, "focus", this._expand, this), o.DomEvent.on(i, "click", function() {
								setTimeout(o.bind(this._onInputClick, this), 0)
							}, this), this._map.on("click", this._collapse, this)
						} else
							this._expand();
						this._baseLayersList = o.DomUtil.create("div", t + "-base", i), this._separator = o.DomUtil.create("div", t + "-separator", i), this._overlaysList = o.DomUtil.create("div", t + "-overlays", i), e.appendChild(i)
					},
					_addLayer : function(t, e, i) {
						var n = o.stamp(t);
						this._layers[n] = {
							layer : t,
							name : e,
							overlay : i
						}, this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex))
					},
					_update : function() {
						if (this._container) {
							this._baseLayersList.innerHTML = "", this._overlaysList.innerHTML = "";
							var t,
							    e,
							    i = !1,
							    n = !1;
							for (t in this._layers) e = this._layers[t], this._addItem(e),
							n = n || e.overlay,
							i = i || !e.overlay;
							this._separator.style.display = n && i ? "" : "none"
						}
					},
					_onLayerChange : function(t) {
						var e = this._layers[o.stamp(t.layer)];
						if (e) {
							this._handlingClick || this._update();
							var i = e.overlay ? "layeradd" === t.type ? "overlayadd" : "overlayremove" : "layeradd" === t.type ? "baselayerchange" : null;
							i && this._map.fire(i, e)
						}
					},
					_createRadioElement : function(t, i) {
						var n = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"';
						i && (n += ' checked="checked"'), n += "/>";
						var o = e.createElement("div");
						return o.innerHTML = n, o.firstChild
					},
					_addItem : function(t) {
						var i,
						    n = e.createElement("label"),
						    s = this._map.hasLayer(t.layer);
						t.overlay ? ( i = e.createElement("input"), i.type = "checkbox", i.className = "leaflet-control-layers-selector", i.defaultChecked =
						s) : i = this._createRadioElement("leaflet-base-layers", s), i.layerId = o.stamp(t.layer), o.DomEvent.on(i, "click", this._onInputClick, this);
						var a = e.createElement("span");
						a.innerHTML = " " + t.name, n.appendChild(i), n.appendChild(a);
						var r = t.overlay ? this._overlaysList : this._baseLayersList;
						return r.appendChild(n), n
					},
					_onInputClick : function() {
						var t,
						    e,
						    i,
						    n = this._form.getElementsByTagName("input"),
						    o = n.length;
						for (this._handlingClick = !0,
						t = 0; o > t; t++)
							e = n[t],
							i = this._layers[e.layerId], e.checked && !this._map.hasLayer(i.layer) ? this._map.addLayer(i.layer) : !e.checked && this._map.hasLayer(i.layer) && this._map.removeLayer(i.layer);
						this._handlingClick = !1, this._refocusOnMap()
					},
					_expand : function() {
						o.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
					},
					_collapse : function() {
						this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "")
					}
				}), o.control.layers = function(t, e, i) {
					return new o.Control.Layers(t, e, i)
				}, o.PosAnimation = o.Class.extend({
					includes : o.Mixin.Events,
					run : function(t, e, i, n) {
						this.stop(), this._el =
						t, this._inProgress = !0, this._newPos =
						e, this.fire("start"), t.style[o.DomUtil.TRANSITION] = "all " + (i || .25) + "s cubic-bezier(0,0," + (n || .5) + ",1)", o.DomEvent.on(t, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this), o.DomUtil.setPosition(t, e), o.Util.falseFn(t.offsetWidth), this._stepTimer = setInterval(o.bind(this._onStep, this), 50)
					},
					stop : function() {
						this._inProgress && (o.DomUtil.setPosition(this._el, this._getPos()), this._onTransitionEnd(), o.Util.falseFn(this._el.offsetWidth))
					},
					_onStep : function() {
						var t = this._getPos();
						return t ? (this._el._leaflet_pos = t, this.fire("step"),
						void 0) : (this._onTransitionEnd(),
						void 0)
					},
					_transformRe : /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
					_getPos : function() {
						var e,
						    i,
						    n,
						    s = this._el,
						    a = t.getComputedStyle(s);
						if (o.Browser.any3d) {
							if ( n = a[o.DomUtil.TRANSFORM].match(this._transformRe), !n)
								return;
							e = parseFloat(n[1]),
							i = parseFloat(n[2])
						} else
							e = parseFloat(a.left),
							i = parseFloat(a.top);
						return new o.Point(e, i, !0)
					},
					_onTransitionEnd : function() {
						o.DomEvent.off(this._el, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this), this._inProgress && (this._inProgress = !1, this._el.style[o.DomUtil.TRANSITION] = "", this._el._leaflet_pos = this._newPos, clearInterval(this._stepTimer), this.fire("step").fire("end"))
					}
				}), o.Map.include({
					setView : function(t, e, n) {
						if ( e = e === i ? this._zoom : this._limitZoom(e),
						t = this._limitCenter(o.latLng(t), e, this.options.maxBounds),
						n = n || {}, this._panAnim && this._panAnim.stop(), this._loaded && !n.reset && n !== !0) {
							n.animate !== i && (n.zoom = o.extend({
								animate : n.animate
							}, n.zoom), n.pan = o.extend({
								animate : n.animate
							}, n.pan));
							var s = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, n.zoom) : this._tryAnimatedPan(t, n.pan);
							if (s)
								return clearTimeout(this._sizeTimer), this
						}
						return this._resetView(t, e), this
					},
					panBy : function(t, e) {
						if ( t = o.point(t).round(),
							e = e || {}, !t.x && !t.y)
							return this;
						if (this._panAnim || (this._panAnim = new o.PosAnimation, this._panAnim.on({
							step : this._onPanTransitionStep,
							end : this._onPanTransitionEnd
						}, this)), e.noMoveStart || this.fire("movestart"), e.animate !== !1) {
							o.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
							var i = this._getMapPanePos().subtract(t);
							this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity)
						} else
							this._rawPanBy(t), this.fire("move").fire("moveend");
						return this
					},
					_onPanTransitionStep : function() {
						this.fire("move")
					},
					_onPanTransitionEnd : function() {
						o.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim"), this.fire("moveend")
					},
					_tryAnimatedPan : function(t, e) {
						var i = this._getCenterOffset(t)._floor();
						return (e && e.animate) === !0 || this.getSize().contains(i) ? (this.panBy(i, e), !0) : !1
					}
				}), o.PosAnimation = o.DomUtil.TRANSITION ? o.PosAnimation : o.PosAnimation.extend({
					run : function(t, e, i, n) {
						this.stop(), this._el =
						t, this._inProgress = !0, this._duration = i || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = o.DomUtil.getPosition(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate()
					},
					stop : function() {
						this._inProgress && (this._step(), this._complete())
					},
					_animate : function() {
						this._animId = o.Util.requestAnimFrame(this._animate, this), this._step()
					},
					_step : function() {
						var t = +new Date - this._startTime,
						    e = 1e3 * this._duration;
						e > t ? this._runFrame(this._easeOut(t / e)) : (this._runFrame(1), this._complete())
					},
					_runFrame : function(t) {
						var e = this._startPos.add(this._offset.multiplyBy(t));
						o.DomUtil.setPosition(this._el, e), this.fire("step")
					},
					_complete : function() {
						o.Util.cancelAnimFrame(this._animId), this._inProgress = !1, this.fire("end")
					},
					_easeOut : function(t) {
						return 1 - Math.pow(1 - t, this._easeOutPower)
					}
				}), o.Map.mergeOptions({
					zoomAnimation : !0,
					zoomAnimationThreshold : 4
				}), o.DomUtil.TRANSITION && o.Map.addInitHook(function() {
					this._zoomAnimated = this.options.zoomAnimation && o.DomUtil.TRANSITION && o.Browser.any3d && !o.Browser.android23 && !o.Browser.mobileOpera, this._zoomAnimated && o.DomEvent.on(this._mapPane, o.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
				}), o.Map.include(o.DomUtil.TRANSITION ? {
					_catchTransitionEnd : function(t) {
						this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd()
					},
					_nothingToAnimate : function() {
						return !this._container.getElementsByClassName("leaflet-zoom-animated").length
					},
					_tryAnimatedZoom : function(t, e, i) {
						if (this._animatingZoom)
							return !0;
						if ( i = i || {}, !this._zoomAnimated || i.animate === !1 || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold)
							return !1;
						var n = this.getZoomScale(e),
						    o = this._getCenterOffset(t)._divideBy(1 - 1 / n),
						    s = this._getCenterLayerPoint()._add(o);
						return i.animate === !0 || this.getSize().contains(o) ? (this.fire("movestart").fire("zoomstart"), this._animateZoom(t, e, s, n, null, !0), !0) : !1
					},
					_animateZoom : function(t, e, i, n, s, a) {
						this._animatingZoom = !0, o.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim"), this._animateToCenter =
						t, this._animateToZoom =
						e, o.Draggable && (o.Draggable._disabled = !0), this.fire("zoomanim", {
							center : t,
							zoom : e,
							origin : i,
							scale : n,
							delta : s,
							backwards : a
						})
					},
					_onZoomTransitionEnd : function() {
						this._animatingZoom = !1, o.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim"), this._resetView(this._animateToCenter, this._animateToZoom, !0, !0), o.Draggable && (o.Draggable._disabled = !1)
					}
				} : {}), o.TileLayer.include({
					_animateZoom : function(t) {
						this._animating || (this._animating = !0, this._prepareBgBuffer());
						var e = this._bgBuffer,
						    i = o.DomUtil.TRANSFORM,
						    n = t.delta ? o.DomUtil.getTranslateString(t.delta) : e.style[i],
						    s = o.DomUtil.getScaleString(t.scale, t.origin);
						e.style[i] = t.backwards ? s + " " + n : n + " " + s
					},
					_endZoomAnim : function() {
						var t = this._tileContainer,
						    e = this._bgBuffer;
						t.style.visibility = "", t.parentNode.appendChild(t), o.Util.falseFn(e.offsetWidth), this._animating = !1
					},
					_clearBgBuffer : function() {
						var t = this._map;
						!t || t._animatingZoom || t.touchZoom._zooming || (this._bgBuffer.innerHTML = "", this._bgBuffer.style[o.DomUtil.TRANSFORM] = "")
					},
					_prepareBgBuffer : function() {
						var t = this._tileContainer,
						    e = this._bgBuffer,
						    i = this._getLoadedTilesPercentage(e),
						    n = this._getLoadedTilesPercentage(t);
						return e && i > .5 && .5 > n ? (t.style.visibility = "hidden", this._stopLoadingImages(t),
						void 0) : (e.style.visibility = "hidden", e.style[o.DomUtil.TRANSFORM] = "", this._tileContainer =
						e,
						e = this._bgBuffer = t, this._stopLoadingImages(e), clearTimeout(this._clearBgBufferTimer),
						void 0)
					},
					_getLoadedTilesPercentage : function(t) {
						var e,
						    i,
						    n = t.getElementsByTagName("img"),
						    o = 0;
						for ( e = 0,
						i = n.length; i > e; e++)
							n[e].complete && o++;
						return o / i
					},
					_stopLoadingImages : function(t) {
						var e,
						    i,
						    n,
						    s = Array.prototype.slice.call(t.getElementsByTagName("img"));
						for ( e = 0,
						i = s.length; i > e; e++)
							n = s[e], n.complete || (n.onload = o.Util.falseFn, n.onerror = o.Util.falseFn, n.src = o.Util.emptyImageUrl, n.parentNode.removeChild(n))
					}
				}), o.Map.include({
					_defaultLocateOptions : {
						watch : !1,
						setView : !1,
						maxZoom : 1 / 0,
						timeout : 1e4,
						maximumAge : 0,
						enableHighAccuracy : !1
					},
					locate : function(t) {
						if ( t = this._locateOptions = o.extend(this._defaultLocateOptions, t), !navigator.geolocation)
							return this._handleGeolocationError({
								code : 0,
								message : "Geolocation not supported."
							}), this;
						var e = o.bind(this._handleGeolocationResponse, this),
						    i = o.bind(this._handleGeolocationError, this);
						return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this
					},
					stopLocate : function() {
						return navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this
					},
					_handleGeolocationError : function(t) {
						var e = t.code,
						    i = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout");
						this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
							code : e,
							message : "Geolocation error: " + i + "."
						})
					},
					_handleGeolocationResponse : function(t) {
						var e = t.coords.latitude,
						    i = t.coords.longitude,
						    n = new o.LatLng(e, i),
						    s = 180 * t.coords.accuracy / 40075017,
						    a = s / Math.cos(o.LatLng.DEG_TO_RAD * e),
						    r = o.latLngBounds([e - s, i - a], [e + s, i + a]),
						    h = this._locateOptions;
						if (h.setView) {
							var l = Math.min(this.getBoundsZoom(r), h.maxZoom);
							this.setView(n, l)
						}
						var u = {
							latlng : n,
							bounds : r,
							timestamp : t.timestamp
						};
						for (var c in t.coords)"number" == typeof t.coords[c] && (u[c] = t.coords[c]);
						this.fire("locationfound", u)
					}
				})
			}(window, document);
		</script>

		<!-- jquery -->
		<script>
			//contents of jquery-1.9.1.js script

			/*!
			 * jQuery JavaScript Library v1.9.1
			 * http://jquery.com/
			 *
			 * Includes Sizzle.js
			 * http://sizzlejs.com/
			 *
			 * Copyright 2005, 2012 jQuery Foundation, Inc. and other contributors
			 * Released under the MIT license
			 * http://jquery.org/license
			 *
			 * Date: 2013-2-4
			 */
			(function(window, undefined) {

				// Can't do this because several apps including ASP.NET trace
				// the stack via arguments.caller.callee and Firefox dies if
				// you try to trace through "use strict" call chains. (#13335)
				// Support: Firefox 18+
				//"use strict";
				var
				// The deferred used on DOM ready
				readyList,

				// A central reference to the root jQuery(document)
				    rootjQuery,

				// Support: IE<9
				// For `typeof node.method` instead of `node.method !== undefined`
				    core_strundefined = typeof undefined,

				// Use the correct document accordingly with window argument (sandbox)
				    document = window.document,
				    location = window.location,

				// Map over jQuery in case of overwrite
				    _jQuery = window.jQuery,

				// Map over the $ in case of overwrite
				    _$ = window.$,

				// [[Class]] -> type pairs
				    class2type = {},

				// List of deleted data cache ids, so we can reuse them
				    core_deletedIds = [],

				    core_version = "1.9.1",

				// Save a reference to some core methods
				    core_concat = core_deletedIds.concat,
				    core_push = core_deletedIds.push,
				    core_slice = core_deletedIds.slice,
				    core_indexOf = core_deletedIds.indexOf,
				    core_toString = class2type.toString,
				    core_hasOwn = class2type.hasOwnProperty,
				    core_trim = core_version.trim,

				// Define a local copy of jQuery
				    jQuery = function(selector, context) {
					// The jQuery object is actually just the init constructor 'enhanced'
					return new jQuery.fn.init(selector, context, rootjQuery);
				},

				// Used for matching numbers
				    core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

				// Used for splitting on whitespace
				    core_rnotwhite = /\S+/g,

				// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
				    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

				// A simple way to check for HTML strings
				// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
				// Strict HTML recognition (#11290: must start with <)
				    rquickExpr = /^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,

				// Match a standalone tag
				    rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

				// JSON RegExp
				    rvalidchars = /^[\],:{}\s]*$/,
				    rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
				    rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
				    rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,

				// Matches dashed string for camelizing
				    rmsPrefix = /^-ms-/,
				    rdashAlpha = /-([\da-z])/gi,

				// Used by jQuery.camelCase as callback to replace()
				    fcamelCase = function(all, letter) {
					return letter.toUpperCase();
				},

				// The ready event handler
				    completed = function(event) {

					// readyState === "complete" is good enough for us to call the dom ready in oldIE
					if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
						detach();
						jQuery.ready();
					}
				},
				// Clean-up method for dom ready events
				    detach = function() {
					if (document.addEventListener) {
						document.removeEventListener("DOMContentLoaded", completed, false);
						window.removeEventListener("load", completed, false);

					} else {
						document.detachEvent("onreadystatechange", completed);
						window.detachEvent("onload", completed);
					}
				};

				jQuery.fn = jQuery.prototype = {
					// The current version of jQuery being used
					jquery : core_version,

					constructor : jQuery,
					init : function(selector, context, rootjQuery) {
						var match,
						    elem;

						// HANDLE: $(""), $(null), $(undefined), $(false)
						if (!selector) {
							return this;
						}

						// Handle HTML strings
						if ( typeof selector === "string") {
							if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
								// Assume that strings that start and end with <> are HTML and skip the regex check
								match = [null, selector, null];

							} else {
								match = rquickExpr.exec(selector);
							}

							// Match html or make sure no context is specified for #id
							if (match && (match[1] || !context)) {

								// HANDLE: $(html) -> $(array)
								if (match[1]) {
									context = context instanceof jQuery ? context[0] : context;

									// scripts is true for back-compat
									jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

									// HANDLE: $(html, props)
									if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
										for (match in context ) {
											// Properties of context are called as methods if possible
											if (jQuery.isFunction(this[match])) {
												this[ match ](context[match]);

												// ...and otherwise set as attributes
											} else {
												this.attr(match, context[match]);
											}
										}
									}

									return this;

									// HANDLE: $(#id)
								} else {
									elem = document.getElementById(match[2]);

									// Check parentNode to catch when Blackberry 4.6 returns
									// nodes that are no longer in the document #6963
									if (elem && elem.parentNode) {
										// Handle the case where IE and Opera return items
										// by name instead of ID
										if (elem.id !== match[2]) {
											return rootjQuery.find(selector);
										}

										// Otherwise, we inject the element directly into the jQuery object
										this.length = 1;
										this[0] = elem;
									}

									this.context = document;
									this.selector = selector;
									return this;
								}

								// HANDLE: $(expr, $(...))
							} else if (!context || context.jquery) {
								return (context || rootjQuery ).find(selector);

								// HANDLE: $(expr, context)
								// (which is just equivalent to: $(context).find(expr)
							} else {
								return this.constructor(context).find(selector);
							}

							// HANDLE: $(DOMElement)
						} else if (selector.nodeType) {
							this.context = this[0] = selector;
							this.length = 1;
							return this;

							// HANDLE: $(function)
							// Shortcut for document ready
						} else if (jQuery.isFunction(selector)) {
							return rootjQuery.ready(selector);
						}

						if (selector.selector !== undefined) {
							this.selector = selector.selector;
							this.context = selector.context;
						}

						return jQuery.makeArray(selector, this);
					},

					// Start with an empty selector
					selector : "",

					// The default length of a jQuery object is 0
					length : 0,

					// The number of elements contained in the matched element set
					size : function() {
						return this.length;
					},

					toArray : function() {
						return core_slice.call(this);
					},

					// Get the Nth element in the matched element set OR
					// Get the whole matched element set as a clean array
					get : function(num) {
						return num == null ?

						// Return a 'clean' array
						this.toArray() :

						// Return just the object
						(num < 0 ? this[this.length + num] : this[num] );
					},

					// Take an array of elements and push it onto the stack
					// (returning the new matched element set)
					pushStack : function(elems) {

						// Build a new jQuery matched element set
						var ret = jQuery.merge(this.constructor(), elems);

						// Add the old object onto the stack (as a reference)
						ret.prevObject = this;
						ret.context = this.context;

						// Return the newly-formed element set
						return ret;
					},

					// Execute a callback for every element in the matched set.
					// (You can seed the arguments with an array of args, but this is
					// only used internally.)
					each : function(callback, args) {
						return jQuery.each(this, callback, args);
					},

					ready : function(fn) {
						// Add the callback
						jQuery.ready.promise().done(fn);

						return this;
					},

					slice : function() {
						return this.pushStack(core_slice.apply(this, arguments));
					},

					first : function() {
						return this.eq(0);
					},

					last : function() {
						return this.eq(-1);
					},

					eq : function(i) {
						var len = this.length,
						    j = +i + (i < 0 ? len : 0 );
						return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
					},

					map : function(callback) {
						return this.pushStack(jQuery.map(this, function(elem, i) {
							return callback.call(elem, i, elem);
						}));
					},

					end : function() {
						return this.prevObject || this.constructor(null);
					},

					// For internal use only.
					// Behaves like an Array's method, not like a jQuery method.
					push : core_push,
					sort : [].sort,
					splice : [].splice
				};

				// Give the init function the jQuery prototype for later instantiation
				jQuery.fn.init.prototype = jQuery.fn;

				jQuery.extend = jQuery.fn.extend = function() {
					var src,
					    copyIsArray,
					    copy,
					    name,
					    options,
					    clone,
					    target = arguments[0] || {},
					    i = 1,
					    length = arguments.length,
					    deep = false;

					// Handle a deep copy situation
					if ( typeof target === "boolean") {
						deep = target;
						target = arguments[1] || {};
						// skip the boolean and the target
						i = 2;
					}

					// Handle case when target is a string or something (possible in deep copy)
					if ( typeof target !== "object" && !jQuery.isFunction(target)) {
						target = {};
					}

					// extend jQuery itself if only one argument is passed
					if (length === i) {
						target = this; --i;
					}

					for (; i < length; i++) {
						// Only deal with non-null/undefined values
						if (( options = arguments[i]) != null) {
							// Extend the base object
							for (name in options ) {
								src = target[name];
								copy = options[name];

								// Prevent never-ending loop
								if (target === copy) {
									continue;
								}

								// Recurse if we're merging plain objects or arrays
								if (deep && copy && (jQuery.isPlainObject(copy) || ( copyIsArray = jQuery.isArray(copy)) )) {
									if (copyIsArray) {
										copyIsArray = false;
										clone = src && jQuery.isArray(src) ? src : [];

									} else {
										clone = src && jQuery.isPlainObject(src) ? src : {};
									}

									// Never move original objects, clone them
									target[name] = jQuery.extend(deep, clone, copy);

									// Don't bring in undefined values
								} else if (copy !== undefined) {
									target[name] = copy;
								}
							}
						}
					}

					// Return the modified object
					return target;
				};

				jQuery.extend({
					noConflict : function(deep) {
						if (window.$ === jQuery) {
							window.$ = _$;
						}

						if (deep && window.jQuery === jQuery) {
							window.jQuery = _jQuery;
						}

						return jQuery;
					},

					// Is the DOM ready to be used? Set to true once it occurs.
					isReady : false,

					// A counter to track how many items to wait for before
					// the ready event fires. See #6781
					readyWait : 1,

					// Hold (or release) the ready event
					holdReady : function(hold) {
						if (hold) {
							jQuery.readyWait++;
						} else {
							jQuery.ready(true);
						}
					},

					// Handle when the DOM is ready
					ready : function(wait) {

						// Abort if there are pending holds or we're already ready
						if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
							return;
						}

						// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
						if (!document.body) {
							return setTimeout(jQuery.ready);
						}

						// Remember that the DOM is ready
						jQuery.isReady = true;

						// If a normal DOM Ready event fired, decrement, and wait if need be
						if (wait !== true && --jQuery.readyWait > 0) {
							return;
						}

						// If there are functions bound, to execute
						readyList.resolveWith(document, [jQuery]);

						// Trigger any bound ready events
						if (jQuery.fn.trigger) {
							jQuery(document).trigger("ready").off("ready");
						}
					},

					// See test/unit/core.js for details concerning isFunction.
					// Since version 1.3, DOM methods and functions like alert
					// aren't supported. They return false on IE (#2968).
					isFunction : function(obj) {
						return jQuery.type(obj) === "function";
					},

					isArray : Array.isArray ||
					function(obj) {
						return jQuery.type(obj) === "array";
					},

					isWindow : function(obj) {
						return obj != null && obj == obj.window;
					},

					isNumeric : function(obj) {
						return !isNaN(parseFloat(obj)) && isFinite(obj);
					},

					type : function(obj) {
						if (obj == null) {
							return String(obj);
						}
						return typeof obj === "object" || typeof obj === "function" ? class2type[ core_toString.call(obj)] || "object" : typeof obj;
					},

					isPlainObject : function(obj) {
						// Must be an Object.
						// Because of IE, we also have to check the presence of the constructor property.
						// Make sure that DOM nodes and window objects don't pass through, as well
						if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
							return false;
						}

						try {
							// Not own constructor property must be Object
							if (obj.constructor && !core_hasOwn.call(obj, "constructor") && !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
								return false;
							}
						} catch ( e ) {
							// IE8,9 Will throw exceptions on certain host objects #9897
							return false;
						}

						// Own properties are enumerated firstly, so to speed up,
						// if last one is own, then all properties are own.

						var key;
						for (key in obj ) {
						}

						return key === undefined || core_hasOwn.call(obj, key);
					},

					isEmptyObject : function(obj) {
						var name;
						for (name in obj ) {
							return false;
						}
						return true;
					},

					error : function(msg) {
						throw new Error(msg);
					},

					// data: string of html
					// context (optional): If specified, the fragment will be created in this context, defaults to document
					// keepScripts (optional): If true, will include scripts passed in the html string
					parseHTML : function(data, context, keepScripts) {
						if (!data || typeof data !== "string") {
							return null;
						}
						if ( typeof context === "boolean") {
							keepScripts = context;
							context = false;
						}
						context = context || document;

						var parsed = rsingleTag.exec(data),
						    scripts = !keepScripts && [];

						// Single tag
						if (parsed) {
							return [context.createElement(parsed[1])];
						}

						parsed = jQuery.buildFragment([data], context, scripts);
						if (scripts) {
							jQuery(scripts).remove();
						}
						return jQuery.merge([], parsed.childNodes);
					},

					parseJSON : function(data) {
						// Attempt to parse using the native JSON parser first
						if (window.JSON && window.JSON.parse) {
							return window.JSON.parse(data);
						}

						if (data === null) {
							return data;
						}

						if ( typeof data === "string") {

							// Make sure leading/trailing whitespace is removed (IE can't handle it)
							data = jQuery.trim(data);

							if (data) {
								// Make sure the incoming data is actual JSON
								// Logic borrowed from http://json.org/json2.js
								if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {

									return (new Function("return " + data) )();
								}
							}
						}

						jQuery.error("Invalid JSON: " + data);
					},

					// Cross-browser xml parsing
					parseXML : function(data) {
						var xml,
						    tmp;
						if (!data || typeof data !== "string") {
							return null;
						}
						try {
							if (window.DOMParser) {// Standard
								tmp = new DOMParser();
								xml = tmp.parseFromString(data, "text/xml");
							} else {// IE
								xml = new ActiveXObject("Microsoft.XMLDOM");
								xml.async = "false";
								xml.loadXML(data);
							}
						} catch( e ) {
							xml = undefined;
						}
						if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
							jQuery.error("Invalid XML: " + data);
						}
						return xml;
					},

					noop : function() {
					},

					// Evaluates a script in a global context
					// Workarounds based on findings by Jim Driscoll
					// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
					globalEval : function(data) {
						if (data && jQuery.trim(data)) {
							// We use execScript on Internet Explorer
							// We use an anonymous function so that context is window
							// rather than jQuery in Firefox
							(window.execScript ||
							function(data) {
								window["eval"].call(window, data);
							} )(data);
						}
					},

					// Convert dashed to camelCase; used by the css and data modules
					// Microsoft forgot to hump their vendor prefix (#9572)
					camelCase : function(string) {
						return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
					},

					nodeName : function(elem, name) {
						return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
					},

					// args is for internal usage only
					each : function(obj, callback, args) {
						var value,
						    i = 0,
						    length = obj.length,
						    isArray = isArraylike(obj);

						if (args) {
							if (isArray) {
								for (; i < length; i++) {
									value = callback.apply(obj[i], args);

									if (value === false) {
										break;
									}
								}
							} else {
								for (i in obj ) {
									value = callback.apply(obj[i], args);

									if (value === false) {
										break;
									}
								}
							}

							// A special, fast, case for the most common use of each
						} else {
							if (isArray) {
								for (; i < length; i++) {
									value = callback.call(obj[i], i, obj[i]);

									if (value === false) {
										break;
									}
								}
							} else {
								for (i in obj ) {
									value = callback.call(obj[i], i, obj[i]);

									if (value === false) {
										break;
									}
								}
							}
						}

						return obj;
					},

					// Use native String.trim function wherever possible
					trim : core_trim && !core_trim.call("\uFEFF\xA0") ? function(text) {
						return text == null ? "" : core_trim.call(text);
					} :

					// Otherwise use our own trimming functionality
					function(text) {
						return text == null ? "" : (text + "" ).replace(rtrim, "");
					},

					// results is for internal usage only
					makeArray : function(arr, results) {
						var ret = results || [];

						if (arr != null) {
							if (isArraylike(Object(arr))) {
								jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
							} else {
								core_push.call(ret, arr);
							}
						}

						return ret;
					},

					inArray : function(elem, arr, i) {
						var len;

						if (arr) {
							if (core_indexOf) {
								return core_indexOf.call(arr, elem, i);
							}

							len = arr.length;
							i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

							for (; i < len; i++) {
								// Skip accessing in sparse arrays
								if ( i in arr && arr[i] === elem) {
									return i;
								}
							}
						}

						return -1;
					},

					merge : function(first, second) {
						var l = second.length,
						    i = first.length,
						    j = 0;

						if ( typeof l === "number") {
							for (; j < l; j++) {
								first[i++] = second[j];
							}
						} else {
							while (second[j] !== undefined) {
								first[i++] = second[j++];
							}
						}

						first.length = i;

						return first;
					},

					grep : function(elems, callback, inv) {
						var retVal,
						    ret = [],
						    i = 0,
						    length = elems.length;
						inv = !!inv;

						// Go through the array, only saving the items
						// that pass the validator function
						for (; i < length; i++) {
							retVal = !!callback(elems[i], i);
							if (inv !== retVal) {
								ret.push(elems[i]);
							}
						}

						return ret;
					},

					// arg is for internal usage only
					map : function(elems, callback, arg) {
						var value,
						    i = 0,
						    length = elems.length,
						    isArray = isArraylike(elems),
						    ret = [];

						// Go through the array, translating each of the items to their
						if (isArray) {
							for (; i < length; i++) {
								value = callback(elems[i], i, arg);

								if (value != null) {
									ret[ret.length] = value;
								}
							}

							// Go through every key on the object,
						} else {
							for (i in elems ) {
								value = callback(elems[i], i, arg);

								if (value != null) {
									ret[ret.length] = value;
								}
							}
						}

						// Flatten any nested arrays
						return core_concat.apply([], ret);
					},

					// A global GUID counter for objects
					guid : 1,

					// Bind a function to a context, optionally partially applying any
					// arguments.
					proxy : function(fn, context) {
						var args,
						    proxy,
						    tmp;

						if ( typeof context === "string") {
							tmp = fn[context];
							context = fn;
							fn = tmp;
						}

						// Quick check to determine if target is callable, in the spec
						// this throws a TypeError, but we will just return undefined.
						if (!jQuery.isFunction(fn)) {
							return undefined;
						}

						// Simulated bind
						args = core_slice.call(arguments, 2);
						proxy = function() {
							return fn.apply(context || this, args.concat(core_slice.call(arguments)));
						};

						// Set the guid of unique handler to the same of original handler, so it can be removed
						proxy.guid = fn.guid = fn.guid || jQuery.guid++;

						return proxy;
					},

					// Multifunctional method to get and set values of a collection
					// The value/s can optionally be executed if it's a function
					access : function(elems, fn, key, value, chainable, emptyGet, raw) {
						var i = 0,
						    length = elems.length,
						    bulk = key == null;

						// Sets many values
						if (jQuery.type(key) === "object") {
							chainable = true;
							for (i in key ) {
								jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
							}

							// Sets one value
						} else if (value !== undefined) {
							chainable = true;

							if (!jQuery.isFunction(value)) {
								raw = true;
							}

							if (bulk) {
								// Bulk operations run against the entire set
								if (raw) {
									fn.call(elems, value);
									fn = null;

									// ...except when executing function values
								} else {
									bulk = fn;
									fn = function(elem, key, value) {
										return bulk.call(jQuery(elem), value);
									};
								}
							}

							if (fn) {
								for (; i < length; i++) {
									fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
								}
							}
						}

						return chainable ? elems :

						// Gets
						bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
					},

					now : function() {
						return (new Date() ).getTime();
					}
				});

				jQuery.ready.promise = function(obj) {
					if (!readyList) {

						readyList = jQuery.Deferred();

						// Catch cases where $(document).ready() is called after the browser event has already occurred.
						// we once tried to use readyState "interactive" here, but it caused issues like the one
						// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
						if (document.readyState === "complete") {
							// Handle it asynchronously to allow scripts the opportunity to delay ready
							setTimeout(jQuery.ready);

							// Standards-based browsers support DOMContentLoaded
						} else if (document.addEventListener) {
							// Use the handy event callback
							document.addEventListener("DOMContentLoaded", completed, false);

							// A fallback to window.onload, that will always work
							window.addEventListener("load", completed, false);

							// If IE event model is used
						} else {
							// Ensure firing before onload, maybe late but safe also for iframes
							document.attachEvent("onreadystatechange", completed);

							// A fallback to window.onload, that will always work
							window.attachEvent("onload", completed);

							// If IE and not a frame
							// continually check to see if the document is ready
							var top = false;

							try {
								top = window.frameElement == null && document.documentElement;
							} catch(e) {
							}

							if (top && top.doScroll) {
								(function doScrollCheck() {
									if (!jQuery.isReady) {

										try {
											// Use the trick by Diego Perini
											// http://javascript.nwbox.com/IEContentLoaded/
											top.doScroll("left");
										} catch(e) {
											return setTimeout(doScrollCheck, 50);
										}

										// detach all dom ready events
										detach();

										// and execute any waiting functions
										jQuery.ready();
									}
								})();
							}
						}
					}
					return readyList.promise(obj);
				};

				// Populate the class2type map
				jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
					class2type["[object " + name + "]"] = name.toLowerCase();
				});

				function isArraylike(obj) {
					var length = obj.length,
					    type = jQuery.type(obj);

					if (jQuery.isWindow(obj)) {
						return false;
					}

					if (obj.nodeType === 1 && length) {
						return true;
					}

					return type === "array" || type !== "function" && (length === 0 || typeof length === "number" && length > 0 && (length - 1 ) in obj );
				}

				// All jQuery objects should point back to these
				rootjQuery = jQuery(document);
				// String to Object options format cache
				var optionsCache = {};

				// Convert String-formatted options into Object-formatted ones and store in cache
				function createOptions(options) {
					var object = optionsCache[options] = {};
					jQuery.each(options.match(core_rnotwhite) || [], function(_, flag) {
						object[flag] = true;
					});
					return object;
				}

				/*
				 * Create a callback list using the following parameters:
				 *
				 *  options: an optional list of space-separated options that will change how
				 *      the callback list behaves or a more traditional option object
				 *
				 * By default a callback list will act like an event callback list and can be
				 * "fired" multiple times.
				 *
				 * Possible options:
				 *
				 *  once:     will ensure the callback list can only be fired once (like a Deferred)
				 *
				 *  memory:     will keep track of previous values and will call any callback added
				 *          after the list has been fired right away with the latest "memorized"
				 *          values (like a Deferred)
				 *
				 *  unique:     will ensure a callback can only be added once (no duplicate in the list)
				 *
				 *  stopOnFalse:  interrupt callings when a callback returns false
				 *
				 */
				jQuery.Callbacks = function(options) {

					// Convert options from String-formatted to Object-formatted if needed
					// (we check in cache first)
					options = typeof options === "string" ? (optionsCache[options] || createOptions(options) ) : jQuery.extend({}, options);

					var// Flag to know if list is currently firing
					firing,
					// Last fire value (for non-forgettable lists)
					    memory,
					// Flag to know if list was already fired
					    fired,
					// End of the loop when firing
					    firingLength,
					// Index of currently firing callback (modified by remove if needed)
					    firingIndex,
					// First callback to fire (used internally by add and fireWith)
					    firingStart,
					// Actual callback list
					    list = [],
					// Stack of fire calls for repeatable lists
					    stack = !options.once && [],
					// Fire callbacks
					    fire = function(data) {
						memory = options.memory && data;
						fired = true;
						firingIndex = firingStart || 0;
						firingStart = 0;
						firingLength = list.length;
						firing = true;
						for (; list && firingIndex < firingLength; firingIndex++) {
							if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
								memory = false;
								// To prevent further calls using add
								break;
							}
						}
						firing = false;
						if (list) {
							if (stack) {
								if (stack.length) {
									fire(stack.shift());
								}
							} else if (memory) {
								list = [];
							} else {
								self.disable();
							}
						}
					},
					// Actual Callbacks object
					    self = {
						// Add a callback or a collection of callbacks to the list
						add : function() {
							if (list) {
								// First, we save the current length
								var start = list.length;
								(function add(args) {
									jQuery.each(args, function(_, arg) {
										var type = jQuery.type(arg);
										if (type === "function") {
											if (!options.unique || !self.has(arg)) {
												list.push(arg);
											}
										} else if (arg && arg.length && type !== "string") {
											// Inspect recursively
											add(arg);
										}
									});
								})(arguments);
								// Do we need to add the callbacks to the
								// current firing batch?
								if (firing) {
									firingLength = list.length;
									// With memory, if we're not firing then
									// we should call right away
								} else if (memory) {
									firingStart = start;
									fire(memory);
								}
							}
							return this;
						},
						// Remove a callback from the list
						remove : function() {
							if (list) {
								jQuery.each(arguments, function(_, arg) {
									var index;
									while (( index = jQuery.inArray(arg, list, index) ) > -1) {
										list.splice(index, 1);
										// Handle firing indexes
										if (firing) {
											if (index <= firingLength) {
												firingLength--;
											}
											if (index <= firingIndex) {
												firingIndex--;
											}
										}
									}
								});
							}
							return this;
						},
						// Check if a given callback is in the list.
						// If no argument is given, return whether or not list has callbacks attached.
						has : function(fn) {
							return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length );
						},
						// Remove all callbacks from the list
						empty : function() {
							list = [];
							return this;
						},
						// Have the list do nothing anymore
						disable : function() {
							list = stack = memory = undefined;
							return this;
						},
						// Is it disabled?
						disabled : function() {
							return !list;
						},
						// Lock the list in its current state
						lock : function() {
							stack = undefined;
							if (!memory) {
								self.disable();
							}
							return this;
						},
						// Is it locked?
						locked : function() {
							return !stack;
						},
						// Call all callbacks with the given context and arguments
						fireWith : function(context, args) {
							args = args || [];
							args = [context, args.slice ? args.slice() : args];
							if (list && (!fired || stack )) {
								if (firing) {
									stack.push(args);
								} else {
									fire(args);
								}
							}
							return this;
						},
						// Call all the callbacks with the given arguments
						fire : function() {
							self.fireWith(this, arguments);
							return this;
						},
						// To know if the callbacks have already been called at least once
						fired : function() {
							return !!fired;
						}
					};

					return self;
				};
				jQuery.extend({

					Deferred : function(func) {
						var tuples = [
						// action, add listener, listener list, final state
						["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
						    state = "pending",
						    promise = {
							state : function() {
								return state;
							},
							always : function() {
								deferred.done(arguments).fail(arguments);
								return this;
							},
							then : function(/* fnDone, fnFail, fnProgress */ ) {
								var fns = arguments;
								return jQuery.Deferred(function(newDefer) {
									jQuery.each(tuples, function(i, tuple) {
										var action = tuple[0],
										    fn = jQuery.isFunction(fns[i]) && fns[i];
										// deferred[ done | fail | progress ] for forwarding actions to newDefer
										deferred[ tuple[1] ](function() {
											var returned = fn && fn.apply(this, arguments);
											if (returned && jQuery.isFunction(returned.promise)) {
												returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
											} else {
												newDefer[ action + "With" ](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
											}
										});
									});
									fns = null;
								}).promise();
							},
							// Get a promise for this deferred
							// If obj is provided, the promise aspect is added to the object
							promise : function(obj) {
								return obj != null ? jQuery.extend(obj, promise) : promise;
							}
						},
						    deferred = {};

						// Keep pipe for back-compat
						promise.pipe = promise.then;

						// Add list-specific methods
						jQuery.each(tuples, function(i, tuple) {
							var list = tuple[2],
							    stateString = tuple[3];

							// promise[ done | fail | progress ] = list.add
							promise[tuple[1]] = list.add;

							// Handle state
							if (stateString) {
								list.add(function() {
									// state = [ resolved | rejected ]
									state = stateString;

									// [ reject_list | resolve_list ].disable; progress_list.lock
								}, tuples[ i ^ 1 ][2].disable, tuples[ 2 ][2].lock);
							}

							// deferred[ resolve | reject | notify ]
							deferred[tuple[0]] = function() {
								deferred[ tuple[0] + "With" ](this === deferred ? promise : this, arguments);
								return this;
							};
							deferred[tuple[0] + "With"] = list.fireWith;
						});

						// Make the deferred a promise
						promise.promise(deferred);

						// Call given func if any
						if (func) {
							func.call(deferred, deferred);
						}

						// All done!
						return deferred;
					},

					// Deferred helper
					when : function(subordinate /* , ..., subordinateN */ ) {
						var i = 0,
						    resolveValues = core_slice.call(arguments),
						    length = resolveValues.length,

						// the count of uncompleted subordinates
						    remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise) ) ? length : 0,

						// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
						    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

						// Update function for both resolve and progress values
						    updateFunc = function(i, contexts, values) {
							return function(value) {
								contexts[i] = this;
								values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
								if (values === progressValues) {
									deferred.notifyWith(contexts, values);
								} else if (!(--remaining )) {
									deferred.resolveWith(contexts, values);
								}
							};
						},

						    progressValues,
						    progressContexts,
						    resolveContexts;

						// add listeners to Deferred subordinates; treat others as resolved
						if (length > 1) {
							progressValues = new Array(length);
							progressContexts = new Array(length);
							resolveContexts = new Array(length);
							for (; i < length; i++) {
								if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
									resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
								} else {--remaining;
								}
							}
						}

						// if we're not waiting on anything, resolve the master
						if (!remaining) {
							deferred.resolveWith(resolveContexts, resolveValues);
						}

						return deferred.promise();
					}
				});
				jQuery.support = (function() {

					var support,
					    all,
					    a,
					    input,
					    select,
					    fragment,
					    opt,
					    eventName,
					    isSupported,
					    i,
					    div = document.createElement("div");

					// Setup
					div.setAttribute("className", "t");
					div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

					// Support tests won't run in some limited or non-browser environments
					all = div.getElementsByTagName("*");
					a = div.getElementsByTagName("a")[0];
					if (!all || !a || !all.length) {
						return {};
					}

					// First batch of tests
					select = document.createElement("select");
					opt = select.appendChild(document.createElement("option"));
					input = div.getElementsByTagName("input")[0];

					a.style.cssText = "top:1px;float:left;opacity:.5";
					support = {
						// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
						getSetAttribute : div.className !== "t",

						// IE strips leading whitespace when .innerHTML is used
						leadingWhitespace : div.firstChild.nodeType === 3,

						// Make sure that tbody elements aren't automatically inserted
						// IE will insert them into empty tables
						tbody : !div.getElementsByTagName("tbody").length,

						// Make sure that link elements get serialized correctly by innerHTML
						// This requires a wrapper element in IE
						htmlSerialize : !!div.getElementsByTagName("link").length,

						// Get the style information from getAttribute
						// (IE uses .cssText instead)
						style : /top/.test(a.getAttribute("style")),

						// Make sure that URLs aren't manipulated
						// (IE normalizes it by default)
						hrefNormalized : a.getAttribute("href") === "/a",

						// Make sure that element opacity exists
						// (IE uses filter instead)
						// Use a regex to work around a WebKit issue. See #5145
						opacity : /^0.5/.test(a.style.opacity),

						// Verify style float existence
						// (IE uses styleFloat instead of cssFloat)
						cssFloat : !!a.style.cssFloat,

						// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
						checkOn : !!input.value,

						// Make sure that a selected-by-default option has a working selected property.
						// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
						optSelected : opt.selected,

						// Tests for enctype support on a form (#6743)
						enctype : !!document.createElement("form").enctype,

						// Makes sure cloning an html5 element does not cause problems
						// Where outerHTML is undefined, this still works
						html5Clone : document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",

						// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
						boxModel : document.compatMode === "CSS1Compat",

						// Will be defined later
						deleteExpando : true,
						noCloneEvent : true,
						inlineBlockNeedsLayout : false,
						shrinkWrapBlocks : false,
						reliableMarginRight : true,
						boxSizingReliable : true,
						pixelPosition : false
					};

					// Make sure checked status is properly cloned
					input.checked = true;
					support.noCloneChecked = input.cloneNode(true).checked;

					// Make sure that the options inside disabled selects aren't marked as disabled
					// (WebKit marks them as disabled)
					select.disabled = true;
					support.optDisabled = !opt.disabled;

					// Support: IE<9
					try {
						delete div.test;
					} catch( e ) {
						support.deleteExpando = false;
					}

					// Check if we can trust getAttribute("value")
					input = document.createElement("input");
					input.setAttribute("value", "");
					support.input = input.getAttribute("value") === "";

					// Check if an input maintains its value after becoming a radio
					input.value = "t";
					input.setAttribute("type", "radio");
					support.radioValue = input.value === "t";

					// #11217 - WebKit loses check when the name is after the checked attribute
					input.setAttribute("checked", "t");
					input.setAttribute("name", "t");

					fragment = document.createDocumentFragment();
					fragment.appendChild(input);

					// Check if a disconnected checkbox will retain its checked
					// value of true after appended to the DOM (IE6/7)
					support.appendChecked = input.checked;

					// WebKit doesn't clone checked state correctly in fragments
					support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

					// Support: IE<9
					// Opera does not clone events (and typeof div.attachEvent === undefined).
					// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
					if (div.attachEvent) {
						div.attachEvent("onclick", function() {
							support.noCloneEvent = false;
						});

						div.cloneNode(true).click();
					}

					// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
					// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP), test/csp.php
					for (i in {
						submit : true,
						change : true,
						focusin : true
					}) {
						div.setAttribute( eventName = "on" + i, "t");

						support[i + "Bubbles"] = eventName in window || div.attributes[eventName].expando === false;
					}

					div.style.backgroundClip = "content-box";
					div.cloneNode(true).style.backgroundClip = "";
					support.clearCloneStyle = div.style.backgroundClip === "content-box";

					// Run tests that need a body at doc ready
					jQuery(function() {
						var container,
						    marginDiv,
						    tds,
						    divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
						    body = document.getElementsByTagName("body")[0];

						if (!body) {
							// Return for frameset docs that don't have a body
							return;
						}

						container = document.createElement("div");
						container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

						body.appendChild(container).appendChild(div);

						// Support: IE8
						// Check if table cells still have offsetWidth/Height when they are set
						// to display:none and there are still other visible table cells in a
						// table row; if so, offsetWidth/Height are not reliable for use when
						// determining if an element has been hidden directly using
						// display:none (it is still safe to use offsets if a parent element is
						// hidden; don safety goggles and see bug #4512 for more information).
						div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
						tds = div.getElementsByTagName("td");
						tds[0].style.cssText = "padding:0;margin:0;border:0;display:none";
						isSupported = (tds[0].offsetHeight === 0 );

						tds[0].style.display = "";
						tds[1].style.display = "none";

						// Support: IE8
						// Check if empty table cells still have offsetWidth/Height
						support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0 );

						// Check box-sizing and margin behavior
						div.innerHTML = "";
						div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
						support.boxSizing = (div.offsetWidth === 4 );
						support.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== 1 );

						// Use window.getComputedStyle because jsdom on node.js will break without it.
						if (window.getComputedStyle) {
							support.pixelPosition = (window.getComputedStyle(div, null) || {} ).top !== "1%";
							support.boxSizingReliable = (window.getComputedStyle(div, null) || {
								width : "4px"
							} ).width === "4px";

							// Check if div with explicit width and no margin-right incorrectly
							// gets computed margin-right based on width of container. (#3333)
							// Fails in WebKit before Feb 2011 nightlies
							// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
							marginDiv = div.appendChild(document.createElement("div"));
							marginDiv.style.cssText = div.style.cssText = divReset;
							marginDiv.style.marginRight = marginDiv.style.width = "0";
							div.style.width = "1px";

							support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {} ).marginRight);
						}

						if ( typeof div.style.zoom !== core_strundefined) {
							// Support: IE<8
							// Check if natively block-level elements act like inline-block
							// elements when setting their display to 'inline' and giving
							// them layout
							div.innerHTML = "";
							div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
							support.inlineBlockNeedsLayout = (div.offsetWidth === 3 );

							// Support: IE6
							// Check if elements with layout shrink-wrap their children
							div.style.display = "block";
							div.innerHTML = "<div></div>";
							div.firstChild.style.width = "5px";
							support.shrinkWrapBlocks = (div.offsetWidth !== 3 );

							if (support.inlineBlockNeedsLayout) {
								// Prevent IE 6 from affecting layout for positioned elements #11048
								// Prevent IE from shrinking the body in IE 7 mode #12869
								// Support: IE<8
								body.style.zoom = 1;
							}
						}

						body.removeChild(container);

						// Null elements to avoid leaks in IE
						container = div = tds = marginDiv = null;
					});

					// Null elements to avoid leaks in IE
					all = select = fragment = opt = a = input = null;

					return support;
				})();

				var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
				    rmultiDash = /([A-Z])/g;

				function internalData(elem, name, data, pvt /* Internal Use Only */ ) {
					if (!jQuery.acceptData(elem)) {
						return;
					}

					var thisCache,
					    ret,
					    internalKey = jQuery.expando,
					    getByName = typeof name === "string",

					// We have to handle DOM nodes and JS objects differently because IE6-7
					// can't GC object references properly across the DOM-JS boundary
					    isNode = elem.nodeType,

					// Only DOM nodes need the global jQuery cache; JS object data is
					// attached directly to the object so GC can occur automatically
					    cache = isNode ? jQuery.cache : elem,

					// Only defining an ID for JS objects if its cache already exists allows
					// the code to shortcut on the same path as a DOM node with no cache
					    id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

					// Avoid doing any more work than we need to when trying to get data on an
					// object that has no data at all
					if ((!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined) {
						return;
					}

					if (!id) {
						// Only DOM nodes need a new unique ID for each element since their data
						// ends up in the global cache
						if (isNode) {
							elem[internalKey] = id = core_deletedIds.pop() || jQuery.guid++;
						} else {
							id = internalKey;
						}
					}

					if (!cache[id]) {
						cache[id] = {};

						// Avoids exposing jQuery metadata on plain JS objects when the object
						// is serialized using JSON.stringify
						if (!isNode) {
							cache[id].toJSON = jQuery.noop;
						}
					}

					// An object can be passed to jQuery.data instead of a key/value pair; this gets
					// shallow copied over onto the existing cache
					if ( typeof name === "object" || typeof name === "function") {
						if (pvt) {
							cache[id] = jQuery.extend(cache[id], name);
						} else {
							cache[id].data = jQuery.extend(cache[id].data, name);
						}
					}

					thisCache = cache[id];

					// jQuery data() is stored in a separate object inside the object's internal data
					// cache in order to avoid key collisions between internal data and user-defined
					// data.
					if (!pvt) {
						if (!thisCache.data) {
							thisCache.data = {};
						}

						thisCache = thisCache.data;
					}

					if (data !== undefined) {
						thisCache[ jQuery.camelCase(name)] = data;
					}

					// Check for both converted-to-camel and non-converted data property names
					// If a data property was specified
					if (getByName) {

						// First Try to find as-is property data
						ret = thisCache[name];

						// Test for null|undefined property data
						if (ret == null) {

							// Try to find the camelCased property
							ret = thisCache[ jQuery.camelCase(name)];
						}
					} else {
						ret = thisCache;
					}

					return ret;
				}

				function internalRemoveData(elem, name, pvt) {
					if (!jQuery.acceptData(elem)) {
						return;
					}

					var i,
					    l,
					    thisCache,
					    isNode = elem.nodeType,

					// See jQuery.data for more information
					    cache = isNode ? jQuery.cache : elem,
					    id = isNode ? elem[jQuery.expando] : jQuery.expando;

					// If there is already no cache entry for this object, there is no
					// purpose in continuing
					if (!cache[id]) {
						return;
					}

					if (name) {

						thisCache = pvt ? cache[id] : cache[id].data;

						if (thisCache) {

							// Support array or space separated string names for data keys
							if (!jQuery.isArray(name)) {

								// try the string as a key before any manipulation
								if ( name in thisCache) {
									name = [name];
								} else {

									// split the camel cased version by spaces unless a key with the spaces exists
									name = jQuery.camelCase(name);
									if ( name in thisCache) {
										name = [name];
									} else {
										name = name.split(" ");
									}
								}
							} else {
								// If "name" is an array of keys...
								// When data is initially created, via ("key", "val") signature,
								// keys will be converted to camelCase.
								// Since there is no way to tell _how_ a key was added, remove
								// both plain key and camelCase key. #12786
								// This will only penalize the array argument path.
								name = name.concat(jQuery.map(name, jQuery.camelCase));
							}

							for ( i = 0,
							l = name.length; i < l; i++) {
								delete thisCache[name[i]];
							}

							// If there is no data left in the cache, we want to continue
							// and let the cache object itself get destroyed
							if (!( pvt ? isEmptyDataObject : jQuery.isEmptyObject )(thisCache)) {
								return;
							}
						}
					}

					// See jQuery.data for more information
					if (!pvt) {
						delete cache[id].data;

						// Don't destroy the parent cache unless the internal data object
						// had been the only thing left in it
						if (!isEmptyDataObject(cache[id])) {
							return;
						}
					}

					// Destroy the cache
					if (isNode) {
						jQuery.cleanData([elem], true);

						// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
					} else if (jQuery.support.deleteExpando || cache != cache.window) {
						delete cache[id];

						// When all else fails, null
					} else {
						cache[id] = null;
					}
				}


				jQuery.extend({
					cache : {},

					// Unique for each copy of jQuery on the page
					// Non-digits removed to match rinlinejQuery
					expando : "jQuery" + (core_version + Math.random() ).replace(/\D/g, ""),

					// The following elements throw uncatchable exceptions if you
					// attempt to add expando properties to them.
					noData : {
						"embed" : true,
						// Ban all objects except for Flash (which handle expandos)
						"object" : "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
						"applet" : true
					},

					hasData : function(elem) {
						elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
						return !!elem && !isEmptyDataObject(elem);
					},

					data : function(elem, name, data) {
						return internalData(elem, name, data);
					},

					removeData : function(elem, name) {
						return internalRemoveData(elem, name);
					},

					// For internal use only.
					_data : function(elem, name, data) {
						return internalData(elem, name, data, true);
					},

					_removeData : function(elem, name) {
						return internalRemoveData(elem, name, true);
					},

					// A method for determining if a DOM node can handle the data expando
					acceptData : function(elem) {
						// Do not set data on non-element because it will not be cleared (#8335).
						if (elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9) {
							return false;
						}

						var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase()];

						// nodes accept data unless otherwise specified; rejection can be conditional
						return !noData || noData !== true && elem.getAttribute("classid") === noData;
					}
				});

				jQuery.fn.extend({
					data : function(key, value) {
						var attrs,
						    name,
						    elem = this[0],
						    i = 0,
						    data = null;

						// Gets all values
						if (key === undefined) {
							if (this.length) {
								data = jQuery.data(elem);

								if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
									attrs = elem.attributes;
									for (; i < attrs.length; i++) {
										name = attrs[i].name;

										if (!name.indexOf("data-")) {
											name = jQuery.camelCase(name.slice(5));

											dataAttr(elem, name, data[name]);
										}
									}
									jQuery._data(elem, "parsedAttrs", true);
								}
							}

							return data;
						}

						// Sets multiple values
						if ( typeof key === "object") {
							return this.each(function() {
								jQuery.data(this, key);
							});
						}

						return jQuery.access(this, function(value) {

							if (value === undefined) {
								// Try to fetch any internally stored data first
								return elem ? dataAttr(elem, key, jQuery.data(elem, key)) : null;
							}

							this.each(function() {
								jQuery.data(this, key, value);
							});
						}, null, value, arguments.length > 1, null, true);
					},

					removeData : function(key) {
						return this.each(function() {
							jQuery.removeData(this, key);
						});
					}
				});

				function dataAttr(elem, key, data) {
					// If nothing was found internally, try to fetch any
					// data from the HTML5 data-* attribute
					if (data === undefined && elem.nodeType === 1) {

						var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

						data = elem.getAttribute(name);

						if ( typeof data === "string") {
							try {
								data = data === "true" ? true : data === "false" ? false : data === "null" ? null :
								// Only convert to a number if it doesn't change the string
								+data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
							} catch( e ) {
							}

							// Make sure we set the data so it isn't changed later
							jQuery.data(elem, key, data);

						} else {
							data = undefined;
						}
					}

					return data;
				}

				// checks a cache object for emptiness
				function isEmptyDataObject(obj) {
					var name;
					for (name in obj ) {

						// if the public data object is empty, the private is still empty
						if (name === "data" && jQuery.isEmptyObject(obj[name])) {
							continue;
						}
						if (name !== "toJSON") {
							return false;
						}
					}

					return true;
				}


				jQuery.extend({
					queue : function(elem, type, data) {
						var queue;

						if (elem) {
							type = (type || "fx" ) + "queue";
							queue = jQuery._data(elem, type);

							// Speed up dequeue by getting out quickly if this is just a lookup
							if (data) {
								if (!queue || jQuery.isArray(data)) {
									queue = jQuery._data(elem, type, jQuery.makeArray(data));
								} else {
									queue.push(data);
								}
							}
							return queue || [];
						}
					},

					dequeue : function(elem, type) {
						type = type || "fx";

						var queue = jQuery.queue(elem, type),
						    startLength = queue.length,
						    fn = queue.shift(),
						    hooks = jQuery._queueHooks(elem, type),
						    next = function() {
							jQuery.dequeue(elem, type);
						};

						// If the fx queue is dequeued, always remove the progress sentinel
						if (fn === "inprogress") {
							fn = queue.shift();
							startLength--;
						}

						hooks.cur = fn;
						if (fn) {

							// Add a progress sentinel to prevent the fx queue from being
							// automatically dequeued
							if (type === "fx") {
								queue.unshift("inprogress");
							}

							// clear up the last queue stop function
							delete hooks.stop;
							fn.call(elem, next, hooks);
						}

						if (!startLength && hooks) {
							hooks.empty.fire();
						}
					},

					// not intended for public consumption - generates a queueHooks object, or returns the current one
					_queueHooks : function(elem, type) {
						var key = type + "queueHooks";
						return jQuery._data(elem, key) || jQuery._data(elem, key, {
							empty : jQuery.Callbacks("once memory").add(function() {
								jQuery._removeData(elem, type + "queue");
								jQuery._removeData(elem, key);
							})
						});
					}
				});

				jQuery.fn.extend({
					queue : function(type, data) {
						var setter = 2;

						if ( typeof type !== "string") {
							data = type;
							type = "fx";
							setter--;
						}

						if (arguments.length < setter) {
							return jQuery.queue(this[0], type);
						}

						return data === undefined ? this : this.each(function() {
							var queue = jQuery.queue(this, type, data);

							// ensure a hooks for this queue
							jQuery._queueHooks(this, type);

							if (type === "fx" && queue[0] !== "inprogress") {
								jQuery.dequeue(this, type);
							}
						});
					},
					dequeue : function(type) {
						return this.each(function() {
							jQuery.dequeue(this, type);
						});
					},
					// Based off of the plugin by Clint Helfers, with permission.
					// http://blindsignals.com/index.php/2009/07/jquery-delay/
					delay : function(time, type) {
						time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
						type = type || "fx";

						return this.queue(type, function(next, hooks) {
							var timeout = setTimeout(next, time);
							hooks.stop = function() {
								clearTimeout(timeout);
							};
						});
					},
					clearQueue : function(type) {
						return this.queue(type || "fx", []);
					},
					// Get a promise resolved when queues of a certain type
					// are emptied (fx is the type by default)
					promise : function(type, obj) {
						var tmp,
						    count = 1,
						    defer = jQuery.Deferred(),
						    elements = this,
						    i = this.length,
						    resolve = function() {
							if (!(--count )) {
								defer.resolveWith(elements, [elements]);
							}
						};

						if ( typeof type !== "string") {
							obj = type;
							type = undefined;
						}
						type = type || "fx";

						while (i--) {
							tmp = jQuery._data(elements[i], type + "queueHooks");
							if (tmp && tmp.empty) {
								count++;
								tmp.empty.add(resolve);
							}
						}
						resolve();
						return defer.promise(obj);
					}
				});
				var nodeHook,
				    boolHook,
				    rclass = /[\t\r\n]/g,
				    rreturn = /\r/g,
				    rfocusable = /^(?:input|select|textarea|button|object)$/i,
				    rclickable = /^(?:a|area)$/i,
				    rboolean = /^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,
				    ruseDefault = /^(?:checked|selected)$/i,
				    getSetAttribute = jQuery.support.getSetAttribute,
				    getSetInput = jQuery.support.input;

				jQuery.fn.extend({
					attr : function(name, value) {
						return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
					},

					removeAttr : function(name) {
						return this.each(function() {
							jQuery.removeAttr(this, name);
						});
					},

					prop : function(name, value) {
						return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
					},

					removeProp : function(name) {
						name = jQuery.propFix[name] || name;
						return this.each(function() {
							// try/catch handles cases where IE balks (such as removing a property on window)
							try {
								this[name] = undefined;
								delete this[name];
							} catch( e ) {
							}
						});
					},

					addClass : function(value) {
						var classes,
						    elem,
						    cur,
						    clazz,
						    j,
						    i = 0,
						    len = this.length,
						    proceed = typeof value === "string" && value;

						if (jQuery.isFunction(value)) {
							return this.each(function(j) {
								jQuery(this).addClass(value.call(this, j, this.className));
							});
						}

						if (proceed) {
							// The disjunction here is for better compressibility (see removeClass)
							classes = (value || "" ).match(core_rnotwhite) || [];

							for (; i < len; i++) {
								elem = this[i];
								cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " " ).replace(rclass, " ") : " "
								);

								if (cur) {
									j = 0;
									while (( clazz = classes[j++])) {
										if (cur.indexOf(" " + clazz + " ") < 0) {
											cur += clazz + " ";
										}
									}
									elem.className = jQuery.trim(cur);

								}
							}
						}

						return this;
					},

					removeClass : function(value) {
						var classes,
						    elem,
						    cur,
						    clazz,
						    j,
						    i = 0,
						    len = this.length,
						    proceed = arguments.length === 0 || typeof value === "string" && value;

						if (jQuery.isFunction(value)) {
							return this.each(function(j) {
								jQuery(this).removeClass(value.call(this, j, this.className));
							});
						}
						if (proceed) {
							classes = (value || "" ).match(core_rnotwhite) || [];

							for (; i < len; i++) {
								elem = this[i];
								// This expression is here for better compressibility (see addClass)
								cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " " ).replace(rclass, " ") : ""
								);

								if (cur) {
									j = 0;
									while (( clazz = classes[j++])) {
										// Remove *all* instances
										while (cur.indexOf(" " + clazz + " ") >= 0) {
											cur = cur.replace(" " + clazz + " ", " ");
										}
									}
									elem.className = value ? jQuery.trim(cur) : "";
								}
							}
						}

						return this;
					},

					toggleClass : function(value, stateVal) {
						var type = typeof value,
						    isBool = typeof stateVal === "boolean";

						if (jQuery.isFunction(value)) {
							return this.each(function(i) {
								jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
							});
						}

						return this.each(function() {
							if (type === "string") {
								// toggle individual class names
								var className,
								    i = 0,
								    self = jQuery(this),
								    state =
								    stateVal,
								    classNames = value.match(core_rnotwhite) || [];

								while (( className = classNames[i++])) {
									// check each className given, space separated list
									state = isBool ? state : !self.hasClass(className);
									self[ state ? "addClass" : "removeClass" ](className);
								}

								// Toggle whole class name
							} else if (type === core_strundefined || type === "boolean") {
								if (this.className) {
									// store className if set
									jQuery._data(this, "__className__", this.className);
								}

								// If the element has a class name or if we're passed "false",
								// then remove the whole classname (if there was one, the above saved it).
								// Otherwise bring back whatever was previously saved (if anything),
								// falling back to the empty string if nothing was stored.
								this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
							}
						});
					},

					hasClass : function(selector) {
						var className = " " + selector + " ",
						    i = 0,
						    l = this.length;
						for (; i < l; i++) {
							if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
								return true;
							}
						}

						return false;
					},

					val : function(value) {
						var ret,
						    hooks,
						    isFunction,
						    elem = this[0];

						if (!arguments.length) {
							if (elem) {
								hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[ elem.nodeName.toLowerCase()];

								if (hooks && "get" in hooks && ( ret = hooks.get(elem, "value")) !== undefined) {
									return ret;
								}

								ret = elem.value;

								return typeof ret === "string" ?
								// handle most common string cases
								ret.replace(rreturn, "") :
								// handle cases where value is null/undef or number
								ret == null ? "" : ret;
							}

							return;
						}

						isFunction = jQuery.isFunction(value);

						return this.each(function(i) {
							var val,
							    self = jQuery(this);

							if (this.nodeType !== 1) {
								return;
							}

							if (isFunction) {
								val = value.call(this, i, self.val());
							} else {
								val = value;
							}

							// Treat null/undefined as ""; convert numbers to string
							if (val == null) {
								val = "";
							} else if ( typeof val === "number") {
								val += "";
							} else if (jQuery.isArray(val)) {
								val = jQuery.map(val, function(value) {
									return value == null ? "" : value + "";
								});
							}

							hooks = jQuery.valHooks[this.type] || jQuery.valHooks[ this.nodeName.toLowerCase()];

							// If set returns undefined, fall back to normal setting
							if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
								this.value = val;
							}
						});
					}
				});

				jQuery.extend({
					valHooks : {
						option : {
							get : function(elem) {
								// attributes.value is undefined in Blackberry 4.7 but
								// uses .value. See #6932
								var val = elem.attributes.value;
								return !val || val.specified ? elem.value : elem.text;
							}
						},
						select : {
							get : function(elem) {
								var value,
								    option,
								    options = elem.options,
								    index = elem.selectedIndex,
								    one = elem.type === "select-one" || index < 0,
								    values = one ? null : [],
								    max = one ? index + 1 : options.length,
								    i = index < 0 ? max : one ? index : 0;

								// Loop through all the selected options
								for (; i < max; i++) {
									option = options[i];

									// oldIE doesn't update selected after form reset (#2551)
									if ((option.selected || i === index ) &&
									// Don't return options that are disabled or in a disabled optgroup
									(jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup") )) {

										// Get the specific value for the option
										value = jQuery(option).val();

										// We don't need an array for one selects
										if (one) {
											return value;
										}

										// Multi-Selects return an array
										values.push(value);
									}
								}

								return values;
							},

							set : function(elem, value) {
								var values = jQuery.makeArray(value);

								jQuery(elem).find("option").each(function() {
									this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
								});

								if (!values.length) {
									elem.selectedIndex = -1;
								}
								return values;
							}
						}
					},

					attr : function(elem, name, value) {
						var hooks,
						    notxml,
						    ret,
						    nType = elem.nodeType;

						// don't get/set attributes on text, comment and attribute nodes
						if (!elem || nType === 3 || nType === 8 || nType === 2) {
							return;
						}

						// Fallback to prop when attributes are not supported
						if ( typeof elem.getAttribute === core_strundefined) {
							return jQuery.prop(elem, name, value);
						}

						notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

						// All attributes are lowercase
						// Grab necessary hook if one is defined
						if (notxml) {
							name = name.toLowerCase();
							hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook );
						}

						if (value !== undefined) {

							if (value === null) {
								jQuery.removeAttr(elem, name);

							} else if (hooks && notxml && "set" in hooks && ( ret = hooks.set(elem, value, name)) !== undefined) {
								return ret;

							} else {
								elem.setAttribute(name, value + "");
								return value;
							}

						} else if (hooks && notxml && "get" in hooks && ( ret = hooks.get(elem, name)) !== null) {
							return ret;

						} else {

							// In IE9+, Flash objects don't have .getAttribute (#12945)
							// Support: IE9+
							if ( typeof elem.getAttribute !== core_strundefined) {
								ret = elem.getAttribute(name);
							}

							// Non-existent attributes return null, we normalize to undefined
							return ret == null ? undefined : ret;
						}
					},

					removeAttr : function(elem, value) {
						var name,
						    propName,
						    i = 0,
						    attrNames = value && value.match(core_rnotwhite);

						if (attrNames && elem.nodeType === 1) {
							while (( name = attrNames[i++])) {
								propName = jQuery.propFix[name] || name;

								// Boolean attributes get special treatment (#10870)
								if (rboolean.test(name)) {
									// Set corresponding property to false for boolean attributes
									// Also clear defaultChecked/defaultSelected (if appropriate) for IE<8
									if (!getSetAttribute && ruseDefault.test(name)) {
										elem[ jQuery.camelCase("default-" + name)] = elem[propName] = false;
									} else {
										elem[propName] = false;
									}

									// See #9699 for explanation of this approach (setting first, then removal)
								} else {
									jQuery.attr(elem, name, "");
								}

								elem.removeAttribute( getSetAttribute ? name : propName);
							}
						}
					},

					attrHooks : {
						type : {
							set : function(elem, value) {
								if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
									// Setting the type on a radio button after the value resets the value in IE6-9
									// Reset value to default in case type is set after value during creation
									var val = elem.value;
									elem.setAttribute("type", value);
									if (val) {
										elem.value = val;
									}
									return value;
								}
							}
						}
					},

					propFix : {
						tabindex : "tabIndex",
						readonly : "readOnly",
						"for" : "htmlFor",
						"class" : "className",
						maxlength : "maxLength",
						cellspacing : "cellSpacing",
						cellpadding : "cellPadding",
						rowspan : "rowSpan",
						colspan : "colSpan",
						usemap : "useMap",
						frameborder : "frameBorder",
						contenteditable : "contentEditable"
					},

					prop : function(elem, name, value) {
						var ret,
						    hooks,
						    notxml,
						    nType = elem.nodeType;

						// don't get/set properties on text, comment and attribute nodes
						if (!elem || nType === 3 || nType === 8 || nType === 2) {
							return;
						}

						notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

						if (notxml) {
							// Fix name and attach hooks
							name = jQuery.propFix[name] || name;
							hooks = jQuery.propHooks[name];
						}

						if (value !== undefined) {
							if (hooks && "set" in hooks && ( ret = hooks.set(elem, value, name)) !== undefined) {
								return ret;

							} else {
								return (elem[name] = value );
							}

						} else {
							if (hooks && "get" in hooks && ( ret = hooks.get(elem, name)) !== null) {
								return ret;

							} else {
								return elem[name];
							}
						}
					},

					propHooks : {
						tabIndex : {
							get : function(elem) {
								// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
								// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
								var attributeNode = elem.getAttributeNode("tabindex");

								return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : undefined;
							}
						}
					}
				});

				// Hook for boolean attributes
				boolHook = {
					get : function(elem, name) {
						var
						// Use .prop to determine if this attribute is understood as boolean
						prop = jQuery.prop(elem, name),

						// Fetch it accordingly
						    attr = typeof prop === "boolean" && elem.getAttribute(name),
						    detail = typeof prop === "boolean" ? getSetInput && getSetAttribute ? attr != null :
						// oldIE fabricates an empty string for missing boolean attributes
						// and conflates checked/selected into attroperties
						ruseDefault.test(name) ? elem[ jQuery.camelCase("default-" + name)] : !!attr :

						// fetch an attribute node for properties not recognized as boolean
						elem.getAttributeNode(name);

						return detail && detail.value !== false ? name.toLowerCase() : undefined;
					},
					set : function(elem, value, name) {
						if (value === false) {
							// Remove boolean attributes when set to false
							jQuery.removeAttr(elem, name);
						} else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
							// IE<8 needs the *property* name
							elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);

							// Use defaultChecked and defaultSelected for oldIE
						} else {
							elem[ jQuery.camelCase("default-" + name)] = elem[name] = true;
						}

						return name;
					}
				};

				// fix oldIE value attroperty
				if (!getSetInput || !getSetAttribute) {
					jQuery.attrHooks.value = {
						get : function(elem, name) {
							var ret = elem.getAttributeNode(name);
							return jQuery.nodeName(elem, "input") ?

							// Ignore the value *property* by using defaultValue
							elem.defaultValue : ret && ret.specified ? ret.value : undefined;
						},
						set : function(elem, value, name) {
							if (jQuery.nodeName(elem, "input")) {
								// Does not return so that setAttribute is also used
								elem.defaultValue = value;
							} else {
								// Use nodeHook if defined (#1954); otherwise setAttribute is fine
								return nodeHook && nodeHook.set(elem, value, name);
							}
						}
					};
				}

				// IE6/7 do not support getting/setting some attributes with get/setAttribute
				if (!getSetAttribute) {

					// Use this for any attribute in IE6/7
					// This fixes almost every IE6/7 issue
					nodeHook = jQuery.valHooks.button = {
						get : function(elem, name) {
							var ret = elem.getAttributeNode(name);
							return ret && (name === "id" || name === "name" || name === "coords" ? ret.value !== "" : ret.specified ) ? ret.value : undefined;
						},
						set : function(elem, value, name) {
							// Set the existing or create a new attribute node
							var ret = elem.getAttributeNode(name);
							if (!ret) {
								elem.setAttributeNode(( ret = elem.ownerDocument.createAttribute(name)));
							}

							ret.value = value += "";

							// Break association with cloned elements by also using setAttribute (#9646)
							return name === "value" || value === elem.getAttribute(name) ? value : undefined;
						}
					};

					// Set contenteditable to false on removals(#10429)
					// Setting to empty string throws an error as an invalid value
					jQuery.attrHooks.contenteditable = {
						get : nodeHook.get,
						set : function(elem, value, name) {
							nodeHook.set(elem, value === "" ? false : value, name);
						}
					};

					// Set width and height to auto instead of 0 on empty string( Bug #8150 )
					// This is for removals
					jQuery.each(["width", "height"], function(i, name) {
						jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
							set : function(elem, value) {
								if (value === "") {
									elem.setAttribute(name, "auto");
									return value;
								}
							}
						});
					});
				}

				// Some attributes require a special call on IE
				// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
				if (!jQuery.support.hrefNormalized) {
					jQuery.each(["href", "src", "width", "height"], function(i, name) {
						jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
							get : function(elem) {
								var ret = elem.getAttribute(name, 2);
								return ret == null ? undefined : ret;
							}
						});
					});

					// href/src property should get the full normalized URL (#10299/#12915)
					jQuery.each(["href", "src"], function(i, name) {
						jQuery.propHooks[name] = {
							get : function(elem) {
								return elem.getAttribute(name, 4);
							}
						};
					});
				}

				if (!jQuery.support.style) {
					jQuery.attrHooks.style = {
						get : function(elem) {
							// Return undefined in the case of empty string
							// Note: IE uppercases css property names, but if we were to .toLowerCase()
							// .cssText, that would destroy case senstitivity in URL's, like in "background"
							return elem.style.cssText || undefined;
						},
						set : function(elem, value) {
							return (elem.style.cssText = value + "" );
						}
					};
				}

				// Safari mis-reports the default selected property of an option
				// Accessing the parent's selectedIndex property fixes it
				if (!jQuery.support.optSelected) {
					jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
						get : function(elem) {
							var parent = elem.parentNode;

							if (parent) {
								parent.selectedIndex

								// Make sure that it also works with optgroups, see #5701
								if (parent.parentNode) {
									parent.parentNode.selectedIndex
								}
							}
							return null;
						}
					});
				}

				// IE6/7 call enctype encoding
				if (!jQuery.support.enctype) {
					jQuery.propFix.enctype = "encoding";
				}

				// Radios and checkboxes getter/setter
				if (!jQuery.support.checkOn) {
					jQuery.each(["radio", "checkbox"], function() {
						jQuery.valHooks[this] = {
							get : function(elem) {
								// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
								return elem.getAttribute("value") === null ? "on" : elem.value;
							}
						};
					});
				}
				jQuery.each(["radio", "checkbox"], function() {
					jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
						set : function(elem, value) {
							if (jQuery.isArray(value)) {
								return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 );
							}
						}
					});
				});
				var rformElems = /^(?:input|select|textarea)$/i,
				    rkeyEvent = /^key/,
				    rmouseEvent = /^(?:mouse|contextmenu)|click/,
				    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
				    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

				function returnTrue() {
					return true;
				}

				function returnFalse() {
					return false;
				}

				/*
				 * Helper functions for managing events -- not part of the public interface.
				 * Props to Dean Edwards' addEvent library for many of the ideas.
				 */
				jQuery.event = {

					global : {},

					add : function(elem, types, handler, data, selector) {
						var tmp,
						    events,
						    t,
						    handleObjIn,
						    special,
						    eventHandle,
						    handleObj,
						    handlers,
						    type,
						    namespaces,
						    origType,
						    elemData = jQuery._data(elem);

						// Don't attach events to noData or text/comment nodes (but allow plain objects)
						if (!elemData) {
							return;
						}

						// Caller can pass in an object of custom data in lieu of the handler
						if (handler.handler) {
							handleObjIn = handler;
							handler = handleObjIn.handler;
							selector = handleObjIn.selector;
						}

						// Make sure that the handler has a unique ID, used to find/remove it later
						if (!handler.guid) {
							handler.guid = jQuery.guid++;
						}

						// Init the element's event structure and main handler, if this is the first
						if (!( events = elemData.events)) {
							events = elemData.events = {};
						}
						if (!( eventHandle = elemData.handle)) {
							eventHandle = elemData.handle = function(e) {
								// Discard the second event of a jQuery.event.trigger() and
								// when an event is called after a page has unloaded
								return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
							};
							// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
							eventHandle.elem = elem;
						}

						// Handle multiple events separated by a space
						// jQuery(...).bind("mouseover mouseout", fn);
						types = (types || "" ).match(core_rnotwhite) || [""];
						t = types.length;
						while (t--) {
							tmp = rtypenamespace.exec(types[t]) || [];
							type = origType = tmp[1];
							namespaces = (tmp[2] || "" ).split(".").sort();

							// If event changes its type, use the special event handlers for the changed type
							special = jQuery.event.special[type] || {};

							// If selector defined, determine special event api type, otherwise given type
							type = ( selector ? special.delegateType : special.bindType ) || type;

							// Update special based on newly reset type
							special = jQuery.event.special[type] || {};

							// handleObj is passed to all event handlers
							handleObj = jQuery.extend({
								type : type,
								origType : origType,
								data : data,
								handler : handler,
								guid : handler.guid,
								selector : selector,
								needsContext : selector && jQuery.expr.match.needsContext.test(selector),
								namespace : namespaces.join(".")
							}, handleObjIn);

							// Init the event handler queue if we're the first
							if (!( handlers = events[type])) {
								handlers = events[type] = [];
								handlers.delegateCount = 0;

								// Only use addEventListener/attachEvent if the special events handler returns false
								if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
									// Bind the global event handler to the element
									if (elem.addEventListener) {
										elem.addEventListener(type, eventHandle, false);

									} else if (elem.attachEvent) {
										elem.attachEvent("on" + type, eventHandle);
									}
								}
							}

							if (special.add) {
								special.add.call(elem, handleObj);

								if (!handleObj.handler.guid) {
									handleObj.handler.guid = handler.guid;
								}
							}

							// Add to the element's handler list, delegates in front
							if (selector) {
								handlers.splice(handlers.delegateCount++, 0, handleObj);
							} else {
								handlers.push(handleObj);
							}

							// Keep track of which events have ever been used, for event optimization
							jQuery.event.global[type] = true;
						}

						// Nullify elem to prevent memory leaks in IE
						elem = null;
					},

					// Detach an event or set of events from an element
					remove : function(elem, types, handler, selector, mappedTypes) {
						var j,
						    handleObj,
						    tmp,
						    origCount,
						    t,
						    events,
						    special,
						    handlers,
						    type,
						    namespaces,
						    origType,
						    elemData = jQuery.hasData(elem) && jQuery._data(elem);

						if (!elemData || !( events = elemData.events)) {
							return;
						}

						// Once for each type.namespace in types; type may be omitted
						types = (types || "" ).match(core_rnotwhite) || [""];
						t = types.length;
						while (t--) {
							tmp = rtypenamespace.exec(types[t]) || [];
							type = origType = tmp[1];
							namespaces = (tmp[2] || "" ).split(".").sort();

							// Unbind all events (on this namespace, if provided) for the element
							if (!type) {
								for (type in events ) {
									jQuery.event.remove(elem, type + types[t], handler, selector, true);
								}
								continue;
							}

							special = jQuery.event.special[type] || {};
							type = ( selector ? special.delegateType : special.bindType ) || type;
							handlers = events[type] || [];
							tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

							// Remove matching events
							origCount = j = handlers.length;
							while (j--) {
								handleObj = handlers[j];

								if ((mappedTypes || origType === handleObj.origType ) && (!handler || handler.guid === handleObj.guid ) && (!tmp || tmp.test(handleObj.namespace) ) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector )) {
									handlers.splice(j, 1);

									if (handleObj.selector) {
										handlers.delegateCount--;
									}
									if (special.remove) {
										special.remove.call(elem, handleObj);
									}
								}
							}

							// Remove generic event handler if we removed something and no more handlers exist
							// (avoids potential for endless recursion during removal of special event handlers)
							if (origCount && !handlers.length) {
								if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
									jQuery.removeEvent(elem, type, elemData.handle);
								}
								delete events[type];
							}
						}

						// Remove the expando if it's no longer used
						if (jQuery.isEmptyObject(events)) {
							delete elemData.handle;

							// removeData also checks for emptiness and clears the expando if empty
							// so use it instead of delete
							jQuery._removeData(elem, "events");
						}
					},

					trigger : function(event, data, elem, onlyHandlers) {
						var handle,
						    ontype,
						    cur,
						    bubbleType,
						    special,
						    tmp,
						    i,
						    eventPath = [elem || document],
						    type = core_hasOwn.call(event, "type") ? event.type : event,
						    namespaces = core_hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

						cur = tmp = elem = elem || document;

						// Don't do events on text and comment nodes
						if (elem.nodeType === 3 || elem.nodeType === 8) {
							return;
						}

						// focus/blur morphs to focusin/out; ensure we're not firing them right now
						if (rfocusMorph.test(type + jQuery.event.triggered)) {
							return;
						}

						if (type.indexOf(".") >= 0) {
							// Namespaced trigger; create a regexp to match event type in handle()
							namespaces = type.split(".");
							type = namespaces.shift();
							namespaces.sort();
						}
						ontype = type.indexOf(":") < 0 && "on" + type;

						// Caller can pass in a jQuery.Event object, Object, or just an event type string
						event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);

						event.isTrigger = true;
						event.namespace = namespaces.join(".");
						event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

						// Clean up the event in case it is being reused
						event.result = undefined;
						if (!event.target) {
							event.target = elem;
						}

						// Clone any incoming data and prepend the event, creating the handler arg list
						data = data == null ? [event] : jQuery.makeArray(data, [event]);

						// Allow special events to draw outside the lines
						special = jQuery.event.special[type] || {};
						if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
							return;
						}

						// Determine event propagation path in advance, per W3C events spec (#9951)
						// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
						if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

							bubbleType = special.delegateType || type;
							if (!rfocusMorph.test(bubbleType + type)) {
								cur = cur.parentNode;
							}
							for (; cur; cur = cur.parentNode) {
								eventPath.push(cur);
								tmp = cur;
							}

							// Only add window if we got to document (e.g., not plain obj or detached DOM)
							if (tmp === (elem.ownerDocument || document)) {
								eventPath.push(tmp.defaultView || tmp.parentWindow || window);
							}
						}

						// Fire handlers on the event path
						i = 0;
						while (( cur = eventPath[i++]) && !event.isPropagationStopped()) {

							event.type = i > 1 ? bubbleType : special.bindType || type;

							// jQuery handler
							handle = ( jQuery._data( cur, "events" ) || {} )[event.type] && jQuery._data(cur, "handle");
							if (handle) {
								handle.apply(cur, data);
							}

							// Native handler
							handle = ontype && cur[ontype];
							if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
								event.preventDefault();
							}
						}
						event.type = type;

						// If nobody prevented the default action, do it now
						if (!onlyHandlers && !event.isDefaultPrevented()) {

							if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) && !(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

								// Call a native DOM method on the target with the same name name as the event.
								// Can't use an .isFunction() check here because IE6/7 fails that test.
								// Don't do default actions on window, that's where global variables be (#6170)
								if (ontype && elem[type] && !jQuery.isWindow(elem)) {

									// Don't re-trigger an onFOO event when we call its FOO() method
									tmp = elem[ontype];

									if (tmp) {
										elem[ontype] = null;
									}

									// Prevent re-triggering of the same event, since we already bubbled it above
									jQuery.event.triggered = type;
									try {
										elem[ type ]();
									} catch ( e ) {
										// IE<9 dies on focus/blur to hidden element (#1486,#12518)
										// only reproducible on winXP IE8 native, not IE9 in IE8 mode
									}
									jQuery.event.triggered = undefined;

									if (tmp) {
										elem[ontype] = tmp;
									}
								}
							}
						}

						return event.result;
					},

					dispatch : function(event) {

						// Make a writable jQuery.Event from the native event object
						event = jQuery.event.fix(event);

						var i,
						    ret,
						    handleObj,
						    matched,
						    j,
						    handlerQueue = [],
						    args = core_slice.call(arguments),
						    handlers = ( jQuery._data( this, "events" ) || {} )[event.type] || [],
						    special = jQuery.event.special[event.type] || {};

						// Use the fix-ed jQuery.Event rather than the (read-only) native event
						args[0] = event;
						event.delegateTarget = this;

						// Call the preDispatch hook for the mapped type, and let it bail if desired
						if (special.preDispatch && special.preDispatch.call(this, event) === false) {
							return;
						}

						// Determine handlers
						handlerQueue = jQuery.event.handlers.call(this, event, handlers);

						// Run delegates first; they may want to stop propagation beneath us
						i = 0;
						while (( matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
							event.currentTarget = matched.elem;

							j = 0;
							while (( handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

								// Triggered event must either 1) have no namespace, or
								// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
								if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {

									event.handleObj = handleObj;
									event.data = handleObj.data;

									ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler ).apply(matched.elem, args);

									if (ret !== undefined) {
										if ((event.result = ret) === false) {
											event.preventDefault();
											event.stopPropagation();
										}
									}
								}
							}
						}

						// Call the postDispatch hook for the mapped type
						if (special.postDispatch) {
							special.postDispatch.call(this, event);
						}

						return event.result;
					},

					handlers : function(event, handlers) {
						var sel,
						    handleObj,
						    matches,
						    i,
						    handlerQueue = [],
						    delegateCount = handlers.delegateCount,
						    cur = event.target;

						// Find delegate handlers
						// Black-hole SVG <use> instance trees (#13180)
						// Avoid non-left-click bubbling in Firefox (#3861)
						if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {

							for (; cur != this; cur = cur.parentNode || this) {

								// Don't check non-elements (#13208)
								// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
								if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
									matches = [];
									for ( i = 0; i < delegateCount; i++) {
										handleObj = handlers[i];

										// Don't conflict with Object.prototype properties (#13203)
										sel = handleObj.selector + " ";

										if (matches[sel] === undefined) {
											matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
										}
										if (matches[sel]) {
											matches.push(handleObj);
										}
									}
									if (matches.length) {
										handlerQueue.push({
											elem : cur,
											handlers : matches
										});
									}
								}
							}
						}

						// Add the remaining (directly-bound) handlers
						if (delegateCount < handlers.length) {
							handlerQueue.push({
								elem : this,
								handlers : handlers.slice(delegateCount)
							});
						}

						return handlerQueue;
					},

					fix : function(event) {
						if (event[jQuery.expando]) {
							return event;
						}

						// Create a writable copy of the event object and normalize some properties
						var i,
						    prop,
						    copy,
						    type = event.type,
						    originalEvent =
						    event,
						    fixHook = this.fixHooks[type];

						if (!fixHook) {
							this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
						}
						copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

						event = new jQuery.Event(originalEvent);

						i = copy.length;
						while (i--) {
							prop = copy[i];
							event[prop] = originalEvent[prop];
						}

						// Support: IE<9
						// Fix target property (#1925)
						if (!event.target) {
							event.target = originalEvent.srcElement || document;
						}

						// Support: Chrome 23+, Safari?
						// Target should not be a text node (#504, #13143)
						if (event.target.nodeType === 3) {
							event.target = event.target.parentNode;
						}

						// Support: IE<9
						// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
						event.metaKey = !!event.metaKey;

						return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
					},

					// Includes some event props shared by KeyEvent and MouseEvent
					props : "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

					fixHooks : {},

					keyHooks : {
						props : "char charCode key keyCode".split(" "),
						filter : function(event, original) {

							// Add which for key events
							if (event.which == null) {
								event.which = original.charCode != null ? original.charCode : original.keyCode;
							}

							return event;
						}
					},

					mouseHooks : {
						props : "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
						filter : function(event, original) {
							var body,
							    eventDoc,
							    doc,
							    button = original.button,
							    fromElement = original.fromElement;

							// Calculate pageX/Y if missing and clientX/Y available
							if (event.pageX == null && original.clientX != null) {
								eventDoc = event.target.ownerDocument || document;
								doc = eventDoc.documentElement;
								body = eventDoc.body;

								event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - (doc && doc.clientLeft || body && body.clientLeft || 0 );
								event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0 ) - (doc && doc.clientTop || body && body.clientTop || 0 );
							}

							// Add relatedTarget, if necessary
							if (!event.relatedTarget && fromElement) {
								event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
							}

							// Add which for click: 1 === left; 2 === middle; 3 === right
							// Note: button is not normalized, so don't use it
							if (!event.which && button !== undefined) {
								event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0 ) ) );
							}

							return event;
						}
					},

					special : {
						load : {
							// Prevent triggered image.load events from bubbling to window.load
							noBubble : true
						},
						click : {
							// For checkbox, fire native event so checked state will be right
							trigger : function() {
								if (jQuery.nodeName(this, "input") && this.type === "checkbox" && this.click) {
									this.click();
									return false;
								}
							}
						},
						focus : {
							// Fire native event if possible so blur/focus sequence is correct
							trigger : function() {
								if (this !== document.activeElement && this.focus) {
									try {
										this.focus();
										return false;
									} catch ( e ) {
										// Support: IE<9
										// If we error on focus to hidden element (#1486, #12518),
										// let .trigger() run the handlers
									}
								}
							},
							delegateType : "focusin"
						},
						blur : {
							trigger : function() {
								if (this === document.activeElement && this.blur) {
									this.blur();
									return false;
								}
							},
							delegateType : "focusout"
						},

						beforeunload : {
							postDispatch : function(event) {

								// Even when returnValue equals to undefined Firefox will still show alert
								if (event.result !== undefined) {
									event.originalEvent.returnValue = event.result;
								}
							}
						}
					},

					simulate : function(type, elem, event, bubble) {
						// Piggyback on a donor event to simulate a different one.
						// Fake originalEvent to avoid donor's stopPropagation, but if the
						// simulated event prevents default then we do the same on the donor.
						var e = jQuery.extend(new jQuery.Event(), event, {
							type : type,
							isSimulated : true,
							originalEvent : {}
						});
						if (bubble) {
							jQuery.event.trigger(e, null, elem);
						} else {
							jQuery.event.dispatch.call(elem, e);
						}
						if (e.isDefaultPrevented()) {
							event.preventDefault();
						}
					}
				};

				jQuery.removeEvent = document.removeEventListener ? function(elem, type, handle) {
					if (elem.removeEventListener) {
						elem.removeEventListener(type, handle, false);
					}
				} : function(elem, type, handle) {
					var name = "on" + type;

					if (elem.detachEvent) {

						// #8545, #7054, preventing memory leaks for custom events in IE6-8
						// detachEvent needed property on element, by name of that event, to properly expose it to GC
						if ( typeof elem[name] === core_strundefined) {
							elem[name] = null;
						}

						elem.detachEvent(name, handle);
					}
				};

				jQuery.Event = function(src, props) {
					// Allow instantiation without the 'new' keyword
					if (!(this instanceof jQuery.Event)) {
						return new jQuery.Event(src, props);
					}

					// Event object
					if (src && src.type) {
						this.originalEvent = src;
						this.type = src.type;

						// Events bubbling up the document may have been marked as prevented
						// by a handler lower down the tree; reflect the correct value.
						this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

						// Event type
					} else {
						this.type = src;
					}

					// Put explicitly provided properties onto the event object
					if (props) {
						jQuery.extend(this, props);
					}

					// Create a timestamp if incoming event doesn't have one
					this.timeStamp = src && src.timeStamp || jQuery.now();

					// Mark it as fixed
					this[jQuery.expando] = true;
				};

				// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
				// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
				jQuery.Event.prototype = {
					isDefaultPrevented : returnFalse,
					isPropagationStopped : returnFalse,
					isImmediatePropagationStopped : returnFalse,

					preventDefault : function() {
						var e = this.originalEvent;

						this.isDefaultPrevented = returnTrue;
						if (!e) {
							return;
						}

						// If preventDefault exists, run it on the original event
						if (e.preventDefault) {
							e.preventDefault();

							// Support: IE
							// Otherwise set the returnValue property of the original event to false
						} else {
							e.returnValue = false;
						}
					},
					stopPropagation : function() {
						var e = this.originalEvent;

						this.isPropagationStopped = returnTrue;
						if (!e) {
							return;
						}
						// If stopPropagation exists, run it on the original event
						if (e.stopPropagation) {
							e.stopPropagation();
						}

						// Support: IE
						// Set the cancelBubble property of the original event to true
						e.cancelBubble = true;
					},
					stopImmediatePropagation : function() {
						this.isImmediatePropagationStopped = returnTrue;
						this.stopPropagation();
					}
				};

				// Create mouseenter/leave events using mouseover/out and event-time checks
				jQuery.each({
					mouseenter : "mouseover",
					mouseleave : "mouseout"
				}, function(orig, fix) {
					jQuery.event.special[orig] = {
						delegateType : fix,
						bindType : fix,

						handle : function(event) {
							var ret,
							    target = this,
							    related = event.relatedTarget,
							    handleObj = event.handleObj;

							// For mousenter/leave call the handler if related is outside the target.
							// NB: No relatedTarget if the mouse left/entered the browser window
							if (!related || (related !== target && !jQuery.contains(target, related))) {
								event.type = handleObj.origType;
								ret = handleObj.handler.apply(this, arguments);
								event.type = fix;
							}
							return ret;
						}
					};
				});

				// IE submit delegation
				if (!jQuery.support.submitBubbles) {

					jQuery.event.special.submit = {
						setup : function() {
							// Only need this for delegated form submit events
							if (jQuery.nodeName(this, "form")) {
								return false;
							}

							// Lazy-add a submit handler when a descendant form may potentially be submitted
							jQuery.event.add(this, "click._submit keypress._submit", function(e) {
								// Node name check avoids a VML-related crash in IE (#9807)
								var elem = e.target,
								    form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;
								if (form && !jQuery._data(form, "submitBubbles")) {
									jQuery.event.add(form, "submit._submit", function(event) {
										event._submit_bubble = true;
									});
									jQuery._data(form, "submitBubbles", true);
								}
							});
							// return undefined since we don't need an event listener
						},

						postDispatch : function(event) {
							// If form was submitted by the user, bubble the event up the tree
							if (event._submit_bubble) {
								delete event._submit_bubble;
								if (this.parentNode && !event.isTrigger) {
									jQuery.event.simulate("submit", this.parentNode, event, true);
								}
							}
						},

						teardown : function() {
							// Only need this for delegated form submit events
							if (jQuery.nodeName(this, "form")) {
								return false;
							}

							// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
							jQuery.event.remove(this, "._submit");
						}
					};
				}

				// IE change delegation and checkbox/radio fix
				if (!jQuery.support.changeBubbles) {

					jQuery.event.special.change = {

						setup : function() {

							if (rformElems.test(this.nodeName)) {
								// IE doesn't fire change on a check/radio until blur; trigger it on click
								// after a propertychange. Eat the blur-change in special.change.handle.
								// This still fires onchange a second time for check/radio after blur.
								if (this.type === "checkbox" || this.type === "radio") {
									jQuery.event.add(this, "propertychange._change", function(event) {
										if (event.originalEvent.propertyName === "checked") {
											this._just_changed = true;
										}
									});
									jQuery.event.add(this, "click._change", function(event) {
										if (this._just_changed && !event.isTrigger) {
											this._just_changed = false;
										}
										// Allow triggered, simulated change events (#11500)
										jQuery.event.simulate("change", this, event, true);
									});
								}
								return false;
							}
							// Delegated event; lazy-add a change handler on descendant inputs
							jQuery.event.add(this, "beforeactivate._change", function(e) {
								var elem = e.target;

								if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "changeBubbles")) {
									jQuery.event.add(elem, "change._change", function(event) {
										if (this.parentNode && !event.isSimulated && !event.isTrigger) {
											jQuery.event.simulate("change", this.parentNode, event, true);
										}
									});
									jQuery._data(elem, "changeBubbles", true);
								}
							});
						},

						handle : function(event) {
							var elem = event.target;

							// Swallow native change events from checkbox/radio, we already triggered them above
							if (this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox")) {
								return event.handleObj.handler.apply(this, arguments);
							}
						},

						teardown : function() {
							jQuery.event.remove(this, "._change");

							return !rformElems.test(this.nodeName);
						}
					};
				}

				// Create "bubbling" focus and blur events
				if (!jQuery.support.focusinBubbles) {
					jQuery.each({
						focus : "focusin",
						blur : "focusout"
					}, function(orig, fix) {

						// Attach a single capturing handler while someone wants focusin/focusout
						var attaches = 0,
						    handler = function(event) {
							jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
						};

						jQuery.event.special[fix] = {
							setup : function() {
								if (attaches++ === 0) {
									document.addEventListener(orig, handler, true);
								}
							},
							teardown : function() {
								if (--attaches === 0) {
									document.removeEventListener(orig, handler, true);
								}
							}
						};
					});
				}

				jQuery.fn.extend({

					on : function(types, selector, data, fn, /*INTERNAL*/one) {
						var type,
						    origFn;

						// Types can be a map of types/handlers
						if ( typeof types === "object") {
							// ( types-Object, selector, data )
							if ( typeof selector !== "string") {
								// ( types-Object, data )
								data = data || selector;
								selector = undefined;
							}
							for (type in types ) {
								this.on(type, selector, data, types[type], one);
							}
							return this;
						}

						if (data == null && fn == null) {
							// ( types, fn )
							fn = selector;
							data = selector = undefined;
						} else if (fn == null) {
							if ( typeof selector === "string") {
								// ( types, selector, fn )
								fn = data;
								data = undefined;
							} else {
								// ( types, data, fn )
								fn = data;
								data = selector;
								selector = undefined;
							}
						}
						if (fn === false) {
							fn = returnFalse;
						} else if (!fn) {
							return this;
						}

						if (one === 1) {
							origFn = fn;
							fn = function(event) {
								// Can use an empty set, since event contains the info
								jQuery().off(event);
								return origFn.apply(this, arguments);
							};
							// Use same guid so caller can remove using origFn
							fn.guid = origFn.guid || (origFn.guid = jQuery.guid++ );
						}
						return this.each(function() {
							jQuery.event.add(this, types, fn, data, selector);
						});
					},
					one : function(types, selector, data, fn) {
						return this.on(types, selector, data, fn, 1);
					},
					off : function(types, selector, fn) {
						var handleObj,
						    type;
						if (types && types.preventDefault && types.handleObj) {
							// ( event )  dispatched jQuery.Event
							handleObj = types.handleObj;
							jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
							return this;
						}
						if ( typeof types === "object") {
							// ( types-object [, selector] )
							for (type in types ) {
								this.off(type, selector, types[type]);
							}
							return this;
						}
						if (selector === false || typeof selector === "function") {
							// ( types [, fn] )
							fn = selector;
							selector = undefined;
						}
						if (fn === false) {
							fn = returnFalse;
						}
						return this.each(function() {
							jQuery.event.remove(this, types, fn, selector);
						});
					},

					bind : function(types, data, fn) {
						return this.on(types, null, data, fn);
					},
					unbind : function(types, fn) {
						return this.off(types, null, fn);
					},

					delegate : function(selector, types, data, fn) {
						return this.on(types, selector, data, fn);
					},
					undelegate : function(selector, types, fn) {
						// ( namespace ) or ( selector, types [, fn] )
						return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
					},

					trigger : function(type, data) {
						return this.each(function() {
							jQuery.event.trigger(type, data, this);
						});
					},
					triggerHandler : function(type, data) {
						var elem = this[0];
						if (elem) {
							return jQuery.event.trigger(type, data, elem, true);
						}
					}
				});
				/*!
				 * Sizzle CSS Selector Engine
				 * Copyright 2012 jQuery Foundation and other contributors
				 * Released under the MIT license
				 * http://sizzlejs.com/
				 */
				(function(window, undefined) {

					var i,
					    cachedruns,
					    Expr,
					    getText,
					    isXML,
					    compile,
					    hasDuplicate,
					    outermostContext,

					// Local document vars
					    setDocument,
					    document,
					    docElem,
					    documentIsXML,
					    rbuggyQSA,
					    rbuggyMatches,
					    matches,
					    contains,
					    sortOrder,

					// Instance-specific data
					    expando = "sizzle" + -(new Date()),
					    preferredDoc = window.document,
					    support = {},
					    dirruns = 0,
					    done = 0,
					    classCache = createCache(),
					    tokenCache = createCache(),
					    compilerCache = createCache(),

					// General-purpose constants
					    strundefined = typeof undefined,
					    MAX_NEGATIVE = 1 << 31,

					// Array methods
					    arr = [],
					    pop = arr.pop,
					    push = arr.push,
					    slice = arr.slice,
					// Use a stripped-down indexOf if we can't use a native one
					    indexOf = arr.indexOf ||
					function(elem) {
						var i = 0,
						    len = this.length;
						for (; i < len; i++) {
							if (this[i] === elem) {
								return i;
							}
						}
						return -1;
					},

					// Regular expressions

					// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
					    whitespace = "[\\x20\\t\\r\\n\\f]",
					// http://www.w3.org/TR/css3-syntax/#characters
					    characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

					// Loosely modeled on CSS identifier characters
					// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
					// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
					    identifier = characterEncoding.replace("w", "w#"),

					// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
					    operators = "([*^$|!~]?=)",
					    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

					// Prefer arguments quoted,
					//   then not containing pseudos/brackets,
					//   then attribute selectors/non-parenthetical expressions,
					//   then anything else
					// These preferences are here to reduce the number of selectors
					//   needing tokenize in the PSEUDO preFilter
					    pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace(3, 8) + ")*)|.*)\\)|)",

					// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
					    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

					    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
					    rcombinators = new RegExp("^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*"),
					    rpseudo = new RegExp(pseudos),
					    ridentifier = new RegExp("^" + identifier + "$"),

					    matchExpr = {
						"ID" : new RegExp("^#(" + characterEncoding + ")"),
						"CLASS" : new RegExp("^\\.(" + characterEncoding + ")"),
						"NAME" : new RegExp("^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]"),
						"TAG" : new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
						"ATTR" : new RegExp("^" + attributes),
						"PSEUDO" : new RegExp("^" + pseudos),
						"CHILD" : new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
						// For use in libraries implementing .is()
						// We use this for POS matching in `select`
						"needsContext" : new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
					},

					    rsibling = /[\x20\t\r\n\f]*[+~]/,

					    rnative = /^[^{]+\{\s*\[native code/,

					// Easily-parseable/retrievable ID or TAG or CLASS selectors
					    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

					    rinputs = /^(?:input|select|textarea|button)$/i,
					    rheader = /^h\d$/i,

					    rescape = /'|\\/g,
					    rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

					// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
					    runescape = /\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,
					    funescape = function(_, escaped) {
						var high = "0x" + escaped - 0x10000;
						// NaN means non-codepoint
						return high !== high ? escaped :
						// BMP codepoint
						high < 0 ? String.fromCharCode(high + 0x10000) :
						// Supplemental Plane codepoint (surrogate pair)
						String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
					};

					// Use a stripped-down slice if we can't use a native one
					try {
						slice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType
					} catch ( e ) {
						slice = function(i) {
							var elem,
							    results = [];
							while (( elem = this[i++])) {
								results.push(elem);
							}
							return results;
						};
					}

					/**
					 * For feature detection
					 * @param {Function} fn The function to test for native support
					 */
					function isNative(fn) {
						return rnative.test(fn + "");
					}

					/**
					 * Create key-value caches of limited size
					 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
					 *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
					 *  deleting the oldest entry
					 */
					function createCache() {
						var cache,
						    keys = [];

						return ( cache = function(key, value) {
							// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
							if (keys.push(key += " ") > Expr.cacheLength) {
								// Only keep the most recent entries
								delete cache[ keys.shift()];
							}
							return (cache[key] = value);
						});
					}

					/**
					 * Mark a function for special use by Sizzle
					 * @param {Function} fn The function to mark
					 */
					function markFunction(fn) {
						fn[expando] = true;
						return fn;
					}

					/**
					 * Support testing using an element
					 * @param {Function} fn Passed the created div and expects a boolean result
					 */
					function assert(fn) {
						var div = document.createElement("div");

						try {
							return fn(div);
						} catch (e) {
							return false;
						} finally {
							// release memory in IE
							div = null;
						}
					}

					function Sizzle(selector, context, results, seed) {
						var match,
						    elem,
						    m,
						    nodeType,
						// QSA vars
						    i,
						    groups,
						    old,
						    nid,
						    newContext,
						    newSelector;

						if (( context ? context.ownerDocument || context : preferredDoc ) !== document) {
							setDocument(context);
						}

						context = context || document;
						results = results || [];

						if (!selector || typeof selector !== "string") {
							return results;
						}

						if (( nodeType = context.nodeType) !== 1 && nodeType !== 9) {
							return [];
						}

						if (!documentIsXML && !seed) {

							// Shortcuts
							if (( match = rquickExpr.exec(selector))) {
								// Speed-up: Sizzle("#ID")
								if (( m = match[1])) {
									if (nodeType === 9) {
										elem = context.getElementById(m);
										// Check parentNode to catch when Blackberry 4.6 returns
										// nodes that are no longer in the document #6963
										if (elem && elem.parentNode) {
											// Handle the case where IE, Opera, and Webkit return items
											// by name instead of ID
											if (elem.id === m) {
												results.push(elem);
												return results;
											}
										} else {
											return results;
										}
									} else {
										// Context is not a document
										if (context.ownerDocument && ( elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
											results.push(elem);
											return results;
										}
									}

									// Speed-up: Sizzle("TAG")
								} else if (match[2]) {
									push.apply(results, slice.call(context.getElementsByTagName(selector), 0));
									return results;

									// Speed-up: Sizzle(".CLASS")
								} else if (( m = match[3]) && support.getByClassName && context.getElementsByClassName) {
									push.apply(results, slice.call(context.getElementsByClassName(m), 0));
									return results;
								}
							}

							// QSA path
							if (support.qsa && !rbuggyQSA.test(selector)) {
								old = true;
								nid = expando;
								newContext = context;
								newSelector = nodeType === 9 && selector;

								// qSA works strangely on Element-rooted queries
								// We can work around this by specifying an extra ID on the root
								// and working up from there (Thanks to Andrew Dupont for the technique)
								// IE 8 doesn't work on object elements
								if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
									groups = tokenize(selector);

									if (( old = context.getAttribute("id"))) {
										nid = old.replace(rescape, "\\$&");
									} else {
										context.setAttribute("id", nid);
									}
									nid = "[id='" + nid + "'] ";

									i = groups.length;
									while (i--) {
										groups[i] = nid + toSelector(groups[i]);
									}
									newContext = rsibling.test(selector) && context.parentNode || context;
									newSelector = groups.join(",");
								}

								if (newSelector) {
									try {
										push.apply(results, slice.call(newContext.querySelectorAll(newSelector), 0));
										return results;
									} catch(qsaError) {
									} finally {
										if (!old) {
											context.removeAttribute("id");
										}
									}
								}
							}
						}

						// All others
						return select(selector.replace(rtrim, "$1"), context, results, seed);
					}

					/**
					 * Detect xml
					 * @param {Element|Object} elem An element or a document
					 */
					isXML = Sizzle.isXML = function(elem) {
						// documentElement is verified for cases where it doesn't yet exist
						// (such as loading iframes in IE - #4833)
						var documentElement = elem && (elem.ownerDocument || elem).documentElement;
						return documentElement ? documentElement.nodeName !== "HTML" : false;
					};

					/**
					 * Sets document-related variables once based on the current document
					 * @param {Element|Object} [doc] An element or document object to use to set the document
					 * @returns {Object} Returns the current document
					 */
					setDocument = Sizzle.setDocument = function(node) {
						var doc = node ? node.ownerDocument || node : preferredDoc;

						// If no document and documentElement is available, return
						if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
							return document;
						}

						// Set our document
						document = doc;
						docElem = doc.documentElement;

						// Support tests
						documentIsXML = isXML(doc);

						// Check if getElementsByTagName("*") returns only elements
						support.tagNameNoComments = assert(function(div) {
							div.appendChild(doc.createComment(""));
							return !div.getElementsByTagName("*").length;
						});

						// Check if attributes should be retrieved by attribute nodes
						support.attributes = assert(function(div) {
							div.innerHTML = "<select></select>";
							var type = typeof div.lastChild.getAttribute("multiple");
							// IE8 returns a string for some attributes even when not present
							return type !== "boolean" && type !== "string";
						});

						// Check if getElementsByClassName can be trusted
						support.getByClassName = assert(function(div) {
							// Opera can't find a second classname (in 9.6)
							div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
							if (!div.getElementsByClassName || !div.getElementsByClassName("e").length) {
								return false;
							}

							// Safari 3.2 caches class attributes and doesn't catch changes
							div.lastChild.className = "e";
							return div.getElementsByClassName("e").length === 2;
						});

						// Check if getElementById returns elements by name
						// Check if getElementsByName privileges form controls or returns elements by ID
						support.getByName = assert(function(div) {
							// Inject content
							div.id = expando + 0;
							div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
							docElem.insertBefore(div, docElem.firstChild);

							// Test
							var pass = doc.getElementsByName &&
							// buggy browsers will return fewer than the correct 2
							doc.getElementsByName(expando).length === 2 +
							// buggy browsers will return more than the correct 0
							doc.getElementsByName(expando + 0).length;
							support.getIdNotName = !doc.getElementById(expando);

							// Cleanup
							docElem.removeChild(div);

							return pass;
						});

						// IE6/7 return modified attributes
						Expr.attrHandle = assert(function(div) {
							div.innerHTML = "<a href='#'></a>";
							return div.firstChild && typeof div.firstChild.getAttribute !== strundefined && div.firstChild.getAttribute("href") === "#";
						}) ? {} : {
							"href" : function(elem) {
								return elem.getAttribute("href", 2);
							},
							"type" : function(elem) {
								return elem.getAttribute("type");
							}
						};

						// ID find and filter
						if (support.getIdNotName) {
							Expr.find["ID"] = function(id, context) {
								if ( typeof context.getElementById !== strundefined && !documentIsXML) {
									var m = context.getElementById(id);
									// Check parentNode to catch when Blackberry 4.6 returns
									// nodes that are no longer in the document #6963
									return m && m.parentNode ? [m] : [];
								}
							};
							Expr.filter["ID"] = function(id) {
								var attrId = id.replace(runescape, funescape);
								return function(elem) {
									return elem.getAttribute("id") === attrId;
								};
							};
						} else {
							Expr.find["ID"] = function(id, context) {
								if ( typeof context.getElementById !== strundefined && !documentIsXML) {
									var m = context.getElementById(id);

									return m ? m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ? [m] : undefined : [];
								}
							};
							Expr.filter["ID"] = function(id) {
								var attrId = id.replace(runescape, funescape);
								return function(elem) {
									var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
									return node && node.value === attrId;
								};
							};
						}

						// Tag
						Expr.find["TAG"] = support.tagNameNoComments ? function(tag, context) {
							if ( typeof context.getElementsByTagName !== strundefined) {
								return context.getElementsByTagName(tag);
							}
						} : function(tag, context) {
							var elem,
							    tmp = [],
							    i = 0,
							    results = context.getElementsByTagName(tag);

							// Filter out possible comments
							if (tag === "*") {
								while (( elem = results[i++])) {
									if (elem.nodeType === 1) {
										tmp.push(elem);
									}
								}

								return tmp;
							}
							return results;
						};

						// Name
						Expr.find["NAME"] = support.getByName &&
						function(tag, context) {
							if ( typeof context.getElementsByName !== strundefined) {
								return context.getElementsByName(name);
							}
						};

						// Class
						Expr.find["CLASS"] = support.getByClassName &&
						function(className, context) {
							if ( typeof context.getElementsByClassName !== strundefined && !documentIsXML) {
								return context.getElementsByClassName(className);
							}
						};

						// QSA and matchesSelector support

						// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
						rbuggyMatches = [];

						// qSa(:focus) reports false when true (Chrome 21),
						// no need to also add to buggyMatches since matches checks buggyQSA
						// A support test would require too much code (would include document ready)
						rbuggyQSA = [":focus"];

						if ((support.qsa = isNative(doc.querySelectorAll))) {
							// Build QSA regex
							// Regex strategy adopted from Diego Perini
							assert(function(div) {
								// Select is set to empty string on purpose
								// This is to test IE's treatment of not explictly
								// setting a boolean content attribute,
								// since its presence should be enough
								// http://bugs.jquery.com/ticket/12359
								div.innerHTML = "<select><option selected=''></option></select>";

								// IE8 - Some boolean attributes are not treated correctly
								if (!div.querySelectorAll("[selected]").length) {
									rbuggyQSA.push("\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)");
								}

								// Webkit/Opera - :checked should return selected option elements
								// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
								// IE8 throws error here and will not see later tests
								if (!div.querySelectorAll(":checked").length) {
									rbuggyQSA.push(":checked");
								}
							});

							assert(function(div) {

								// Opera 10-12/IE8 - ^= $= *= and empty values
								// Should not select anything
								div.innerHTML = "<input type='hidden' i=''/>";
								if (div.querySelectorAll("[i^='']").length) {
									rbuggyQSA.push("[*^$]=" + whitespace + "*(?:\"\"|'')");
								}

								// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
								// IE8 throws error here and will not see later tests
								if (!div.querySelectorAll(":enabled").length) {
									rbuggyQSA.push(":enabled", ":disabled");
								}

								// Opera 10-11 does not throw on post-comma invalid pseudos
								div.querySelectorAll("*,:x");
								rbuggyQSA.push(",.*:");
							});
						}

						if ((support.matchesSelector = isNative(( matches = docElem.matchesSelector || docElem.mozMatchesSelector || docElem.webkitMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {

							assert(function(div) {
								// Check to see if it's possible to do matchesSelector
								// on a disconnected node (IE 9)
								support.disconnectedMatch = matches.call(div, "div");

								// This should fail with an exception
								// Gecko does not error, returns false instead
								matches.call(div, "[s!='']:x");
								rbuggyMatches.push("!=", pseudos);
							});
						}

						rbuggyQSA = new RegExp(rbuggyQSA.join("|"));
						rbuggyMatches = new RegExp(rbuggyMatches.join("|"));

						// Element contains another
						// Purposefully does not implement inclusive descendent
						// As in, an element does not contain itself
						contains = isNative(docElem.contains) || docElem.compareDocumentPosition ? function(a, b) {
							var adown = a.nodeType === 9 ? a.documentElement : a,
							    bup = b && b.parentNode;
							return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
							));
						} : function(a, b) {
							if (b) {
								while (( b = b.parentNode)) {
									if (b === a) {
										return true;
									}
								}
							}
							return false;
						};

						// Document order sorting
						sortOrder = docElem.compareDocumentPosition ? function(a, b) {
							var compare;

							if (a === b) {
								hasDuplicate = true;
								return 0;
							}

							if (( compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b))) {
								if (compare & 1 || a.parentNode && a.parentNode.nodeType === 11) {
									if (a === doc || contains(preferredDoc, a)) {
										return -1;
									}
									if (b === doc || contains(preferredDoc, b)) {
										return 1;
									}
									return 0;
								}
								return compare & 4 ? -1 : 1;
							}

							return a.compareDocumentPosition ? -1 : 1;
						} : function(a, b) {
							var cur,
							    i = 0,
							    aup = a.parentNode,
							    bup = b.parentNode,
							    ap = [a],
							    bp = [b];

							// Exit early if the nodes are identical
							if (a === b) {
								hasDuplicate = true;
								return 0;

								// Parentless nodes are either documents or disconnected
							} else if (!aup || !bup) {
								return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : 0;

								// If the nodes are siblings, we can do a quick check
							} else if (aup === bup) {
								return siblingCheck(a, b);
							}

							// Otherwise we need full lists of their ancestors for comparison
							cur = a;
							while (( cur = cur.parentNode)) {
								ap.unshift(cur);
							}
							cur = b;
							while (( cur = cur.parentNode)) {
								bp.unshift(cur);
							}

							// Walk down the tree looking for a discrepancy
							while (ap[i] === bp[i]) {
								i++;
							}

							return i ?
							// Do a sibling check if the nodes have a common ancestor
							siblingCheck(ap[i], bp[i]) :

							// Otherwise nodes in our document sort first
							ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
						};

						// Always assume the presence of duplicates if sort doesn't
						// pass them to our comparison function (as in Google Chrome).
						hasDuplicate = false;
						[0, 0].sort(sortOrder);
						support.detectDuplicates = hasDuplicate;

						return document;
					};

					Sizzle.matches = function(expr, elements) {
						return Sizzle(expr, null, null, elements);
					};

					Sizzle.matchesSelector = function(elem, expr) {
						// Set document vars if needed
						if ((elem.ownerDocument || elem ) !== document) {
							setDocument(elem);
						}

						// Make sure that attribute selectors are quoted
						expr = expr.replace(rattributeQuotes, "='$1']");

						// rbuggyQSA always contains :focus, so no need for an existence check
						if (support.matchesSelector && !documentIsXML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && !rbuggyQSA.test(expr)) {
							try {
								var ret = matches.call(elem, expr);

								// IE 9's matchesSelector returns false on disconnected nodes
								if (ret || support.disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document && elem.document.nodeType !== 11) {
									return ret;
								}
							} catch(e) {
							}
						}

						return Sizzle(expr, document, null, [elem]).length > 0;
					};

					Sizzle.contains = function(context, elem) {
						// Set document vars if needed
						if ((context.ownerDocument || context ) !== document) {
							setDocument(context);
						}
						return contains(context, elem);
					};

					Sizzle.attr = function(elem, name) {
						var val;

						// Set document vars if needed
						if ((elem.ownerDocument || elem ) !== document) {
							setDocument(elem);
						}

						if (!documentIsXML) {
							name = name.toLowerCase();
						}
						if (( val = Expr.attrHandle[name])) {
							return val(elem);
						}
						if (documentIsXML || support.attributes) {
							return elem.getAttribute(name);
						}
						return (( val = elem.getAttributeNode(name)) || elem.getAttribute(name) ) && elem[name] === true ? name : val && val.specified ? val.value : null;
					};

					Sizzle.error = function(msg) {
						throw new Error("Syntax error, unrecognized expression: " + msg);
					};

					// Document sorting and removing duplicates
					Sizzle.uniqueSort = function(results) {
						var elem,
						    duplicates = [],
						    i = 1,
						    j = 0;

						// Unless we *know* we can detect duplicates, assume their presence
						hasDuplicate = !support.detectDuplicates;
						results.sort(sortOrder);

						if (hasDuplicate) {
							for (; ( elem = results[i]); i++) {
								if (elem === results[i - 1]) {
									j = duplicates.push(i);
								}
							}
							while (j--) {
								results.splice(duplicates[j], 1);
							}
						}

						return results;
					};

					function siblingCheck(a, b) {
						var cur = b && a,
						    diff = cur && (~b.sourceIndex || MAX_NEGATIVE ) - (~a.sourceIndex || MAX_NEGATIVE );

						// Use IE sourceIndex if available on both nodes
						if (diff) {
							return diff;
						}

						// Check if b follows a
						if (cur) {
							while (( cur = cur.nextSibling)) {
								if (cur === b) {
									return -1;
								}
							}
						}

						return a ? 1 : -1;
					}

					// Returns a function to use in pseudos for input types
					function createInputPseudo(type) {
						return function(elem) {
							var name = elem.nodeName.toLowerCase();
							return name === "input" && elem.type === type;
						};
					}

					// Returns a function to use in pseudos for buttons
					function createButtonPseudo(type) {
						return function(elem) {
							var name = elem.nodeName.toLowerCase();
							return (name === "input" || name === "button") && elem.type === type;
						};
					}

					// Returns a function to use in pseudos for positionals
					function createPositionalPseudo(fn) {
						return markFunction(function(argument) {
							argument = +argument;
							return markFunction(function(seed, matches) {
								var j,
								    matchIndexes = fn([], seed.length, argument),
								    i = matchIndexes.length;

								// Match elements found at the specified indexes
								while (i--) {
									if (seed[( j = matchIndexes[i])]) {
										seed[j] = !(matches[j] = seed[j]);
									}
								}
							});
						});
					}

					/**
					 * Utility function for retrieving the text value of an array of DOM nodes
					 * @param {Array|Element} elem
					 */
					getText = Sizzle.getText = function(elem) {
						var node,
						    ret = "",
						    i = 0,
						    nodeType = elem.nodeType;

						if (!nodeType) {
							// If no nodeType, this is expected to be an array
							for (; ( node = elem[i]); i++) {
								// Do not traverse comment nodes
								ret += getText(node);
							}
						} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
							// Use textContent for elements
							// innerText usage removed for consistency of new lines (see #11153)
							if ( typeof elem.textContent === "string") {
								return elem.textContent;
							} else {
								// Traverse its children
								for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
									ret += getText(elem);
								}
							}
						} else if (nodeType === 3 || nodeType === 4) {
							return elem.nodeValue;
						}
						// Do not include comment or processing instruction nodes

						return ret;
					};

					Expr = Sizzle.selectors = {

						// Can be adjusted by the user
						cacheLength : 50,

						createPseudo : markFunction,

						match : matchExpr,

						find : {},

						relative : {
							">" : {
								dir : "parentNode",
								first : true
							},
							" " : {
								dir : "parentNode"
							},
							"+" : {
								dir : "previousSibling",
								first : true
							},
							"~" : {
								dir : "previousSibling"
							}
						},

						preFilter : {
							"ATTR" : function(match) {
								match[1] = match[1].replace(runescape, funescape);

								// Move the given value to match[3] whether quoted or unquoted
								match[3] = (match[4] || match[5] || "" ).replace(runescape, funescape);

								if (match[2] === "~=") {
									match[3] = " " + match[3] + " ";
								}

								return match.slice(0, 4);
							},

							"CHILD" : function(match) {
								/* matches from matchExpr["CHILD"]
								 1 type (only|nth|...)
								 2 what (child|of-type)
								 3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
								 4 xn-component of xn+y argument ([+-]?\d*n|)
								 5 sign of xn-component
								 6 x of xn-component
								 7 sign of y-component
								 8 y of y-component
								 */
								match[1] = match[1].toLowerCase();

								if (match[1].slice(0, 3) === "nth") {
									// nth-* requires argument
									if (!match[3]) {
										Sizzle.error(match[0]);
									}

									// numeric x and y parameters for Expr.filter.CHILD
									// remember that false/true cast respectively to 0/1
									match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd" ) );
									match[5] = +((match[7] + match[8] ) || match[3] === "odd" );

									// other types prohibit arguments
								} else if (match[3]) {
									Sizzle.error(match[0]);
								}

								return match;
							},

							"PSEUDO" : function(match) {
								var excess,
								    unquoted = !match[5] && match[2];

								if (matchExpr["CHILD"].test(match[0])) {
									return null;
								}

								// Accept quoted arguments as-is
								if (match[4]) {
									match[2] = match[4];

									// Strip excess characters from unquoted arguments
								} else if (unquoted && rpseudo.test(unquoted) &&
								// Get excess from tokenize (recursively)
								( excess = tokenize(unquoted, true)) &&
								// advance to the next closing parenthesis
								( excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

									// excess is a negative index
									match[0] = match[0].slice(0, excess);
									match[2] = unquoted.slice(0, excess);
								}

								// Return only captures needed by the pseudo filter method (type and argument)
								return match.slice(0, 3);
							}
						},

						filter : {

							"TAG" : function(nodeName) {
								if (nodeName === "*") {
									return function() {
										return true;
									};
								}

								nodeName = nodeName.replace(runescape, funescape).toLowerCase();
								return function(elem) {
									return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
								};
							},

							"CLASS" : function(className) {
								var pattern = classCache[className + " "];

								return pattern || ( pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
									return pattern.test(elem.className || ( typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "");
								});
							},

							"ATTR" : function(name, operator, check) {
								return function(elem) {
									var result = Sizzle.attr(elem, name);

									if (result == null) {
										return operator === "!=";
									}
									if (!operator) {
										return true;
									}

									result += "";

									return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " " ).indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
								};
							},

							"CHILD" : function(type, what, argument, first, last) {
								var simple = type.slice(0, 3) !== "nth",
								    forward = type.slice(-4) !== "last",
								    ofType = what === "of-type";

								return first === 1 && last === 0 ?

								// Shortcut for :nth-*(n)
								function(elem) {
									return !!elem.parentNode;
								} : function(elem, context, xml) {
									var cache,
									    outerCache,
									    node,
									    diff,
									    nodeIndex,
									    start,
									    dir = simple !== forward ? "nextSibling" : "previousSibling",
									    parent = elem.parentNode,
									    name = ofType && elem.nodeName.toLowerCase(),
									    useCache = !xml && !ofType;

									if (parent) {

										// :(first|last|only)-(child|of-type)
										if (simple) {
											while (dir) {
												node = elem;
												while (( node = node[dir])) {
													if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
														return false;
													}
												}
												// Reverse direction for :only-* (if we haven't yet done so)
												start = dir = type === "only" && !start && "nextSibling";
											}
											return true;
										}

										start = [ forward ? parent.firstChild : parent.lastChild];

										// non-xml :nth-child(...) stores cache data on `parent`
										if (forward && useCache) {
											// Seek `elem` from a previously-cached index
											outerCache = parent[expando] || (parent[expando] = {});
											cache = outerCache[type] || [];
											nodeIndex = cache[0] === dirruns && cache[1];
											diff = cache[0] === dirruns && cache[2];
											node = nodeIndex && parent.childNodes[nodeIndex];

											while (( node = ++nodeIndex && node && node[dir] ||

											// Fallback to seeking `elem` from the start
											( diff = nodeIndex = 0) || start.pop())) {

												// When found, cache indexes on `parent` and break
												if (node.nodeType === 1 && ++diff && node === elem) {
													outerCache[type] = [dirruns, nodeIndex, diff];
													break;
												}
											}

											// Use previously-cached element index if available
										} else if (useCache && ( cache = (elem[ expando ] || (elem[ expando ] = {}))[type]) && cache[0] === dirruns) {
											diff = cache[1];

											// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
										} else {
											// Use the same loop as above to seek `elem` from the start
											while (( node = ++nodeIndex && node && node[dir] || ( diff = nodeIndex = 0) || start.pop())) {

												if (( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff) {
													// Cache the index of each encountered element
													if (useCache) {
														(node[ expando ] || (node[ expando ] = {}))[type] = [dirruns, diff];
													}

													if (node === elem) {
														break;
													}
												}
											}
										}

										// Incorporate the offset, then check against cycle size
										diff -= last;
										return diff === first || (diff % first === 0 && diff / first >= 0 );
									}
								};
							},

							"PSEUDO" : function(pseudo, argument) {
								// pseudo-class names are case-insensitive
								// http://www.w3.org/TR/selectors/#pseudo-classes
								// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
								// Remember that setFilters inherits from pseudos
								var args,
								    fn = Expr.pseudos[pseudo] || Expr.setFilters[ pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

								// The user may use createPseudo to indicate that
								// arguments are needed to create the filter function
								// just as Sizzle does
								if (fn[expando]) {
									return fn(argument);
								}

								// But maintain support for old signatures
								if (fn.length > 1) {
									args = [pseudo, pseudo, "", argument];
									return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
										var idx,
										    matched = fn(seed, argument),
										    i = matched.length;
										while (i--) {
											idx = indexOf.call(seed, matched[i]);
											seed[idx] = !(matches[idx] = matched[i] );
										}
									}) : function(elem) {
										return fn(elem, 0, args);
									};
								}

								return fn;
							}
						},

						pseudos : {
							// Potentially complex pseudos
							"not" : markFunction(function(selector) {
								// Trim the selector passed to compile
								// to avoid treating leading and trailing
								// spaces as combinators
								var input = [],
								    results = [],
								    matcher = compile(selector.replace(rtrim, "$1"));

								return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
									var elem,
									    unmatched = matcher(seed, null, xml, []),
									    i = seed.length;

									// Match elements unmatched by `matcher`
									while (i--) {
										if (( elem = unmatched[i])) {
											seed[i] = !(matches[i] = elem);
										}
									}
								}) : function(elem, context, xml) {
									input[0] = elem;
									matcher(input, null, xml, results);
									return !results.pop();
								};
							}),

							"has" : markFunction(function(selector) {
								return function(elem) {
									return Sizzle(selector, elem).length > 0;
								};
							}),

							"contains" : markFunction(function(text) {
								return function(elem) {
									return (elem.textContent || elem.innerText || getText(elem) ).indexOf(text) > -1;
								};
							}),

							// "Whether an element is represented by a :lang() selector
							// is based solely on the element's language value
							// being equal to the identifier C,
							// or beginning with the identifier C immediately followed by "-".
							// The matching of C against the element's language value is performed case-insensitively.
							// The identifier C does not have to be a valid language name."
							// http://www.w3.org/TR/selectors/#lang-pseudo
							"lang" : markFunction(function(lang) {
								// lang value must be a valid identifider
								if (!ridentifier.test(lang || "")) {
									Sizzle.error("unsupported lang: " + lang);
								}
								lang = lang.replace(runescape, funescape).toLowerCase();
								return function(elem) {
									var elemLang;
									do {
										if (( elemLang = documentIsXML ? elem.getAttribute("xml:lang") || elem.getAttribute("lang") : elem.lang)) {

											elemLang = elemLang.toLowerCase();
											return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
										}
									} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
									return false;
								};
							}),

							// Miscellaneous
							"target" : function(elem) {
								var hash = window.location && window.location.hash;
								return hash && hash.slice(1) === elem.id;
							},

							"root" : function(elem) {
								return elem === docElem;
							},

							"focus" : function(elem) {
								return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
							},

							// Boolean properties
							"enabled" : function(elem) {
								return elem.disabled === false;
							},

							"disabled" : function(elem) {
								return elem.disabled === true;
							},

							"checked" : function(elem) {
								// In CSS3, :checked should return both checked and selected elements
								// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
								var nodeName = elem.nodeName.toLowerCase();
								return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
							},

							"selected" : function(elem) {
								// Accessing this property makes selected-by-default
								// options in Safari work properly
								if (elem.parentNode) {
									elem.parentNode.selectedIndex
								}

								return elem.selected === true;
							},

							// Contents
							"empty" : function(elem) {
								// http://www.w3.org/TR/selectors/#empty-pseudo
								// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
								//   not comment, processing instructions, or others
								// Thanks to Diego Perini for the nodeName shortcut
								//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
								for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
									if (elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4) {
										return false;
									}
								}
								return true;
							},

							"parent" : function(elem) {
								return !Expr.pseudos["empty"](elem);
							},

							// Element/input types
							"header" : function(elem) {
								return rheader.test(elem.nodeName);
							},

							"input" : function(elem) {
								return rinputs.test(elem.nodeName);
							},

							"button" : function(elem) {
								var name = elem.nodeName.toLowerCase();
								return name === "input" && elem.type === "button" || name === "button";
							},

							"text" : function(elem) {
								var attr;
								// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
								// use getAttribute instead to test this case
								return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (( attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
							},

							// Position-in-collection
							"first" : createPositionalPseudo(function() {
								return [0];
							}),

							"last" : createPositionalPseudo(function(matchIndexes, length) {
								return [length - 1];
							}),

							"eq" : createPositionalPseudo(function(matchIndexes, length, argument) {
								return [argument < 0 ? argument + length : argument];
							}),

							"even" : createPositionalPseudo(function(matchIndexes, length) {
								var i = 0;
								for (; i < length; i += 2) {
									matchIndexes.push(i);
								}
								return matchIndexes;
							}),

							"odd" : createPositionalPseudo(function(matchIndexes, length) {
								var i = 1;
								for (; i < length; i += 2) {
									matchIndexes.push(i);
								}
								return matchIndexes;
							}),

							"lt" : createPositionalPseudo(function(matchIndexes, length, argument) {
								var i = argument < 0 ? argument + length : argument;
								for (; --i >= 0; ) {
									matchIndexes.push(i);
								}
								return matchIndexes;
							}),

							"gt" : createPositionalPseudo(function(matchIndexes, length, argument) {
								var i = argument < 0 ? argument + length : argument;
								for (; ++i < length; ) {
									matchIndexes.push(i);
								}
								return matchIndexes;
							})
						}
					};

					// Add button/input type pseudos
					for (i in {
						radio : true,
						checkbox : true,
						file : true,
						password : true,
						image : true
					} ) {
						Expr.pseudos[i] = createInputPseudo(i);
					}
					for (i in {
						submit : true,
						reset : true
					} ) {
						Expr.pseudos[i] = createButtonPseudo(i);
					}

					function tokenize(selector, parseOnly) {
						var matched,
						    match,
						    tokens,
						    type,
						    soFar,
						    groups,
						    preFilters,
						    cached = tokenCache[selector + " "];

						if (cached) {
							return parseOnly ? 0 : cached.slice(0);
						}

						soFar = selector;
						groups = [];
						preFilters = Expr.preFilter;

						while (soFar) {

							// Comma and first run
							if (!matched || ( match = rcomma.exec(soFar))) {
								if (match) {
									// Don't consume trailing commas as valid
									soFar = soFar.slice(match[0].length) || soFar;
								}
								groups.push( tokens = []);
							}

							matched = false;

							// Combinators
							if (( match = rcombinators.exec(soFar))) {
								matched = match.shift();
								tokens.push({
									value : matched,
									// Cast descendant combinators to space
									type : match[0].replace(rtrim, " ")
								});
								soFar = soFar.slice(matched.length);
							}

							// Filters
							for (type in Expr.filter ) {
								if (( match = matchExpr[type].exec(soFar)) && (!preFilters[type] || ( match = preFilters[ type ](match)))) {
									matched = match.shift();
									tokens.push({
										value : matched,
										type : type,
										matches : match
									});
									soFar = soFar.slice(matched.length);
								}
							}

							if (!matched) {
								break;
							}
						}

						// Return the length of the invalid excess
						// if we're just parsing
						// Otherwise, throw an error or return tokens
						return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
						// Cache the tokens
						tokenCache(selector, groups).slice(0);
					}

					function toSelector(tokens) {
						var i = 0,
						    len = tokens.length,
						    selector = "";
						for (; i < len; i++) {
							selector += tokens[i].value;
						}
						return selector;
					}

					function addCombinator(matcher, combinator, base) {
						var dir = combinator.dir,
						    checkNonElements = base && dir === "parentNode",
						    doneName = done++;

						return combinator.first ?
						// Check against closest ancestor/preceding element
						function(elem, context, xml) {
							while (( elem = elem[dir])) {
								if (elem.nodeType === 1 || checkNonElements) {
									return matcher(elem, context, xml);
								}
							}
						} :

						// Check against all ancestor/preceding elements
						function(elem, context, xml) {
							var data,
							    cache,
							    outerCache,
							    dirkey = dirruns + " " + doneName;

							// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
							if (xml) {
								while (( elem = elem[dir])) {
									if (elem.nodeType === 1 || checkNonElements) {
										if (matcher(elem, context, xml)) {
											return true;
										}
									}
								}
							} else {
								while (( elem = elem[dir])) {
									if (elem.nodeType === 1 || checkNonElements) {
										outerCache = elem[expando] || (elem[expando] = {});
										if (( cache = outerCache[dir]) && cache[0] === dirkey) {
											if (( data = cache[1]) === true || data === cachedruns) {
												return data === true;
											}
										} else {
											cache = outerCache[dir] = [dirkey];
											cache[1] = matcher(elem, context, xml) || cachedruns;
											if (cache[1] === true) {
												return true;
											}
										}
									}
								}
							}
						};
					}

					function elementMatcher(matchers) {
						return matchers.length > 1 ? function(elem, context, xml) {
							var i = matchers.length;
							while (i--) {
								if (!matchers[i](elem, context, xml)) {
									return false;
								}
							}
							return true;
						} : matchers[0];
					}

					function condense(unmatched, map, filter, context, xml) {
						var elem,
						    newUnmatched = [],
						    i = 0,
						    len = unmatched.length,
						    mapped = map != null;

						for (; i < len; i++) {
							if (( elem = unmatched[i])) {
								if (!filter || filter(elem, context, xml)) {
									newUnmatched.push(elem);
									if (mapped) {
										map.push(i);
									}
								}
							}
						}

						return newUnmatched;
					}

					function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
						if (postFilter && !postFilter[expando]) {
							postFilter = setMatcher(postFilter);
						}
						if (postFinder && !postFinder[expando]) {
							postFinder = setMatcher(postFinder, postSelector);
						}
						return markFunction(function(seed, results, context, xml) {
							var temp,
							    i,
							    elem,
							    preMap = [],
							    postMap = [],
							    preexisting = results.length,

							// Get initial elements from seed or context
							    elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

							// Prefilter to get matcher input, preserving a map for seed-results synchronization
							    matcherIn = preFilter && (seed || !selector ) ? condense(elems, preMap, preFilter, context, xml) : elems,

							    matcherOut = matcher ?
							// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
							postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

							// ...intermediate processing is necessary
							[
							] :

							// ...otherwise use results directly
							results : matcherIn;

							// Find primary matches
							if (matcher) {
								matcher(matcherIn, matcherOut, context, xml);
							}

							// Apply postFilter
							if (postFilter) {
								temp = condense(matcherOut, postMap);
								postFilter(temp, [], context, xml);

								// Un-match failing elements by moving them back to matcherIn
								i = temp.length;
								while (i--) {
									if (( elem = temp[i])) {
										matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
									}
								}
							}

							if (seed) {
								if (postFinder || preFilter) {
									if (postFinder) {
										// Get the final matcherOut by condensing this intermediate into postFinder contexts
										temp = [];
										i = matcherOut.length;
										while (i--) {
											if (( elem = matcherOut[i])) {
												// Restore matcherIn since elem is not yet a final match
												temp.push((matcherIn[i] = elem));
											}
										}
										postFinder(null, ( matcherOut = []), temp, xml);
									}

									// Move matched elements from seed to results to keep them synchronized
									i = matcherOut.length;
									while (i--) {
										if (( elem = matcherOut[i]) && ( temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

											seed[temp] = !(results[temp] = elem);
										}
									}
								}

								// Add elements to results, through postFinder if defined
							} else {
								matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
								if (postFinder) {
									postFinder(null, results, matcherOut, xml);
								} else {
									push.apply(results, matcherOut);
								}
							}
						});
					}

					function matcherFromTokens(tokens) {
						var checkContext,
						    matcher,
						    j,
						    len = tokens.length,
						    leadingRelative = Expr.relative[tokens[0].type],
						    implicitRelative = leadingRelative || Expr.relative[" "],
						    i = leadingRelative ? 1 : 0,

						// The foundational matcher ensures that elements are reachable from top-level context(s)
						    matchContext = addCombinator(function(elem) {
							return elem === checkContext;
						}, implicitRelative, true),
						    matchAnyContext = addCombinator(function(elem) {
							return indexOf.call(checkContext, elem) > -1;
						}, implicitRelative, true),
						    matchers = [
						function(elem, context, xml) {
							return (!leadingRelative && (xml || context !== outermostContext ) ) || (( checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml) );
						}];

						for (; i < len; i++) {
							if (( matcher = Expr.relative[tokens[i].type])) {
								matchers = [addCombinator(elementMatcher(matchers), matcher)];
							} else {
								matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

								// Return special upon seeing a positional matcher
								if (matcher[expando]) {
									// Find the next relative operator (if any) for proper handling
									j = ++i;
									for (; j < len; j++) {
										if (Expr.relative[tokens[j].type]) {
											break;
										}
									}
									return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1)).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(( tokens = tokens.slice(j))), j < len && toSelector(tokens));
								}
								matchers.push(matcher);
							}
						}

						return elementMatcher(matchers);
					}

					function matcherFromGroupMatchers(elementMatchers, setMatchers) {
						// A counter to specify which element is currently being matched
						var matcherCachedRuns = 0,
						    bySet = setMatchers.length > 0,
						    byElement = elementMatchers.length > 0,
						    superMatcher = function(seed, context, xml, results, expandContext) {
							var elem,
							    j,
							    matcher,
							    setMatched = [],
							    matchedCount = 0,
							    i = "0",
							    unmatched = seed && [],
							    outermost = expandContext != null,
							    contextBackup =
							    outermostContext,
							// We must always have either seed elements or context
							    elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context),
							// Use integer dirruns iff this is the outermost matcher
							    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

							if (outermost) {
								outermostContext = context !== document && context;
								cachedruns = matcherCachedRuns;
							}

							// Add elements passing elementMatchers directly to results
							// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
							for (; ( elem = elems[i]) != null; i++) {
								if (byElement && elem) {
									j = 0;
									while (( matcher = elementMatchers[j++])) {
										if (matcher(elem, context, xml)) {
											results.push(elem);
											break;
										}
									}
									if (outermost) {
										dirruns = dirrunsUnique;
										cachedruns = ++matcherCachedRuns;
									}
								}

								// Track unmatched elements for set filters
								if (bySet) {
									// They will have gone through all possible matchers
									if (( elem = !matcher && elem)) {
										matchedCount--;
									}

									// Lengthen the array for every element, matched or not
									if (seed) {
										unmatched.push(elem);
									}
								}
							}

							// Apply set filters to unmatched elements
							matchedCount += i;
							if (bySet && i !== matchedCount) {
								j = 0;
								while (( matcher = setMatchers[j++])) {
									matcher(unmatched, setMatched, context, xml);
								}

								if (seed) {
									// Reintegrate element matches to eliminate the need for sorting
									if (matchedCount > 0) {
										while (i--) {
											if (!(unmatched[i] || setMatched[i])) {
												setMatched[i] = pop.call(results);
											}
										}
									}

									// Discard index placeholder values to get only actual matches
									setMatched = condense(setMatched);
								}

								// Add matches to results
								push.apply(results, setMatched);

								// Seedless set matches succeeding multiple successful matchers stipulate sorting
								if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length ) > 1) {

									Sizzle.uniqueSort(results);
								}
							}

							// Override manipulation of globals by nested matchers
							if (outermost) {
								dirruns = dirrunsUnique;
								outermostContext = contextBackup;
							}

							return unmatched;
						};

						return bySet ? markFunction(superMatcher) : superMatcher;
					}

					compile = Sizzle.compile = function(selector, group /* Internal Use Only */ ) {
						var i,
						    setMatchers = [],
						    elementMatchers = [],
						    cached = compilerCache[selector + " "];

						if (!cached) {
							// Generate a function of recursive functions that can be used to check each element
							if (!group) {
								group = tokenize(selector);
							}
							i = group.length;
							while (i--) {
								cached = matcherFromTokens(group[i]);
								if (cached[expando]) {
									setMatchers.push(cached);
								} else {
									elementMatchers.push(cached);
								}
							}

							// Cache the compiled function
							cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
						}
						return cached;
					};

					function multipleContexts(selector, contexts, results) {
						var i = 0,
						    len = contexts.length;
						for (; i < len; i++) {
							Sizzle(selector, contexts[i], results);
						}
						return results;
					}

					function select(selector, context, results, seed) {
						var i,
						    tokens,
						    token,
						    type,
						    find,
						    match = tokenize(selector);

						if (!seed) {
							// Try to minimize operations if there is only one group
							if (match.length === 1) {

								// Take a shortcut and set the context if the root selector is an ID
								tokens = match[0] = match[0].slice(0);
								if (tokens.length > 2 && ( token = tokens[0]).type === "ID" && context.nodeType === 9 && !documentIsXML && Expr.relative[tokens[1].type]) {

									context = Expr.find["ID"]( token.matches[0].replace( runescape, funescape ), context )[0];
									if (!context) {
										return results;
									}

									selector = selector.slice(tokens.shift().value.length);
								}

								// Fetch a seed set for right-to-left matching
								i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
								while (i--) {
									token = tokens[i];

									// Abort if we hit a combinator
									if (Expr.relative[( type = token.type)]) {
										break;
									}
									if (( find = Expr.find[type])) {
										// Search, expanding context for leading sibling combinators
										if (( seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context))) {

											// If seed is empty or no tokens remain, we can return early
											tokens.splice(i, 1);
											selector = seed.length && toSelector(tokens);
											if (!selector) {
												push.apply(results, slice.call(seed, 0));
												return results;
											}

											break;
										}
									}
								}
							}
						}

						// Compile and execute a filtering function
						// Provide `match` to avoid retokenization if we modified the selector above
						compile( selector, match )(seed, context, documentIsXML, results, rsibling.test(selector));
						return results;
					}

					// Deprecated
					Expr.pseudos["nth"] = Expr.pseudos["eq"];

					// Easy API for creating new setFilters
					function setFilters() {
					}


					Expr.filters = setFilters.prototype = Expr.pseudos;
					Expr.setFilters = new setFilters();

					// Initialize with the default document
					setDocument();

					// Override sizzle attribute retrieval
					Sizzle.attr = jQuery.attr;
					jQuery.find = Sizzle;
					jQuery.expr = Sizzle.selectors;
					jQuery.expr[":"] = jQuery.expr.pseudos;
					jQuery.unique = Sizzle.uniqueSort;
					jQuery.text = Sizzle.getText;
					jQuery.isXMLDoc = Sizzle.isXML;
					jQuery.contains = Sizzle.contains;

				})(window);
				var runtil = /Until$/,
				    rparentsprev = /^(?:parents|prev(?:Until|All))/,
				    isSimple = /^.[^:#\[\.,]*$/,
				    rneedsContext = jQuery.expr.match.needsContext,
				// methods guaranteed to produce a unique set when starting from a unique set
				    guaranteedUnique = {
					children : true,
					contents : true,
					next : true,
					prev : true
				};

				jQuery.fn.extend({
					find : function(selector) {
						var i,
						    ret,
						    self,
						    len = this.length;

						if ( typeof selector !== "string") {
							self = this;
							return this.pushStack(jQuery(selector).filter(function() {
								for ( i = 0; i < len; i++) {
									if (jQuery.contains(self[i], this)) {
										return true;
									}
								}
							}));
						}

						ret = [];
						for ( i = 0; i < len; i++) {
							jQuery.find(selector, this[i], ret);
						}

						// Needed because $( selector, context ) becomes $( context ).find( selector )
						ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
						ret.selector = (this.selector ? this.selector + " " : "" ) + selector;
						return ret;
					},

					has : function(target) {
						var i,
						    targets = jQuery(target, this),
						    len = targets.length;

						return this.filter(function() {
							for ( i = 0; i < len; i++) {
								if (jQuery.contains(this, targets[i])) {
									return true;
								}
							}
						});
					},

					not : function(selector) {
						return this.pushStack(winnow(this, selector, false));
					},

					filter : function(selector) {
						return this.pushStack(winnow(this, selector, true));
					},

					is : function(selector) {
						return !!selector && ( typeof selector === "string" ?
						// If this is a positional/relative selector, check membership in the returned set
						// so $("p:first").is("p:last") won't return true for a doc with two "p".
						rneedsContext.test(selector) ? jQuery(selector, this.context).index(this[0]) >= 0 : jQuery.filter(selector, this).length > 0 : this.filter(selector).length > 0 );
					},

					closest : function(selectors, context) {
						var cur,
						    i = 0,
						    l = this.length,
						    ret = [],
						    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

						for (; i < l; i++) {
							cur = this[i];

							while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {
								if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
									ret.push(cur);
									break;
								}
								cur = cur.parentNode;
							}
						}

						return this.pushStack(ret.length > 1 ? jQuery.unique(ret) : ret);
					},

					// Determine the position of an element within
					// the matched set of elements
					index : function(elem) {

						// No argument, return index in parent
						if (!elem) {
							return (this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
						}

						// index in selector
						if ( typeof elem === "string") {
							return jQuery.inArray(this[0], jQuery(elem));
						}

						// Locate the position of the desired element
						return jQuery.inArray(
						// If it receives a jQuery object, the first element is used
						elem.jquery ? elem[0] : elem, this);
					},

					add : function(selector, context) {
						var set = typeof selector === "string" ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
						    all = jQuery.merge(this.get(), set);

						return this.pushStack(jQuery.unique(all));
					},

					addBack : function(selector) {
						return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
					}
				});

				jQuery.fn.andSelf = jQuery.fn.addBack;

				function sibling(cur, dir) {
					do {
						cur = cur[dir];
					} while ( cur && cur.nodeType !== 1 );

					return cur;
				}


				jQuery.each({
					parent : function(elem) {
						var parent = elem.parentNode;
						return parent && parent.nodeType !== 11 ? parent : null;
					},
					parents : function(elem) {
						return jQuery.dir(elem, "parentNode");
					},
					parentsUntil : function(elem, i, until) {
						return jQuery.dir(elem, "parentNode", until);
					},
					next : function(elem) {
						return sibling(elem, "nextSibling");
					},
					prev : function(elem) {
						return sibling(elem, "previousSibling");
					},
					nextAll : function(elem) {
						return jQuery.dir(elem, "nextSibling");
					},
					prevAll : function(elem) {
						return jQuery.dir(elem, "previousSibling");
					},
					nextUntil : function(elem, i, until) {
						return jQuery.dir(elem, "nextSibling", until);
					},
					prevUntil : function(elem, i, until) {
						return jQuery.dir(elem, "previousSibling", until);
					},
					siblings : function(elem) {
						return jQuery.sibling((elem.parentNode || {} ).firstChild, elem);
					},
					children : function(elem) {
						return jQuery.sibling(elem.firstChild);
					},
					contents : function(elem) {
						return jQuery.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
					}
				}, function(name, fn) {
					jQuery.fn[name] = function(until, selector) {
						var ret = jQuery.map(this, fn, until);

						if (!runtil.test(name)) {
							selector = until;
						}

						if (selector && typeof selector === "string") {
							ret = jQuery.filter(selector, ret);
						}

						ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

						if (this.length > 1 && rparentsprev.test(name)) {
							ret = ret.reverse();
						}

						return this.pushStack(ret);
					};
				});

				jQuery.extend({
					filter : function(expr, elems, not) {
						if (not) {
							expr = ":not(" + expr + ")";
						}

						return elems.length === 1 ? jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] : jQuery.find.matches(expr, elems);
					},

					dir : function(elem, dir, until) {
						var matched = [],
						    cur = elem[dir];

						while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
							if (cur.nodeType === 1) {
								matched.push(cur);
							}
							cur = cur[dir];
						}
						return matched;
					},

					sibling : function(n, elem) {
						var r = [];

						for (; n; n = n.nextSibling) {
							if (n.nodeType === 1 && n !== elem) {
								r.push(n);
							}
						}

						return r;
					}
				});

				// Implement the identical functionality for filter and not
				function winnow(elements, qualifier, keep) {

					// Can't pass null or undefined to indexOf in Firefox 4
					// Set to 0 to skip string check
					qualifier = qualifier || 0;

					if (jQuery.isFunction(qualifier)) {
						return jQuery.grep(elements, function(elem, i) {
							var retVal = !!qualifier.call(elem, i, elem);
							return retVal === keep;
						});

					} else if (qualifier.nodeType) {
						return jQuery.grep(elements, function(elem) {
							return (elem === qualifier ) === keep;
						});

					} else if ( typeof qualifier === "string") {
						var filtered = jQuery.grep(elements, function(elem) {
							return elem.nodeType === 1;
						});

						if (isSimple.test(qualifier)) {
							return jQuery.filter(qualifier, filtered, !keep);
						} else {
							qualifier = jQuery.filter(qualifier, filtered);
						}
					}

					return jQuery.grep(elements, function(elem) {
						return (jQuery.inArray(elem, qualifier) >= 0 ) === keep;
					});
				}

				function createSafeFragment(document) {
					var list = nodeNames.split("|"),
					    safeFrag = document.createDocumentFragment();

					if (safeFrag.createElement) {
						while (list.length) {
							safeFrag.createElement(list.pop());
						}
					}
					return safeFrag;
				}

				var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" + "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
				    rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
				    rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
				    rleadingWhitespace = /^\s+/,
				    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
				    rtagName = /<([\w:]+)/,
				    rtbody = /<tbody/i,
				    rhtml = /<|&#?\w+;/,
				    rnoInnerhtml = /<(?:script|style|link)/i,
				    manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
				// checked="checked" or checked
				    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
				    rscriptType = /^$|\/(?:java|ecma)script/i,
				    rscriptTypeMasked = /^true\/(.*)/,
				    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

				// We have to close these tags to support XHTML (#13200)
				    wrapMap = {
					option : [1, "<select multiple='multiple'>", "</select>"],
					legend : [1, "<fieldset>", "</fieldset>"],
					area : [1, "<map>", "</map>"],
					param : [1, "<object>", "</object>"],
					thead : [1, "<table>", "</table>"],
					tr : [2, "<table><tbody>", "</tbody></table>"],
					col : [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
					td : [3, "<table><tbody><tr>", "</tr></tbody></table>"],

					// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
					// unless wrapped in a div with non-breaking characters in front of it.
					_default : jQuery.support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
				},
				    safeFragment = createSafeFragment(document),
				    fragmentDiv = safeFragment.appendChild(document.createElement("div"));

				wrapMap.optgroup = wrapMap.option;
				wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
				wrapMap.th = wrapMap.td;

				jQuery.fn.extend({
					text : function(value) {
						return jQuery.access(this, function(value) {
							return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document ).createTextNode(value));
						}, null, value, arguments.length);
					},

					wrapAll : function(html) {
						if (jQuery.isFunction(html)) {
							return this.each(function(i) {
								jQuery(this).wrapAll(html.call(this, i));
							});
						}

						if (this[0]) {
							// The elements to wrap the target around
							var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

							if (this[0].parentNode) {
								wrap.insertBefore(this[0]);
							}

							wrap.map(function() {
								var elem = this;

								while (elem.firstChild && elem.firstChild.nodeType === 1) {
									elem = elem.firstChild;
								}

								return elem;
							}).append(this);
						}

						return this;
					},

					wrapInner : function(html) {
						if (jQuery.isFunction(html)) {
							return this.each(function(i) {
								jQuery(this).wrapInner(html.call(this, i));
							});
						}

						return this.each(function() {
							var self = jQuery(this),
							    contents = self.contents();

							if (contents.length) {
								contents.wrapAll(html);

							} else {
								self.append(html);
							}
						});
					},

					wrap : function(html) {
						var isFunction = jQuery.isFunction(html);

						return this.each(function(i) {
							jQuery(this).wrapAll( isFunction ? html.call(this, i) : html);
						});
					},

					unwrap : function() {
						return this.parent().each(function() {
							if (!jQuery.nodeName(this, "body")) {
								jQuery(this).replaceWith(this.childNodes);
							}
						}).end();
					},

					append : function() {
						return this.domManip(arguments, true, function(elem) {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								this.appendChild(elem);
							}
						});
					},

					prepend : function() {
						return this.domManip(arguments, true, function(elem) {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								this.insertBefore(elem, this.firstChild);
							}
						});
					},

					before : function() {
						return this.domManip(arguments, false, function(elem) {
							if (this.parentNode) {
								this.parentNode.insertBefore(elem, this);
							}
						});
					},

					after : function() {
						return this.domManip(arguments, false, function(elem) {
							if (this.parentNode) {
								this.parentNode.insertBefore(elem, this.nextSibling);
							}
						});
					},

					// keepData is for internal use only--do not document
					remove : function(selector, keepData) {
						var elem,
						    i = 0;

						for (; ( elem = this[i]) != null; i++) {
							if (!selector || jQuery.filter(selector, [elem]).length > 0) {
								if (!keepData && elem.nodeType === 1) {
									jQuery.cleanData(getAll(elem));
								}

								if (elem.parentNode) {
									if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
										setGlobalEval(getAll(elem, "script"));
									}
									elem.parentNode.removeChild(elem);
								}
							}
						}

						return this;
					},

					empty : function() {
						var elem,
						    i = 0;

						for (; ( elem = this[i]) != null; i++) {
							// Remove element nodes and prevent memory leaks
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
							}

							// Remove any remaining nodes
							while (elem.firstChild) {
								elem.removeChild(elem.firstChild);
							}

							// If this is a select, ensure that it displays empty (#12336)
							// Support: IE<9
							if (elem.options && jQuery.nodeName(elem, "select")) {
								elem.options.length = 0;
							}
						}

						return this;
					},

					clone : function(dataAndEvents, deepDataAndEvents) {
						dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
						deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

						return this.map(function() {
							return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
						});
					},

					html : function(value) {
						return jQuery.access(this, function(value) {
							var elem = this[0] || {},
							    i = 0,
							    l = this.length;

							if (value === undefined) {
								return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, "") : undefined;
							}

							// See if we can take a shortcut and just use innerHTML
							if ( typeof value === "string" && !rnoInnerhtml.test(value) && (jQuery.support.htmlSerialize || !rnoshimcache.test(value)  ) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value) ) && !wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase()]) {

								value = value.replace(rxhtmlTag, "<$1></$2>");

								try {
									for (; i < l; i++) {
										// Remove element nodes and prevent memory leaks
										elem = this[i] || {};
										if (elem.nodeType === 1) {
											jQuery.cleanData(getAll(elem, false));
											elem.innerHTML = value;
										}
									}

									elem = 0;

									// If using innerHTML throws an exception, use the fallback method
								} catch(e) {
								}
							}

							if (elem) {
								this.empty().append(value);
							}
						}, null, value, arguments.length);
					},

					replaceWith : function(value) {
						var isFunc = jQuery.isFunction(value);

						// Make sure that the elements are removed from the DOM before they are inserted
						// this can help fix replacing a parent with child elements
						if (!isFunc && typeof value !== "string") {
							value = jQuery(value).not(this).detach();
						}

						return this.domManip([value], true, function(elem) {
							var next = this.nextSibling,
							    parent = this.parentNode;

							if (parent) {
								jQuery(this).remove();
								parent.insertBefore(elem, next);
							}
						});
					},

					detach : function(selector) {
						return this.remove(selector, true);
					},

					domManip : function(args, table, callback) {

						// Flatten any nested arrays
						args = core_concat.apply([], args);

						var first,
						    node,
						    hasScripts,
						    scripts,
						    doc,
						    fragment,
						    i = 0,
						    l = this.length,
						    set = this,
						    iNoClone = l - 1,
						    value = args[0],
						    isFunction = jQuery.isFunction(value);

						// We can't cloneNode fragments that contain checked, in WebKit
						if (isFunction || !(l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test(value) )) {
							return this.each(function(index) {
								var self = set.eq(index);
								if (isFunction) {
									args[0] = value.call(this, index, table ? self.html() : undefined);
								}
								self.domManip(args, table, callback);
							});
						}

						if (l) {
							fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
							first = fragment.firstChild;

							if (fragment.childNodes.length === 1) {
								fragment = first;
							}

							if (first) {
								table = table && jQuery.nodeName(first, "tr");
								scripts = jQuery.map(getAll(fragment, "script"), disableScript);
								hasScripts = scripts.length;

								// Use the original fragment for the last item instead of the first because it can end up
								// being emptied incorrectly in certain situations (#8070).
								for (; i < l; i++) {
									node = fragment;

									if (i !== iNoClone) {
										node = jQuery.clone(node, true, true);

										// Keep references to cloned scripts for later restoration
										if (hasScripts) {
											jQuery.merge(scripts, getAll(node, "script"));
										}
									}

									callback.call(table && jQuery.nodeName(this[i], "table") ? findOrAppend(this[i], "tbody") : this[i], node, i);
								}

								if (hasScripts) {
									doc = scripts[scripts.length - 1].ownerDocument;

									// Reenable scripts
									jQuery.map(scripts, restoreScript);

									// Evaluate executable scripts on first document insertion
									for ( i = 0; i < hasScripts; i++) {
										node = scripts[i];
										if (rscriptType.test(node.type || "") && !jQuery._data(node, "globalEval") && jQuery.contains(doc, node)) {

											if (node.src) {
												// Hope ajax is available...
												jQuery.ajax({
													url : node.src,
													type : "GET",
													dataType : "script",
													async : false,
													global : false,
													"throws" : true
												});
											} else {
												jQuery.globalEval((node.text || node.textContent || node.innerHTML || "" ).replace(rcleanScript, ""));
											}
										}
									}
								}

								// Fix #11809: Avoid leaking memory
								fragment = first = null;
							}
						}

						return this;
					}
				});

				function findOrAppend(elem, tag) {
					return elem.getElementsByTagName( tag )[0] || elem.appendChild(elem.ownerDocument.createElement(tag));
				}

				// Replace/restore the type attribute of script elements for safe DOM manipulation
				function disableScript(elem) {
					var attr = elem.getAttributeNode("type");
					elem.type = (attr && attr.specified ) + "/" + elem.type;
					return elem;
				}

				function restoreScript(elem) {
					var match = rscriptTypeMasked.exec(elem.type);
					if (match) {
						elem.type = match[1];
					} else {
						elem.removeAttribute("type");
					}
					return elem;
				}

				// Mark scripts as having already been evaluated
				function setGlobalEval(elems, refElements) {
					var elem,
					    i = 0;
					for (; ( elem = elems[i]) != null; i++) {
						jQuery._data(elem, "globalEval", !refElements || jQuery._data(refElements[i], "globalEval"));
					}
				}

				function cloneCopyEvent(src, dest) {

					if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
						return;
					}

					var type,
					    i,
					    l,
					    oldData = jQuery._data(src),
					    curData = jQuery._data(dest, oldData),
					    events = oldData.events;

					if (events) {
						delete curData.handle;
						curData.events = {};

						for (type in events ) {
							for ( i = 0,
							l = events[type].length; i < l; i++) {
								jQuery.event.add(dest, type, events[ type ][i]);
							}
						}
					}

					// make the cloned public data object a copy from the original
					if (curData.data) {
						curData.data = jQuery.extend({}, curData.data);
					}
				}

				function fixCloneNodeIssues(src, dest) {
					var nodeName,
					    e,
					    data;

					// We do not need to do anything for non-Elements
					if (dest.nodeType !== 1) {
						return;
					}

					nodeName = dest.nodeName.toLowerCase();

					// IE6-8 copies events bound via attachEvent when using cloneNode.
					if (!jQuery.support.noCloneEvent && dest[jQuery.expando]) {
						data = jQuery._data(dest);

						for (e in data.events ) {
							jQuery.removeEvent(dest, e, data.handle);
						}

						// Event data gets referenced instead of copied if the expando gets copied too
						dest.removeAttribute(jQuery.expando);
					}

					// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
					if (nodeName === "script" && dest.text !== src.text) {
						disableScript(dest).text = src.text;
						restoreScript(dest);

						// IE6-10 improperly clones children of object elements using classid.
						// IE10 throws NoModificationAllowedError if parent is null, #12132.
					} else if (nodeName === "object") {
						if (dest.parentNode) {
							dest.outerHTML = src.outerHTML;
						}

						// This path appears unavoidable for IE9. When cloning an object
						// element in IE9, the outerHTML strategy above is not sufficient.
						// If the src has innerHTML and the destination does not,
						// copy the src.innerHTML into the dest.innerHTML. #10324
						if (jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML) )) {
							dest.innerHTML = src.innerHTML;
						}

					} else if (nodeName === "input" && manipulation_rcheckableType.test(src.type)) {
						// IE6-8 fails to persist the checked state of a cloned checkbox
						// or radio button. Worse, IE6-7 fail to give the cloned element
						// a checked appearance if the defaultChecked value isn't also set

						dest.defaultChecked = dest.checked = src.checked;

						// IE6-7 get confused and end up setting the value of a cloned
						// checkbox/radio button to an empty string instead of "on"
						if (dest.value !== src.value) {
							dest.value = src.value;
						}

						// IE6-8 fails to return the selected option to the default selected
						// state when cloning options
					} else if (nodeName === "option") {
						dest.defaultSelected = dest.selected = src.defaultSelected;

						// IE6-8 fails to set the defaultValue to the correct value when
						// cloning other types of input fields
					} else if (nodeName === "input" || nodeName === "textarea") {
						dest.defaultValue = src.defaultValue;
					}
				}


				jQuery.each({
					appendTo : "append",
					prependTo : "prepend",
					insertBefore : "before",
					insertAfter : "after",
					replaceAll : "replaceWith"
				}, function(name, original) {
					jQuery.fn[name] = function(selector) {
						var elems,
						    i = 0,
						    ret = [],
						    insert = jQuery(selector),
						    last = insert.length - 1;

						for (; i <= last; i++) {
							elems = i === last ? this : this.clone(true);
							jQuery( insert[i] )[ original ](elems);

							// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
							core_push.apply(ret, elems.get());
						}

						return this.pushStack(ret);
					};
				});

				function getAll(context, tag) {
					var elems,
					    elem,
					    i = 0,
					    found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll(tag || "*") : undefined;

					if (!found) {
						for ( found = [],
						elems = context.childNodes || context; ( elem = elems[i]) != null; i++) {
							if (!tag || jQuery.nodeName(elem, tag)) {
								found.push(elem);
							} else {
								jQuery.merge(found, getAll(elem, tag));
							}
						}
					}

					return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;
				}

				// Used in buildFragment, fixes the defaultChecked property
				function fixDefaultChecked(elem) {
					if (manipulation_rcheckableType.test(elem.type)) {
						elem.defaultChecked = elem.checked;
					}
				}


				jQuery.extend({
					clone : function(elem, dataAndEvents, deepDataAndEvents) {
						var destElements,
						    node,
						    clone,
						    i,
						    srcElements,
						    inPage = jQuery.contains(elem.ownerDocument, elem);

						if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
							clone = elem.cloneNode(true);

							// IE<=8 does not properly clone detached, unknown element nodes
						} else {
							fragmentDiv.innerHTML = elem.outerHTML;
							fragmentDiv.removeChild( clone = fragmentDiv.firstChild);
						}

						if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

							// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
							destElements = getAll(clone);
							srcElements = getAll(elem);

							// Fix all IE cloning issues
							for ( i = 0; ( node = srcElements[i]) != null; ++i) {
								// Ensure that the destination node is not null; Fixes #9587
								if (destElements[i]) {
									fixCloneNodeIssues(node, destElements[i]);
								}
							}
						}

						// Copy the events from the original to the clone
						if (dataAndEvents) {
							if (deepDataAndEvents) {
								srcElements = srcElements || getAll(elem);
								destElements = destElements || getAll(clone);

								for ( i = 0; ( node = srcElements[i]) != null; i++) {
									cloneCopyEvent(node, destElements[i]);
								}
							} else {
								cloneCopyEvent(elem, clone);
							}
						}

						// Preserve script evaluation history
						destElements = getAll(clone, "script");
						if (destElements.length > 0) {
							setGlobalEval(destElements, !inPage && getAll(elem, "script"));
						}

						destElements = srcElements = node = null;

						// Return the cloned set
						return clone;
					},

					buildFragment : function(elems, context, scripts, selection) {
						var j,
						    elem,
						    contains,
						    tmp,
						    tag,
						    tbody,
						    wrap,
						    l = elems.length,

						// Ensure a safe fragment
						    safe = createSafeFragment(context),

						    nodes = [],
						    i = 0;

						for (; i < l; i++) {
							elem = elems[i];

							if (elem || elem === 0) {

								// Add nodes directly
								if (jQuery.type(elem) === "object") {
									jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

									// Convert non-html into a text node
								} else if (!rhtml.test(elem)) {
									nodes.push(context.createTextNode(elem));

									// Convert html into DOM nodes
								} else {
									tmp = tmp || safe.appendChild(context.createElement("div"));

									// Deserialize a standard representation
									tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
									wrap = wrapMap[tag] || wrapMap._default;

									tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];

									// Descend through wrappers to the right content
									j = wrap[0];
									while (j--) {
										tmp = tmp.lastChild;
									}

									// Manually add leading whitespace removed by IE
									if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
										nodes.push(context.createTextNode(rleadingWhitespace.exec( elem )[0]));
									}

									// Remove IE's autoinserted <tbody> from table fragments
									if (!jQuery.support.tbody) {

										// String was a <table>, *may* have spurious <tbody>
										elem = tag === "table" && !rtbody.test(elem) ? tmp.firstChild :

										// String was a bare <thead> or <tfoot>
										wrap[1] === "<table>" && !rtbody.test(elem) ? tmp : 0;

										j = elem && elem.childNodes.length;
										while (j--) {
											if (jQuery.nodeName(( tbody = elem.childNodes[j]), "tbody") && !tbody.childNodes.length) {
												elem.removeChild(tbody);
											}
										}
									}

									jQuery.merge(nodes, tmp.childNodes);

									// Fix #12392 for WebKit and IE > 9
									tmp.textContent = "";

									// Fix #12392 for oldIE
									while (tmp.firstChild) {
										tmp.removeChild(tmp.firstChild);
									}

									// Remember the top-level container for proper cleanup
									tmp = safe.lastChild;
								}
							}
						}

						// Fix #11356: Clear elements from fragment
						if (tmp) {
							safe.removeChild(tmp);
						}

						// Reset defaultChecked for any radios and checkboxes
						// about to be appended to the DOM in IE 6/7 (#8060)
						if (!jQuery.support.appendChecked) {
							jQuery.grep(getAll(nodes, "input"), fixDefaultChecked);
						}

						i = 0;
						while (( elem = nodes[i++])) {

							// #4087 - If origin and destination elements are the same, and this is
							// that element, do not do anything
							if (selection && jQuery.inArray(elem, selection) !== -1) {
								continue;
							}

							contains = jQuery.contains(elem.ownerDocument, elem);

							// Append to fragment
							tmp = getAll(safe.appendChild(elem), "script");

							// Preserve script evaluation history
							if (contains) {
								setGlobalEval(tmp);
							}

							// Capture executables
							if (scripts) {
								j = 0;
								while (( elem = tmp[j++])) {
									if (rscriptType.test(elem.type || "")) {
										scripts.push(elem);
									}
								}
							}
						}

						tmp = null;

						return safe;
					},

					cleanData : function(elems, /* internal */acceptData) {
						var elem,
						    type,
						    id,
						    data,
						    i = 0,
						    internalKey = jQuery.expando,
						    cache = jQuery.cache,
						    deleteExpando = jQuery.support.deleteExpando,
						    special = jQuery.event.special;

						for (; ( elem = elems[i]) != null; i++) {

							if (acceptData || jQuery.acceptData(elem)) {

								id = elem[internalKey];
								data = id && cache[id];

								if (data) {
									if (data.events) {
										for (type in data.events ) {
											if (special[type]) {
												jQuery.event.remove(elem, type);

												// This is a shortcut to avoid jQuery.event.remove's overhead
											} else {
												jQuery.removeEvent(elem, type, data.handle);
											}
										}
									}

									// Remove cache only if it was not already removed by jQuery.event.remove
									if (cache[id]) {
										delete cache[id];

										// IE does not allow us to delete expando properties from nodes,
										// nor does it have a removeAttribute function on Document nodes;
										// we must handle all of these cases
										if (deleteExpando) {
											delete elem[internalKey];

										} else if ( typeof elem.removeAttribute !== core_strundefined) {
											elem.removeAttribute(internalKey);

										} else {
											elem[internalKey] = null;
										}

										core_deletedIds.push(id);
									}
								}
							}
						}
					}
				});
				var iframe,
				    getStyles,
				    curCSS,
				    ralpha = /alpha\([^)]*\)/i,
				    ropacity = /opacity\s*=\s*([^)]*)/,
				    rposition = /^(top|right|bottom|left)$/,
				// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
				// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
				    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
				    rmargin = /^margin/,
				    rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
				    rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
				    rrelNum = new RegExp("^([+-])=(" + core_pnum + ")", "i"),
				    elemdisplay = {
					BODY : "block"
				},

				    cssShow = {
					position : "absolute",
					visibility : "hidden",
					display : "block"
				},
				    cssNormalTransform = {
					letterSpacing : 0,
					fontWeight : 400
				},

				    cssExpand = ["Top", "Right", "Bottom", "Left"],
				    cssPrefixes = ["Webkit", "O", "Moz", "ms"];

				// return a css property mapped to a potentially vendor prefixed property
				function vendorPropName(style, name) {

					// shortcut for names that are not vendor prefixed
					if ( name in style) {
						return name;
					}

					// check for vendor prefixed names
					var capName = name.charAt(0).toUpperCase() + name.slice(1),
					    origName =
					    name,
					    i = cssPrefixes.length;

					while (i--) {
						name = cssPrefixes[i] + capName;
						if ( name in style) {
							return name;
						}
					}

					return origName;
				}

				function isHidden(elem, el) {
					// isHidden might be called from jQuery#filter function;
					// in that case, element will be second argument
					elem = el || elem;
					return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
				}

				function showHide(elements, show) {
					var display,
					    elem,
					    hidden,
					    values = [],
					    index = 0,
					    length = elements.length;

					for (; index < length; index++) {
						elem = elements[index];
						if (!elem.style) {
							continue;
						}

						values[index] = jQuery._data(elem, "olddisplay");
						display = elem.style.display;
						if (show) {
							// Reset the inline display of this element to learn if it is
							// being hidden by cascaded rules or not
							if (!values[index] && display === "none") {
								elem.style.display = "";
							}

							// Set elements which have been overridden with display: none
							// in a stylesheet to whatever the default browser style is
							// for such an element
							if (elem.style.display === "" && isHidden(elem)) {
								values[index] = jQuery._data(elem, "olddisplay", css_defaultDisplay(elem.nodeName));
							}
						} else {

							if (!values[index]) {
								hidden = isHidden(elem);

								if (display && display !== "none" || !hidden) {
									jQuery._data(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
								}
							}
						}
					}

					// Set the display of most of the elements in a second loop
					// to avoid the constant reflow
					for ( index = 0; index < length; index++) {
						elem = elements[index];
						if (!elem.style) {
							continue;
						}
						if (!show || elem.style.display === "none" || elem.style.display === "") {
							elem.style.display = show ? values[index] || "" : "none";
						}
					}

					return elements;
				}


				jQuery.fn.extend({
					css : function(name, value) {
						return jQuery.access(this, function(elem, name, value) {
							var len,
							    styles,
							    map = {},
							    i = 0;

							if (jQuery.isArray(name)) {
								styles = getStyles(elem);
								len = name.length;

								for (; i < len; i++) {
									map[name[i]] = jQuery.css(elem, name[i], false, styles);
								}

								return map;
							}

							return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
						}, name, value, arguments.length > 1);
					},
					show : function() {
						return showHide(this, true);
					},
					hide : function() {
						return showHide(this);
					},
					toggle : function(state) {
						var bool = typeof state === "boolean";

						return this.each(function() {
							if ( bool ? state : isHidden(this)) {
								jQuery(this).show();
							} else {
								jQuery(this).hide();
							}
						});
					}
				});

				jQuery.extend({
					// Add in style property hooks for overriding the default
					// behavior of getting and setting a style property
					cssHooks : {
						opacity : {
							get : function(elem, computed) {
								if (computed) {
									// We should always get a number back from opacity
									var ret = curCSS(elem, "opacity");
									return ret === "" ? "1" : ret;
								}
							}
						}
					},

					// Exclude the following css properties to add px
					cssNumber : {
						"columnCount" : true,
						"fillOpacity" : true,
						"fontWeight" : true,
						"lineHeight" : true,
						"opacity" : true,
						"orphans" : true,
						"widows" : true,
						"zIndex" : true,
						"zoom" : true
					},

					// Add in properties whose names you wish to fix before
					// setting or getting the value
					cssProps : {
						// normalize float css property
						"float" : jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
					},

					// Get and set the style property on a DOM Node
					style : function(elem, name, value, extra) {
						// Don't set styles on text and comment nodes
						if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
							return;
						}

						// Make sure that we're working with the right name
						var ret,
						    type,
						    hooks,
						    origName = jQuery.camelCase(name),
						    style = elem.style;

						name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName) );

						// gets hook for the prefixed version
						// followed by the unprefixed version
						hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

						// Check if we're setting a value
						if (value !== undefined) {
							type = typeof value;

							// convert relative number strings (+= or -=) to relative numbers. #7345
							if (type === "string" && ( ret = rrelNum.exec(value))) {
								value = (ret[1] + 1 ) * ret[2] + parseFloat(jQuery.css(elem, name));
								// Fixes bug #9237
								type = "number";
							}

							// Make sure that NaN and null values aren't set. See: #7116
							if (value == null || type === "number" && isNaN(value)) {
								return;
							}

							// If a number was passed in, add 'px' to the (except for certain CSS properties)
							if (type === "number" && !jQuery.cssNumber[origName]) {
								value += "px";
							}

							// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
							// but it would mean to define eight (for every problematic property) identical functions
							if (!jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
								style[name] = "inherit";
							}

							// If a hook was provided, use that value, otherwise just set the specified value
							if (!hooks || !("set" in hooks) || ( value = hooks.set(elem, value, extra)) !== undefined) {

								// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
								// Fixes bug #5509
								try {
									style[name] = value;
								} catch(e) {
								}
							}

						} else {
							// If a hook was provided get the non-computed value from there
							if (hooks && "get" in hooks && ( ret = hooks.get(elem, false, extra)) !== undefined) {
								return ret;
							}

							// Otherwise just get the value from the style object
							return style[name];
						}
					},

					css : function(elem, name, extra, styles) {
						var num,
						    val,
						    hooks,
						    origName = jQuery.camelCase(name);

						// Make sure that we're working with the right name
						name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName) );

						// gets hook for the prefixed version
						// followed by the unprefixed version
						hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

						// If a hook was provided get the computed value from there
						if (hooks && "get" in hooks) {
							val = hooks.get(elem, true, extra);
						}

						// Otherwise, if a way to get the computed value exists, use that
						if (val === undefined) {
							val = curCSS(elem, name, styles);
						}

						//convert "normal" to computed value
						if (val === "normal" && name in cssNormalTransform) {
							val = cssNormalTransform[name];
						}

						// Return, converting to number if forced or a qualifier was provided and val looks numeric
						if (extra === "" || extra) {
							num = parseFloat(val);
							return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
						}
						return val;
					},

					// A method for quickly swapping in/out CSS properties to get correct calculations
					swap : function(elem, options, callback, args) {
						var ret,
						    name,
						    old = {};

						// Remember the old values, and insert the new ones
						for (name in options ) {
							old[name] = elem.style[name];
							elem.style[name] = options[name];
						}

						ret = callback.apply(elem, args || []);

						// Revert the old values
						for (name in options ) {
							elem.style[name] = old[name];
						}

						return ret;
					}
				});

				// NOTE: we've included the "window" in window.getComputedStyle
				// because jsdom on node.js will break without it.
				if (window.getComputedStyle) {
					getStyles = function(elem) {
						return window.getComputedStyle(elem, null);
					};

					curCSS = function(elem, name, _computed) {
						var width,
						    minWidth,
						    maxWidth,
						    computed = _computed || getStyles(elem),

						// getPropertyValue is only needed for .css('filter') in IE9, see #12537
						    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined,
						    style = elem.style;

						if (computed) {

							if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
								ret = jQuery.style(elem, name);
							}

							// A tribute to the "awesome hack by Dean Edwards"
							// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
							// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
							// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
							if (rnumnonpx.test(ret) && rmargin.test(name)) {

								// Remember the original values
								width = style.width;
								minWidth = style.minWidth;
								maxWidth = style.maxWidth;

								// Put in the new values to get a computed value out
								style.minWidth = style.maxWidth = style.width = ret;
								ret = computed.width;

								// Revert the changed values
								style.width = width;
								style.minWidth = minWidth;
								style.maxWidth = maxWidth;
							}
						}

						return ret;
					};
				} else if (document.documentElement.currentStyle) {
					getStyles = function(elem) {
						return elem.currentStyle;
					};

					curCSS = function(elem, name, _computed) {
						var left,
						    rs,
						    rsLeft,
						    computed = _computed || getStyles(elem),
						    ret = computed ? computed[name] : undefined,
						    style = elem.style;

						// Avoid setting ret to empty string here
						// so we don't default to auto
						if (ret == null && style && style[name]) {
							ret = style[name];
						}

						// From the awesome hack by Dean Edwards
						// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

						// If we're not dealing with a regular pixel number
						// but a number that has a weird ending, we need to convert it to pixels
						// but not position css attributes, as those are proportional to the parent element instead
						// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
						if (rnumnonpx.test(ret) && !rposition.test(name)) {

							// Remember the original values
							left = style.left;
							rs = elem.runtimeStyle;
							rsLeft = rs && rs.left;

							// Put in the new values to get a computed value out
							if (rsLeft) {
								rs.left = elem.currentStyle.left;
							}
							style.left = name === "fontSize" ? "1em" : ret;
							ret = style.pixelLeft + "px";

							// Revert the changed values
							style.left = left;
							if (rsLeft) {
								rs.left = rsLeft;
							}
						}

						return ret === "" ? "auto" : ret;
					};
				}

				function setPositiveNumber(elem, value, subtract) {
					var matches = rnumsplit.exec(value);
					return matches ?
					// Guard against undefined "subtract", e.g., when used as in cssHooks
					Math.max(0, matches[1] - (subtract || 0 )) + (matches[2] || "px" ) : value;
				}

				function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
					var i = extra === ( isBorderBox ? "border" : "content" ) ?
					// If we already have the right measurement, avoid augmentation
					4 :
					// Otherwise initialize for horizontal or vertical properties
					name === "width" ? 1 : 0,

					    val = 0;

					for (; i < 4; i += 2) {
						// both box models exclude margin, so add it if we want it
						if (extra === "margin") {
							val += jQuery.css(elem, extra + cssExpand[i], true, styles);
						}

						if (isBorderBox) {
							// border-box includes padding, so remove it if we want content
							if (extra === "content") {
								val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
							}

							// at this point, extra isn't border nor margin, so remove border
							if (extra !== "margin") {
								val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							}
						} else {
							// at this point, extra isn't content, so add padding
							val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

							// at this point, extra isn't content nor padding, so add border
							if (extra !== "padding") {
								val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							}
						}
					}

					return val;
				}

				function getWidthOrHeight(elem, name, extra) {

					// Start with offset property, which is equivalent to the border-box value
					var valueIsBorderBox = true,
					    val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
					    styles = getStyles(elem),
					    isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box";

					// some non-html elements return undefined for offsetWidth, so check for null/undefined
					// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
					// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
					if (val <= 0 || val == null) {
						// Fall back to computed then uncomputed css if necessary
						val = curCSS(elem, name, styles);
						if (val < 0 || val == null) {
							val = elem.style[name];
						}

						// Computed unit is not pixels. Stop here and return.
						if (rnumnonpx.test(val)) {
							return val;
						}

						// we need the check for style in case a browser which returns unreliable values
						// for getComputedStyle silently falls back to the reliable elem.style
						valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name] );

						// Normalize "", auto, and prepare for extra
						val = parseFloat(val) || 0;
					}

					// use the active box-sizing model to add/subtract irrelevant styles
					return (val + augmentWidthOrHeight(elem, name, extra || ( isBorderBox ? "border" : "content" ), valueIsBorderBox, styles)
					) + "px";
				}

				// Try to determine the default display value of an element
				function css_defaultDisplay(nodeName) {
					var doc = document,
					    display = elemdisplay[nodeName];

					if (!display) {
						display = actualDisplay(nodeName, doc);

						// If the simple way fails, read from inside an iframe
						if (display === "none" || !display) {
							// Use the already-created iframe if possible
							iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>").css("cssText", "display:block !important")
							).appendTo(doc.documentElement);

							// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
							doc = (iframe[0].contentWindow || iframe[0].contentDocument ).document;
							doc.write("<!doctype html><html><body>");
							doc.close();

							display = actualDisplay(nodeName, doc);
							iframe.detach();
						}

						// Store the correct default display
						elemdisplay[nodeName] = display;
					}

					return display;
				}

				// Called ONLY from within css_defaultDisplay
				function actualDisplay(name, doc) {
					var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
					    display = jQuery.css(elem[0], "display");
					elem.remove();
					return display;
				}


				jQuery.each(["height", "width"], function(i, name) {
					jQuery.cssHooks[name] = {
						get : function(elem, computed, extra) {
							if (computed) {
								// certain elements can have dimension info if we invisibly show them
								// however, it must have a current display style that would benefit from this
								return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, "display")) ? jQuery.swap(elem, cssShow, function() {
									return getWidthOrHeight(elem, name, extra);
								}) : getWidthOrHeight(elem, name, extra);
							}
						},

						set : function(elem, value, extra) {
							var styles = extra && getStyles(elem);
							return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
						}
					};
				});

				if (!jQuery.support.opacity) {
					jQuery.cssHooks.opacity = {
						get : function(elem, computed) {
							// IE uses filters for opacity
							return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? (0.01 * parseFloat(RegExp.$1) ) + "" : computed ? "1" : "";
						},

						set : function(elem, value) {
							var style = elem.style,
							    currentStyle = elem.currentStyle,
							    opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
							    filter = currentStyle && currentStyle.filter || style.filter || "";

							// IE has trouble with opacity if it does not have layout
							// Force it by setting the zoom level
							style.zoom = 1;

							// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
							// if value === "", then remove inline opacity #12685
							if ((value >= 1 || value === "" ) && jQuery.trim(filter.replace(ralpha, "")) === "" && style.removeAttribute) {

								// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
								// if "filter:" is present at all, clearType is disabled, we want to avoid this
								// style.removeAttribute is IE Only, but so apparently is this code path...
								style.removeAttribute("filter");

								// if there is no filter style applied in a css rule or unset inline opacity, we are done
								if (value === "" || currentStyle && !currentStyle.filter) {
									return;
								}
							}

							// otherwise, set new filter values
							style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity;
						}
					};
				}

				// These hooks cannot be added until DOM ready because the support test
				// for it is not run until after DOM ready
				jQuery(function() {
					if (!jQuery.support.reliableMarginRight) {
						jQuery.cssHooks.marginRight = {
							get : function(elem, computed) {
								if (computed) {
									// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
									// Work around by temporarily setting element display to inline-block
									return jQuery.swap(elem, {
										"display" : "inline-block"
									}, curCSS, [elem, "marginRight"]);
								}
							}
						};
					}

					// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
					// getComputedStyle returns percent when specified for top/left/bottom/right
					// rather than make the css module depend on the offset module, we just check for it here
					if (!jQuery.support.pixelPosition && jQuery.fn.position) {
						jQuery.each(["top", "left"], function(i, prop) {
							jQuery.cssHooks[prop] = {
								get : function(elem, computed) {
									if (computed) {
										computed = curCSS(elem, prop);
										// if curCSS returns percentage, fallback to offset
										return rnumnonpx.test(computed) ? jQuery( elem ).position()[prop] + "px" : computed;
									}
								}
							};
						});
					}

				});

				if (jQuery.expr && jQuery.expr.filters) {
					jQuery.expr.filters.hidden = function(elem) {
						// Support: Opera <= 12.12
						// Opera reports offsetWidths and offsetHeights less than zero on some elements
						return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css(elem, "display")) === "none");
					};

					jQuery.expr.filters.visible = function(elem) {
						return !jQuery.expr.filters.hidden(elem);
					};
				}

				// These hooks are used by animate to expand properties
				jQuery.each({
					margin : "",
					padding : "",
					border : "Width"
				}, function(prefix, suffix) {
					jQuery.cssHooks[prefix + suffix] = {
						expand : function(value) {
							var i = 0,
							    expanded = {},

							// assumes a single number if not a string
							    parts = typeof value === "string" ? value.split(" ") : [value];

							for (; i < 4; i++) {
								expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
							}

							return expanded;
						}
					};

					if (!rmargin.test(prefix)) {
						jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
					}
				});
				var r20 = /%20/g,
				    rbracket = /\[\]$/,
				    rCRLF = /\r?\n/g,
				    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
				    rsubmittable = /^(?:input|select|textarea|keygen)/i;

				jQuery.fn.extend({
					serialize : function() {
						return jQuery.param(this.serializeArray());
					},
					serializeArray : function() {
						return this.map(function() {
							// Can add propHook for "elements" to filter or add form elements
							var elements = jQuery.prop(this, "elements");
							return elements ? jQuery.makeArray(elements) : this;
						}).filter(function() {
							var type = this.type;
							// Use .is(":disabled") so that fieldset[disabled] works
							return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type) );
						}).map(function(i, elem) {
							var val = jQuery(this).val();

							return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
								return {
									name : elem.name,
									value : val.replace(rCRLF, "\r\n")
								};
							}) : {
								name : elem.name,
								value : val.replace(rCRLF, "\r\n")
							};
						}).get();
					}
				});

				//Serialize an array of form elements or a set of
				//key/values into a query string
				jQuery.param = function(a, traditional) {
					var prefix,
					    s = [],
					    add = function(key, value) {
						// If value is a function, invoke it and return its value
						value = jQuery.isFunction(value) ? value() : (value == null ? "" : value );
						s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
					};

					// Set traditional to true for jQuery <= 1.3.2 behavior.
					if (traditional === undefined) {
						traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
					}

					// If an array was passed in, assume that it is an array of form elements.
					if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a) )) {
						// Serialize the form elements
						jQuery.each(a, function() {
							add(this.name, this.value);
						});

					} else {
						// If traditional, encode the "old" way (the way 1.3.2 or older
						// did it), otherwise encode params recursively.
						for (prefix in a ) {
							buildParams(prefix, a[prefix], traditional, add);
						}
					}

					// Return the resulting serialization
					return s.join("&").replace(r20, "+");
				};

				function buildParams(prefix, obj, traditional, add) {
					var name;

					if (jQuery.isArray(obj)) {
						// Serialize array item.
						jQuery.each(obj, function(i, v) {
							if (traditional || rbracket.test(prefix)) {
								// Treat each array item as a scalar.
								add(prefix, v);

							} else {
								// Item is non-scalar (array or object), encode its numeric index.
								buildParams(prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add);
							}
						});

					} else if (!traditional && jQuery.type(obj) === "object") {
						// Serialize object item.
						for (name in obj ) {
							buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
						}

					} else {
						// Serialize scalar item.
						add(prefix, obj);
					}
				}


				jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {

					// Handle event binding
					jQuery.fn[name] = function(data, fn) {
						return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
					};
				});

				jQuery.fn.hover = function(fnOver, fnOut) {
					return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
				};
				var
				// Document location
				ajaxLocParts,
				    ajaxLocation,
				    ajax_nonce = jQuery.now(),

				    ajax_rquery = /\?/,
				    rhash = /#.*$/,
				    rts = /([?&])_=[^&]*/,
				    rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
				// #7653, #8125, #8152: local protocol detection
				    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
				    rnoContent = /^(?:GET|HEAD)$/,
				    rprotocol = /^\/\//,
				    rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

				// Keep a copy of the old load method
				    _load = jQuery.fn.load,

				/* Prefilters
				 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
				 * 2) These are called:
				 *    - BEFORE asking for a transport
				 *    - AFTER param serialization (s.data is a string if s.processData is true)
				 * 3) key is the dataType
				 * 4) the catchall symbol "*" can be used
				 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
				 */
				    prefilters = {},

				/* Transports bindings
				 * 1) key is the dataType
				 * 2) the catchall symbol "*" can be used
				 * 3) selection will start with transport dataType and THEN go to "*" if needed
				 */
				    transports = {},

				// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
				    allTypes = "*/".concat("*");

				// #8138, IE may throw an exception when accessing
				// a field from window.location if document.domain has been set
				try {
					ajaxLocation = location.href;
				} catch( e ) {
					// Use the href attribute of an A element
					// since IE will modify it given document.location
					ajaxLocation = document.createElement("a");
					ajaxLocation.href = "";
					ajaxLocation = ajaxLocation.href;
				}

				// Segment location into parts
				ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

				// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
				function addToPrefiltersOrTransports(structure) {

					// dataTypeExpression is optional and defaults to "*"
					return function(dataTypeExpression, func) {

						if ( typeof dataTypeExpression !== "string") {
							func = dataTypeExpression;
							dataTypeExpression = "*";
						}

						var dataType,
						    i = 0,
						    dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];

						if (jQuery.isFunction(func)) {
							// For each dataType in the dataTypeExpression
							while (( dataType = dataTypes[i++])) {
								// Prepend if requested
								if (dataType[0] === "+") {
									dataType = dataType.slice(1) || "*";
									(structure[dataType] = structure[dataType] || []).unshift(func);

									// Otherwise append
								} else {
									(structure[dataType] = structure[dataType] || []).push(func);
								}
							}
						}
					};
				}

				// Base inspection function for prefilters and transports
				function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

					var inspected = {},
					    seekingTransport = (structure === transports );

					function inspect(dataType) {
						var selected;
						inspected[dataType] = true;
						jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
							var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
							if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
								options.dataTypes.unshift(dataTypeOrTransport);
								inspect(dataTypeOrTransport);
								return false;
							} else if (seekingTransport) {
								return !( selected = dataTypeOrTransport );
							}
						});
						return selected;
					}

					return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
				}

				// A special extend for ajax options
				// that takes "flat" options (not to be deep extended)
				// Fixes #9887
				function ajaxExtend(target, src) {
					var deep,
					    key,
					    flatOptions = jQuery.ajaxSettings.flatOptions || {};

					for (key in src ) {
						if (src[key] !== undefined) {
							( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[key] = src[key];
						}
					}
					if (deep) {
						jQuery.extend(true, target, deep);
					}

					return target;
				}


				jQuery.fn.load = function(url, params, callback) {
					if ( typeof url !== "string" && _load) {
						return _load.apply(this, arguments);
					}

					var selector,
					    response,
					    type,
					    self = this,
					    off = url.indexOf(" ");

					if (off >= 0) {
						selector = url.slice(off, url.length);
						url = url.slice(0, off);
					}

					// If it's a function
					if (jQuery.isFunction(params)) {

						// We assume that it's the callback
						callback = params;
						params = undefined;

						// Otherwise, build a param string
					} else if (params && typeof params === "object") {
						type = "POST";
					}

					// If we have elements to modify, make the request
					if (self.length > 0) {
						jQuery.ajax({
							url : url,

							// if "type" variable is undefined, then "GET" method will be used
							type : type,
							dataType : "html",
							data : params
						}).done(function(responseText) {

							// Save response for use in complete callback
							response = arguments;

							self.html( selector ?

							// If a selector was specified, locate the right elements in a dummy div
							// Exclude scripts to avoid IE 'Permission Denied' errors
							jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

							// Otherwise use the full result
							responseText);

						}).complete(callback &&
						function(jqXHR, status) {
							self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
						});
					}

					return this;
				};

				// Attach a bunch of functions for handling common AJAX events
				jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
					jQuery.fn[type] = function(fn) {
						return this.on(type, fn);
					};
				});

				jQuery.each(["get", "post"], function(i, method) {
					jQuery[method] = function(url, data, callback, type) {
						// shift arguments if data argument was omitted
						if (jQuery.isFunction(data)) {
							type = type || callback;
							callback = data;
							data = undefined;
						}

						return jQuery.ajax({
							url : url,
							type : method,
							dataType : type,
							data : data,
							success : callback
						});
					};
				});

				jQuery.extend({

					// Counter for holding the number of active queries
					active : 0,

					// Last-Modified header cache for next request
					lastModified : {},
					etag : {},

					ajaxSettings : {
						url : ajaxLocation,
						type : "GET",
						isLocal : rlocalProtocol.test(ajaxLocParts[1]),
						global : true,
						processData : true,
						async : true,
						contentType : "application/x-www-form-urlencoded; charset=UTF-8",
						/*
						 timeout: 0,
						 data: null,
						 dataType: null,
						 username: null,
						 password: null,
						 cache: null,
						 throws: false,
						 traditional: false,
						 headers: {},
						 */

						accepts : {
							"*" : allTypes,
							text : "text/plain",
							html : "text/html",
							xml : "application/xml, text/xml",
							json : "application/json, text/javascript"
						},

						contents : {
							xml : /xml/,
							html : /html/,
							json : /json/
						},

						responseFields : {
							xml : "responseXML",
							text : "responseText"
						},

						// Data converters
						// Keys separate source (or catchall "*") and destination types with a single space
						converters : {

							// Convert anything to text
							"* text" : window.String,

							// Text to html (true = no transformation)
							"text html" : true,

							// Evaluate text as a json expression
							"text json" : jQuery.parseJSON,

							// Parse text as xml
							"text xml" : jQuery.parseXML
						},

						// For options that shouldn't be deep extended:
						// you can add your own custom options here if
						// and when you create one that shouldn't be
						// deep extended (see ajaxExtend)
						flatOptions : {
							url : true,
							context : true
						}
					},

					// Creates a full fledged settings object into target
					// with both ajaxSettings and settings fields.
					// If target is omitted, writes into ajaxSettings.
					ajaxSetup : function(target, settings) {
						return settings ?

						// Building a settings object
						ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

						// Extending ajaxSettings
						ajaxExtend(jQuery.ajaxSettings, target);
					},

					ajaxPrefilter : addToPrefiltersOrTransports(prefilters),
					ajaxTransport : addToPrefiltersOrTransports(transports),

					// Main method
					ajax : function(url, options) {

						// If url is an object, simulate pre-1.5 signature
						if ( typeof url === "object") {
							options = url;
							url = undefined;
						}

						// Force options to be an object
						options = options || {};

						var// Cross-domain detection vars
						parts,
						// Loop variable
						    i,
						// URL without anti-cache param
						    cacheURL,
						// Response headers as string
						    responseHeadersString,
						// timeout handle
						    timeoutTimer,

						// To know if global events are to be dispatched
						    fireGlobals,

						    transport,
						// Response headers
						    responseHeaders,
						// Create the final options object
						    s = jQuery.ajaxSetup({}, options),
						// Callbacks context
						    callbackContext = s.context || s,
						// Context for global events is callbackContext if it is a DOM node or jQuery collection
						    globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery ) ? jQuery(callbackContext) : jQuery.event,
						// Deferreds
						    deferred = jQuery.Deferred(),
						    completeDeferred = jQuery.Callbacks("once memory"),
						// Status-dependent callbacks
						    statusCode = s.statusCode || {},
						// Headers (they are sent all at once)
						    requestHeaders = {},
						    requestHeadersNames = {},
						// The jqXHR state
						    state = 0,
						// Default abort message
						    strAbort = "canceled",
						// Fake xhr
						    jqXHR = {
							readyState : 0,

							// Builds headers hashtable if needed
							getResponseHeader : function(key) {
								var match;
								if (state === 2) {
									if (!responseHeaders) {
										responseHeaders = {};
										while (( match = rheaders.exec(responseHeadersString))) {
											responseHeaders[ match[1].toLowerCase()] = match[2];
										}
									}
									match = responseHeaders[ key.toLowerCase()];
								}
								return match == null ? null : match;
							},

							// Raw string
							getAllResponseHeaders : function() {
								return state === 2 ? responseHeadersString : null;
							},

							// Caches the header
							setRequestHeader : function(name, value) {
								var lname = name.toLowerCase();
								if (!state) {
									name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
									requestHeaders[name] = value;
								}
								return this;
							},

							// Overrides response content-type header
							overrideMimeType : function(type) {
								if (!state) {
									s.mimeType = type;
								}
								return this;
							},

							// Status-dependent callbacks
							statusCode : function(map) {
								var code;
								if (map) {
									if (state < 2) {
										for (code in map ) {
											// Lazy-add the new callback in a way that preserves old ones
											statusCode[code] = [statusCode[code], map[code]];
										}
									} else {
										// Execute the appropriate callbacks
										jqXHR.always(map[jqXHR.status]);
									}
								}
								return this;
							},

							// Cancel the request
							abort : function(statusText) {
								var finalText = statusText || strAbort;
								if (transport) {
									transport.abort(finalText);
								}
								done(0, finalText);
								return this;
							}
						};

						// Attach deferreds
						deferred.promise(jqXHR).complete = completeDeferred.add;
						jqXHR.success = jqXHR.done;
						jqXHR.error = jqXHR.fail;

						// Remove hash character (#7531: and string promotion)
						// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
						// Handle falsy url in the settings object (#10093: consistency with old signature)
						// We also use the url parameter if available
						s.url = ((url || s.url || ajaxLocation ) + "" ).replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

						// Alias method option to type as per ticket #12004
						s.type = options.method || options.type || s.method || s.type;

						// Extract dataTypes list
						s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(core_rnotwhite) || [""];

						// A cross-domain request is in order when we have a protocol:host:port mismatch
						if (s.crossDomain == null) {
							parts = rurl.exec(s.url.toLowerCase());
							s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? 80 : 443 ) ) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443 ) ) )
							);
						}

						// Convert data if not already a string
						if (s.data && s.processData && typeof s.data !== "string") {
							s.data = jQuery.param(s.data, s.traditional);
						}

						// Apply prefilters
						inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

						// If request was aborted inside a prefilter, stop there
						if (state === 2) {
							return jqXHR;
						}

						// We can fire global events as of now if asked to
						fireGlobals = s.global;

						// Watch for a new set of requests
						if (fireGlobals && jQuery.active++ === 0) {
							jQuery.event.trigger("ajaxStart");
						}

						// Uppercase the type
						s.type = s.type.toUpperCase();

						// Determine if request has content
						s.hasContent = !rnoContent.test(s.type);

						// Save the URL in case we're toying with the If-Modified-Since
						// and/or If-None-Match header later on
						cacheURL = s.url;

						// More options handling for requests with no content
						if (!s.hasContent) {

							// If data is available, append data to url
							if (s.data) {
								cacheURL = (s.url += (ajax_rquery.test(cacheURL) ? "&" : "?" ) + s.data );
								// #9682: remove data so that it's not used in an eventual retry
								delete s.data;
							}

							// Add anti-cache in url if needed
							if (s.cache === false) {
								s.url = rts.test(cacheURL) ?

								// If there is already a '_' parameter, set its value
								cacheURL.replace(rts, "$1_=" + ajax_nonce++) :

								// Otherwise add one to the end
								cacheURL + (ajax_rquery.test(cacheURL) ? "&" : "?" ) + "_=" + ajax_nonce++;
							}
						}

						// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
						if (s.ifModified) {
							if (jQuery.lastModified[cacheURL]) {
								jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
							}
							if (jQuery.etag[cacheURL]) {
								jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
							}
						}

						// Set the correct header, if data is being sent
						if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
							jqXHR.setRequestHeader("Content-Type", s.contentType);
						}

						// Set the Accepts header for the server, depending on the dataType
						jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) : s.accepts["*"]);

						// Check for headers option
						for (i in s.headers ) {
							jqXHR.setRequestHeader(i, s.headers[i]);
						}

						// Allow custom headers/mimetypes and early abort
						if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2 )) {
							// Abort if not done already and return
							return jqXHR.abort();
						}

						// aborting is no longer a cancellation
						strAbort = "abort";

						// Install callbacks on deferreds
						for (i in {
							success : 1,
							error : 1,
							complete : 1
						} ) {
							jqXHR[ i ](s[i]);
						}

						// Get transport
						transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

						// If no transport, we auto-abort
						if (!transport) {
							done(-1, "No Transport");
						} else {
							jqXHR.readyState = 1;

							// Send global event
							if (fireGlobals) {
								globalEventContext.trigger("ajaxSend", [jqXHR, s]);
							}
							// Timeout
							if (s.async && s.timeout > 0) {
								timeoutTimer = setTimeout(function() {
									jqXHR.abort("timeout");
								}, s.timeout);
							}

							try {
								state = 1;
								transport.send(requestHeaders, done);
							} catch ( e ) {
								// Propagate exception as error if not done
								if (state < 2) {
									done(-1, e);
									// Simply rethrow otherwise
								} else {
									throw e;
								}
							}
						}

						// Callback for when everything is done
						function done(status, nativeStatusText, responses, headers) {
							var isSuccess,
							    success,
							    error,
							    response,
							    modified,
							    statusText =
							    nativeStatusText;

							// Called once
							if (state === 2) {
								return;
							}

							// State is "done" now
							state = 2;

							// Clear timeout if it exists
							if (timeoutTimer) {
								clearTimeout(timeoutTimer);
							}

							// Dereference transport for early garbage collection
							// (no matter how long the jqXHR object will be used)
							transport = undefined;

							// Cache response headers
							responseHeadersString = headers || "";

							// Set readyState
							jqXHR.readyState = status > 0 ? 4 : 0;

							// Get response data
							if (responses) {
								response = ajaxHandleResponses(s, jqXHR, responses);
							}

							// If successful, handle type chaining
							if (status >= 200 && status < 300 || status === 304) {

								// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
								if (s.ifModified) {
									modified = jqXHR.getResponseHeader("Last-Modified");
									if (modified) {
										jQuery.lastModified[cacheURL] = modified;
									}
									modified = jqXHR.getResponseHeader("etag");
									if (modified) {
										jQuery.etag[cacheURL] = modified;
									}
								}

								// if no content
								if (status === 204) {
									isSuccess = true;
									statusText = "nocontent";

									// if not modified
								} else if (status === 304) {
									isSuccess = true;
									statusText = "notmodified";

									// If we have data, let's convert it
								} else {
									isSuccess = ajaxConvert(s, response);
									statusText = isSuccess.state;
									success = isSuccess.data;
									error = isSuccess.error;
									isSuccess = !error;
								}
							} else {
								// We extract error from statusText
								// then normalize statusText and status for non-aborts
								error = statusText;
								if (status || !statusText) {
									statusText = "error";
									if (status < 0) {
										status = 0;
									}
								}
							}

							// Set data for the fake xhr object
							jqXHR.status = status;
							jqXHR.statusText = (nativeStatusText || statusText ) + "";

							// Success/Error
							if (isSuccess) {
								deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
							} else {
								deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
							}

							// Status-dependent callbacks
							jqXHR.statusCode(statusCode);
							statusCode = undefined;

							if (fireGlobals) {
								globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
							}

							// Complete
							completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

							if (fireGlobals) {
								globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
								// Handle the global AJAX counter
								if (!(--jQuery.active )) {
									jQuery.event.trigger("ajaxStop");
								}
							}
						}

						return jqXHR;
					},

					getScript : function(url, callback) {
						return jQuery.get(url, undefined, callback, "script");
					},

					getJSON : function(url, data, callback) {
						return jQuery.get(url, data, callback, "json");
					}
				});

				/* Handles responses to an ajax request:
				 * - sets all responseXXX fields accordingly
				 * - finds the right dataType (mediates between content-type and expected dataType)
				 * - returns the corresponding response
				 */
				function ajaxHandleResponses(s, jqXHR, responses) {
					var firstDataType,
					    ct,
					    finalDataType,
					    type,
					    contents = s.contents,
					    dataTypes = s.dataTypes,
					    responseFields = s.responseFields;

					// Fill responseXXX fields
					for (type in responseFields ) {
						if ( type in responses) {
							jqXHR[responseFields[type]] = responses[type];
						}
					}

					// Remove auto dataType and get content-type in the process
					while (dataTypes[0] === "*") {
						dataTypes.shift();
						if (ct === undefined) {
							ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
						}
					}

					// Check if we're dealing with a known content-type
					if (ct) {
						for (type in contents ) {
							if (contents[type] && contents[type].test(ct)) {
								dataTypes.unshift(type);
								break;
							}
						}
					}

					// Check to see if we have a response for the expected dataType
					if (dataTypes[0] in responses) {
						finalDataType = dataTypes[0];
					} else {
						// Try convertible dataTypes
						for (type in responses ) {
							if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
								finalDataType = type;
								break;
							}
							if (!firstDataType) {
								firstDataType = type;
							}
						}
						// Or just use first one
						finalDataType = finalDataType || firstDataType;
					}

					// If we found a dataType
					// We add the dataType to the list if needed
					// and return the corresponding response
					if (finalDataType) {
						if (finalDataType !== dataTypes[0]) {
							dataTypes.unshift(finalDataType);
						}
						return responses[finalDataType];
					}
				}

				// Chain conversions given the request and the original response
				function ajaxConvert(s, response) {
					var conv2,
					    current,
					    conv,
					    tmp,
					    converters = {},
					    i = 0,
					// Work with a copy of dataTypes in case we need to modify it for conversion
					    dataTypes = s.dataTypes.slice(),
					    prev = dataTypes[0];

					// Apply the dataFilter if provided
					if (s.dataFilter) {
						response = s.dataFilter(response, s.dataType);
					}

					// Create converters map with lowercased keys
					if (dataTypes[1]) {
						for (conv in s.converters ) {
							converters[ conv.toLowerCase()] = s.converters[conv];
						}
					}

					// Convert to each sequential dataType, tolerating list modification
					for (; ( current = dataTypes[++i]); ) {

						// There's only work to do if current dataType is non-auto
						if (current !== "*") {

							// Convert response if prev dataType is non-auto and differs from current
							if (prev !== "*" && prev !== current) {

								// Seek a direct converter
								conv = converters[prev + " " + current] || converters["* " + current];

								// If none found, seek a pair
								if (!conv) {
									for (conv2 in converters ) {

										// If conv2 outputs current
										tmp = conv2.split(" ");
										if (tmp[1] === current) {

											// If prev can be converted to accepted input
											conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
											if (conv) {
												// Condense equivalence converters
												if (conv === true) {
													conv = converters[conv2];

													// Otherwise, insert the intermediate dataType
												} else if (converters[conv2] !== true) {
													current = tmp[0];
													dataTypes.splice(i--, 0, current);
												}

												break;
											}
										}
									}
								}

								// Apply converter (if not an equivalence)
								if (conv !== true) {

									// Unless errors are allowed to bubble, catch and return them
									if (conv && s["throws"]) {
										response = conv(response);
									} else {
										try {
											response = conv(response);
										} catch ( e ) {
											return {
												state : "parsererror",
												error : conv ? e : "No conversion from " + prev + " to " + current
											};
										}
									}
								}
							}

							// Update prev for next iteration
							prev = current;
						}
					}

					return {
						state : "success",
						data : response
					};
				}

				// Install script dataType
				jQuery.ajaxSetup({
					accepts : {
						script : "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
					},
					contents : {
						script : /(?:java|ecma)script/
					},
					converters : {
						"text script" : function(text) {
							jQuery.globalEval(text);
							return text;
						}
					}
				});

				// Handle cache's special case and global
				jQuery.ajaxPrefilter("script", function(s) {
					if (s.cache === undefined) {
						s.cache = false;
					}
					if (s.crossDomain) {
						s.type = "GET";
						s.global = false;
					}
				});

				// Bind script tag hack transport
				jQuery.ajaxTransport("script", function(s) {

					// This transport only deals with cross domain requests
					if (s.crossDomain) {

						var script,
						    head = document.head || jQuery("head")[0] || document.documentElement;

						return {

							send : function(_, callback) {

								script = document.createElement("script");

								script.async = true;

								if (s.scriptCharset) {
									script.charset = s.scriptCharset;
								}

								script.src = s.url;

								// Attach handlers for all browsers
								script.onload = script.onreadystatechange = function(_, isAbort) {

									if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

										// Handle memory leak in IE
										script.onload = script.onreadystatechange = null;

										// Remove the script
										if (script.parentNode) {
											script.parentNode.removeChild(script);
										}

										// Dereference the script
										script = null;

										// Callback if not abort
										if (!isAbort) {
											callback(200, "success");
										}
									}
								};

								// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
								// Use native DOM manipulation to avoid our domManip AJAX trickery
								head.insertBefore(script, head.firstChild);
							},

							abort : function() {
								if (script) {
									script.onload(undefined, true);
								}
							}
						};
					}
				});
				var oldCallbacks = [],
				    rjsonp = /(=)\?(?=&|$)|\?\?/;

				// Default jsonp settings
				jQuery.ajaxSetup({
					jsonp : "callback",
					jsonpCallback : function() {
						var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (ajax_nonce++ ) );
						this[callback] = true;
						return callback;
					}
				});

				// Detect, normalize options and install callbacks for jsonp requests
				jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

					var callbackName,
					    overwritten,
					    responseContainer,
					    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"
					);

					// Handle iff the expected data type is "jsonp" or we have a parameter to set
					if (jsonProp || s.dataTypes[0] === "jsonp") {

						// Get callback name, remembering preexisting value associated with it
						callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

						// Insert callback into url or form data
						if (jsonProp) {
							s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
						} else if (s.jsonp !== false) {
							s.url += (ajax_rquery.test(s.url) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
						}

						// Use data converter to retrieve json after script execution
						s.converters["script json"] = function() {
							if (!responseContainer) {
								jQuery.error(callbackName + " was not called");
							}
							return responseContainer[0];
						};

						// force json dataType
						s.dataTypes[0] = "json";

						// Install callback
						overwritten = window[callbackName];
						window[callbackName] = function() {
							responseContainer = arguments;
						};

						// Clean-up function (fires after converters)
						jqXHR.always(function() {
							// Restore preexisting value
							window[callbackName] = overwritten;

							// Save back as free
							if (s[callbackName]) {
								// make sure that re-using the options doesn't screw things around
								s.jsonpCallback = originalSettings.jsonpCallback;

								// save the callback name for future use
								oldCallbacks.push(callbackName);
							}

							// Call if it was a function and we have a response
							if (responseContainer && jQuery.isFunction(overwritten)) {
								overwritten(responseContainer[0]);
							}

							responseContainer = overwritten = undefined;
						});

						// Delegate to script
						return "script";
					}
				});
				var xhrCallbacks,
				    xhrSupported,
				    xhrId = 0,
				// #5280: Internet Explorer will keep connections alive if we don't abort on unload
				    xhrOnUnloadAbort = window.ActiveXObject &&
				function() {
					// Abort all pending requests
					var key;
					for (key in xhrCallbacks ) {
						xhrCallbacks[ key ](undefined, true);
					}
				};

				// Functions to create xhrs
				function createStandardXHR() {
					try {
						return new window.XMLHttpRequest();
					} catch( e ) {
					}
				}

				function createActiveXHR() {
					try {
						return new window.ActiveXObject("Microsoft.XMLHTTP");
					} catch( e ) {
					}
				}

				// Create the request object
				// (This is still attached to ajaxSettings for backward compatibility)
				jQuery.ajaxSettings.xhr = window.ActiveXObject ?
				/* Microsoft failed to properly
				 * implement the XMLHttpRequest in IE7 (can't request local files),
				 * so we use the ActiveXObject when it is available
				 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
				 * we need a fallback.
				 */
				function() {
					return !this.isLocal && createStandardXHR() || createActiveXHR();
				} :
				// For all other browsers, use the standard XMLHttpRequest object
				createStandardXHR;

				// Determine support properties
				xhrSupported = jQuery.ajaxSettings.xhr();
				jQuery.support.cors = !!xhrSupported && ("withCredentials" in xhrSupported );
				xhrSupported = jQuery.support.ajax = !!xhrSupported;

				// Create transport if the browser can provide an xhr
				if (xhrSupported) {

					jQuery.ajaxTransport(function(s) {
						// Cross domain only allowed if supported through XMLHttpRequest
						if (!s.crossDomain || jQuery.support.cors) {

							var callback;

							return {
								send : function(headers, complete) {

									// Get a new xhr
									var handle,
									    i,
									    xhr = s.xhr();

									// Open the socket
									// Passing null username, generates a login popup on Opera (#2865)
									if (s.username) {
										xhr.open(s.type, s.url, s.async, s.username, s.password);
									} else {
										xhr.open(s.type, s.url, s.async);
									}

									// Apply custom fields if provided
									if (s.xhrFields) {
										for (i in s.xhrFields ) {
											xhr[i] = s.xhrFields[i];
										}
									}

									// Override mime type if needed
									if (s.mimeType && xhr.overrideMimeType) {
										xhr.overrideMimeType(s.mimeType);
									}

									// X-Requested-With header
									// For cross-domain requests, seeing as conditions for a preflight are
									// akin to a jigsaw puzzle, we simply never set it to be sure.
									// (it can always be set on a per-request basis or even using ajaxSetup)
									// For same-domain requests, won't change header if already provided.
									if (!s.crossDomain && !headers["X-Requested-With"]) {
										headers["X-Requested-With"] = "XMLHttpRequest";
									}

									// Need an extra try/catch for cross domain requests in Firefox 3
									try {
										for (i in headers ) {
											xhr.setRequestHeader(i, headers[i]);
										}
									} catch( err ) {
									}

									// Do send the request
									// This may raise an exception which is actually
									// handled in jQuery.ajax (so no try/catch here)
									xhr.send((s.hasContent && s.data ) || null);

									// Listener
									callback = function(_, isAbort) {
										var status,
										    responseHeaders,
										    statusText,
										    responses;

										// Firefox throws exceptions when accessing properties
										// of an xhr when a network error occurred
										// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
										try {

											// Was never called and is aborted or complete
											if (callback && (isAbort || xhr.readyState === 4 )) {

												// Only called once
												callback = undefined;

												// Do not keep as active anymore
												if (handle) {
													xhr.onreadystatechange = jQuery.noop;
													if (xhrOnUnloadAbort) {
														delete xhrCallbacks[handle];
													}
												}

												// If it's an abort
												if (isAbort) {
													// Abort it manually if needed
													if (xhr.readyState !== 4) {
														xhr.abort();
													}
												} else {
													responses = {};
													status = xhr.status;
													responseHeaders = xhr.getAllResponseHeaders();

													// When requesting binary data, IE6-9 will throw an exception
													// on any attempt to access responseText (#11426)
													if ( typeof xhr.responseText === "string") {
														responses.text = xhr.responseText;
													}

													// Firefox throws an exception when accessing
													// statusText for faulty cross-domain requests
													try {
														statusText = xhr.statusText;
													} catch( e ) {
														// We normalize with Webkit giving an empty statusText
														statusText = "";
													}

													// Filter status for non standard behaviors

													// If the request is local and we have data: assume a success
													// (success with no data won't get notified, that's the best we
													// can do given current implementations)
													if (!status && s.isLocal && !s.crossDomain) {
														status = responses.text ? 200 : 404;
														// IE - #1450: sometimes returns 1223 when it should be 204
													} else if (status === 1223) {
														status = 204;
													}
												}
											}
										} catch( firefoxAccessException ) {
											if (!isAbort) {
												complete(-1, firefoxAccessException);
											}
										}

										// Call complete if needed
										if (responses) {
											complete(status, statusText, responses, responseHeaders);
										}
									};

									if (!s.async) {
										// if we're in sync mode we fire the callback
										callback();
									} else if (xhr.readyState === 4) {
										// (IE6 & IE7) if it's in cache and has been
										// retrieved directly we need to fire the callback
										setTimeout(callback);
									} else {
										handle = ++xhrId;
										if (xhrOnUnloadAbort) {
											// Create the active xhrs callbacks list if needed
											// and attach the unload handler
											if (!xhrCallbacks) {
												xhrCallbacks = {};
												jQuery(window).unload(xhrOnUnloadAbort);
											}
											// Add to list of active xhrs callbacks
											xhrCallbacks[handle] = callback;
										}
										xhr.onreadystatechange = callback;
									}
								},

								abort : function() {
									if (callback) {
										callback(undefined, true);
									}
								}
							};
						}
					});
				}
				var fxNow,
				    timerId,
				    rfxtypes = /^(?:toggle|show|hide)$/,
				    rfxnum = new RegExp("^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
				    rrun = /queueHooks$/,
				    animationPrefilters = [defaultPrefilter],
				    tweeners = {
					"*" : [
					function(prop, value) {
						var end,
						    unit,
						    tween = this.createTween(prop, value),
						    parts = rfxnum.exec(value),
						    target = tween.cur(),
						    start = +target || 0,
						    scale = 1,
						    maxIterations = 20;

						if (parts) {
							end = +parts[2];
							unit = parts[3] || (jQuery.cssNumber[prop] ? "" : "px" );

							// We need to compute starting value
							if (unit !== "px" && start) {
								// Iteratively approximate from a nonzero starting point
								// Prefer the current property, because this process will be trivial if it uses the same units
								// Fallback to end or a simple constant
								start = jQuery.css(tween.elem, prop, true) || end || 1;

								do {
									// If previous iteration zeroed out, double until we get *something*
									// Use a string for doubling factor so we don't accidentally see scale as unchanged below
									scale = scale || ".5";

									// Adjust and apply
									start = start / scale;
									jQuery.style(tween.elem, prop, start + unit);

									// Update scale, tolerating zero or NaN from tween.cur()
									// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
								} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
							}

							tween.unit = unit;
							tween.start = start;
							// If a +=/-= token was provided, we're doing a relative animation
							tween.end = parts[1] ? start + (parts[1] + 1 ) * end : end;
						}
						return tween;
					}]

				};

				// Animations created synchronously will run synchronously
				function createFxNow() {
					setTimeout(function() {
						fxNow = undefined;
					});
					return ( fxNow = jQuery.now() );
				}

				function createTweens(animation, props) {
					jQuery.each(props, function(prop, value) {
						var collection = (tweeners[prop] || [] ).concat(tweeners["*"]),
						    index = 0,
						    length = collection.length;
						for (; index < length; index++) {
							if (collection[index].call(animation, prop, value)) {

								// we're done with this property
								return;
							}
						}
					});
				}

				function Animation(elem, properties, options) {
					var result,
					    stopped,
					    index = 0,
					    length = animationPrefilters.length,
					    deferred = jQuery.Deferred().always(function() {
						// don't match elem in the :animated selector
						delete tick.elem;
					}),
					    tick = function() {
						if (stopped) {
							return false;
						}
						var currentTime = fxNow || createFxNow(),
						    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
						// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
						    temp = remaining / animation.duration || 0,
						    percent = 1 - temp,
						    index = 0,
						    length = animation.tweens.length;

						for (; index < length; index++) {
							animation.tweens[index].run(percent);
						}

						deferred.notifyWith(elem, [animation, percent, remaining]);

						if (percent < 1 && length) {
							return remaining;
						} else {
							deferred.resolveWith(elem, [animation]);
							return false;
						}
					},
					    animation = deferred.promise({
						elem : elem,
						props : jQuery.extend({}, properties),
						opts : jQuery.extend(true, {
							specialEasing : {}
						}, options),
						originalProperties : properties,
						originalOptions : options,
						startTime : fxNow || createFxNow(),
						duration : options.duration,
						tweens : [],
						createTween : function(prop, end) {
							var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
							animation.tweens.push(tween);
							return tween;
						},
						stop : function(gotoEnd) {
							var index = 0,
							// if we are going to the end, we want to run all the tweens
							// otherwise we skip this part
							    length = gotoEnd ? animation.tweens.length : 0;
							if (stopped) {
								return this;
							}
							stopped = true;
							for (; index < length; index++) {
								animation.tweens[index].run(1);
							}

							// resolve when we played the last frame
							// otherwise, reject
							if (gotoEnd) {
								deferred.resolveWith(elem, [animation, gotoEnd]);
							} else {
								deferred.rejectWith(elem, [animation, gotoEnd]);
							}
							return this;
						}
					}),
					    props = animation.props;

					propFilter(props, animation.opts.specialEasing);

					for (; index < length; index++) {
						result = animationPrefilters[index].call(animation, elem, props, animation.opts);
						if (result) {
							return result;
						}
					}

					createTweens(animation, props);

					if (jQuery.isFunction(animation.opts.start)) {
						animation.opts.start.call(elem, animation);
					}

					jQuery.fx.timer(jQuery.extend(tick, {
						elem : elem,
						anim : animation,
						queue : animation.opts.queue
					}));

					// attach callbacks from options
					return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
				}

				function propFilter(props, specialEasing) {
					var value,
					    name,
					    index,
					    easing,
					    hooks;

					// camelCase, specialEasing and expand cssHook pass
					for (index in props ) {
						name = jQuery.camelCase(index);
						easing = specialEasing[name];
						value = props[index];
						if (jQuery.isArray(value)) {
							easing = value[1];
							value = props[index] = value[0];
						}

						if (index !== name) {
							props[name] = value;
							delete props[index];
						}

						hooks = jQuery.cssHooks[name];
						if (hooks && "expand" in hooks) {
							value = hooks.expand(value);
							delete props[name];

							// not quite $.extend, this wont overwrite keys already present.
							// also - reusing 'index' from above because we have the correct "name"
							for (index in value ) {
								if (!( index in props )) {
									props[index] = value[index];
									specialEasing[index] = easing;
								}
							}
						} else {
							specialEasing[name] = easing;
						}
					}
				}


				jQuery.Animation = jQuery.extend(Animation, {

					tweener : function(props, callback) {
						if (jQuery.isFunction(props)) {
							callback = props;
							props = ["*"];
						} else {
							props = props.split(" ");
						}

						var prop,
						    index = 0,
						    length = props.length;

						for (; index < length; index++) {
							prop = props[index];
							tweeners[prop] = tweeners[prop] || [];
							tweeners[prop].unshift(callback);
						}
					},

					prefilter : function(callback, prepend) {
						if (prepend) {
							animationPrefilters.unshift(callback);
						} else {
							animationPrefilters.push(callback);
						}
					}
				});

				function defaultPrefilter(elem, props, opts) {
					/*jshint validthis:true */
					var prop,
					    index,
					    length,
					    value,
					    dataShow,
					    toggle,
					    tween,
					    hooks,
					    oldfire,
					    anim = this,
					    style = elem.style,
					    orig = {},
					    handled = [],
					    hidden = elem.nodeType && isHidden(elem);

					// handle queue: false promises
					if (!opts.queue) {
						hooks = jQuery._queueHooks(elem, "fx");
						if (hooks.unqueued == null) {
							hooks.unqueued = 0;
							oldfire = hooks.empty.fire;
							hooks.empty.fire = function() {
								if (!hooks.unqueued) {
									oldfire();
								}
							};
						}
						hooks.unqueued++;

						anim.always(function() {
							// doing this makes sure that the complete handler will be called
							// before this completes
							anim.always(function() {
								hooks.unqueued--;
								if (!jQuery.queue(elem, "fx").length) {
									hooks.empty.fire();
								}
							});
						});
					}

					// height/width overflow pass
					if (elem.nodeType === 1 && ("height" in props || "width" in props )) {
						// Make sure that nothing sneaks out
						// Record all 3 overflow attributes because IE does not
						// change the overflow attribute when overflowX and
						// overflowY are set to the same value
						opts.overflow = [style.overflow, style.overflowX, style.overflowY];

						// Set display property to inline-block for height/width
						// animations on inline elements that are having width/height animated
						if (jQuery.css(elem, "display") === "inline" && jQuery.css(elem, "float") === "none") {

							// inline-level elements accept inline-block;
							// block-level elements need to be inline with layout
							if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === "inline") {
								style.display = "inline-block";

							} else {
								style.zoom = 1;
							}
						}
					}

					if (opts.overflow) {
						style.overflow = "hidden";
						if (!jQuery.support.shrinkWrapBlocks) {
							anim.always(function() {
								style.overflow = opts.overflow[0];
								style.overflowX = opts.overflow[1];
								style.overflowY = opts.overflow[2];
							});
						}
					}

					// show/hide pass
					for (index in props ) {
						value = props[index];
						if (rfxtypes.exec(value)) {
							delete props[index];
							toggle = toggle || value === "toggle";
							if (value === ( hidden ? "hide" : "show" )) {
								continue;
							}
							handled.push(index);
						}
					}

					length = handled.length;
					if (length) {
						dataShow = jQuery._data(elem, "fxshow") || jQuery._data(elem, "fxshow", {});
						if ("hidden" in dataShow) {
							hidden = dataShow.hidden;
						}

						// store state if its toggle - enables .stop().toggle() to "reverse"
						if (toggle) {
							dataShow.hidden = !hidden;
						}
						if (hidden) {
							jQuery(elem).show();
						} else {
							anim.done(function() {
								jQuery(elem).hide();
							});
						}
						anim.done(function() {
							var prop;
							jQuery._removeData(elem, "fxshow");
							for (prop in orig ) {
								jQuery.style(elem, prop, orig[prop]);
							}
						});
						for ( index = 0; index < length; index++) {
							prop = handled[index];
							tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);
							orig[prop] = dataShow[prop] || jQuery.style(elem, prop);

							if (!( prop in dataShow )) {
								dataShow[prop] = tween.start;
								if (hidden) {
									tween.end = tween.start;
									tween.start = prop === "width" || prop === "height" ? 1 : 0;
								}
							}
						}
					}
				}

				function Tween(elem, options, prop, end, easing) {
					return new Tween.prototype.init(elem, options, prop, end, easing);
				}


				jQuery.Tween = Tween;

				Tween.prototype = {
					constructor : Tween,
					init : function(elem, options, prop, end, easing, unit) {
						this.elem = elem;
						this.prop = prop;
						this.easing = easing || "swing";
						this.options = options;
						this.start = this.now = this.cur();
						this.end = end;
						this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px" );
					},
					cur : function() {
						var hooks = Tween.propHooks[this.prop];

						return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
					},
					run : function(percent) {
						var eased,
						    hooks = Tween.propHooks[this.prop];

						if (this.options.duration) {
							this.pos = eased = jQuery.easing[ this.easing ](percent, this.options.duration * percent, 0, 1, this.options.duration);
						} else {
							this.pos = eased = percent;
						}
						this.now = (this.end - this.start ) * eased + this.start;

						if (this.options.step) {
							this.options.step.call(this.elem, this.now, this);
						}

						if (hooks && hooks.set) {
							hooks.set(this);
						} else {
							Tween.propHooks._default.set(this);
						}
						return this;
					}
				};

				Tween.prototype.init.prototype = Tween.prototype;

				Tween.propHooks = {
					_default : {
						get : function(tween) {
							var result;

							if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
								return tween.elem[tween.prop];
							}

							// passing an empty string as a 3rd parameter to .css will automatically
							// attempt a parseFloat and fallback to a string if the parse fails
							// so, simple values such as "10px" are parsed to Float.
							// complex values such as "rotate(1rad)" are returned as is.
							result = jQuery.css(tween.elem, tween.prop, "");
							// Empty strings, null, undefined and "auto" are converted to 0.
							return !result || result === "auto" ? 0 : result;
						},
						set : function(tween) {
							// use step hook for back compat - use cssHook if its there - use .style if its
							// available and use plain properties where available
							if (jQuery.fx.step[tween.prop]) {
								jQuery.fx.step[ tween.prop ](tween);
							} else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop] )) {
								jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
							} else {
								tween.elem[tween.prop] = tween.now;
							}
						}
					}
				};

				// Remove in 2.0 - this supports IE8's panic based approach
				// to setting things on disconnected nodes

				Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
					set : function(tween) {
						if (tween.elem.nodeType && tween.elem.parentNode) {
							tween.elem[tween.prop] = tween.now;
						}
					}
				};

				jQuery.each(["toggle", "show", "hide"], function(i, name) {
					var cssFn = jQuery.fn[name];
					jQuery.fn[name] = function(speed, easing, callback) {
						return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
					};
				});

				jQuery.fn.extend({
					fadeTo : function(speed, to, easing, callback) {

						// show any hidden elements after setting opacity to 0
						return this.filter(isHidden).css("opacity", 0).show()

						// animate to the value specified
						.end().animate({
							opacity : to
						}, speed, easing, callback);
					},
					animate : function(prop, speed, easing, callback) {
						var empty = jQuery.isEmptyObject(prop),
						    optall = jQuery.speed(speed, easing, callback),
						    doAnimation = function() {
							// Operate on a copy of prop so per-property easing won't be lost
							var anim = Animation(this, jQuery.extend({}, prop), optall);
							doAnimation.finish = function() {
								anim.stop(true);
							};
							// Empty animations, or finishing resolves immediately
							if (empty || jQuery._data(this, "finish")) {
								anim.stop(true);
							}
						};
						doAnimation.finish = doAnimation;

						return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
					},
					stop : function(type, clearQueue, gotoEnd) {
						var stopQueue = function(hooks) {
							var stop = hooks.stop;
							delete hooks.stop;
							stop(gotoEnd);
						};

						if ( typeof type !== "string") {
							gotoEnd = clearQueue;
							clearQueue = type;
							type = undefined;
						}
						if (clearQueue && type !== false) {
							this.queue(type || "fx", []);
						}

						return this.each(function() {
							var dequeue = true,
							    index = type != null && type + "queueHooks",
							    timers = jQuery.timers,
							    data = jQuery._data(this);

							if (index) {
								if (data[index] && data[index].stop) {
									stopQueue(data[index]);
								}
							} else {
								for (index in data ) {
									if (data[index] && data[index].stop && rrun.test(index)) {
										stopQueue(data[index]);
									}
								}
							}

							for ( index = timers.length; index--; ) {
								if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
									timers[index].anim.stop(gotoEnd);
									dequeue = false;
									timers.splice(index, 1);
								}
							}

							// start the next in the queue if the last step wasn't forced
							// timers currently will call their complete callbacks, which will dequeue
							// but only if they were gotoEnd
							if (dequeue || !gotoEnd) {
								jQuery.dequeue(this, type);
							}
						});
					},
					finish : function(type) {
						if (type !== false) {
							type = type || "fx";
						}
						return this.each(function() {
							var index,
							    data = jQuery._data(this),
							    queue = data[type + "queue"],
							    hooks = data[type + "queueHooks"],
							    timers = jQuery.timers,
							    length = queue ? queue.length : 0;

							// enable finishing flag on private data
							data.finish = true;

							// empty the queue first
							jQuery.queue(this, type, []);

							if (hooks && hooks.cur && hooks.cur.finish) {
								hooks.cur.finish.call(this);
							}

							// look for any active animations, and finish them
							for ( index = timers.length; index--; ) {
								if (timers[index].elem === this && timers[index].queue === type) {
									timers[index].anim.stop(true);
									timers.splice(index, 1);
								}
							}

							// look for any animations in the old queue and finish them
							for ( index = 0; index < length; index++) {
								if (queue[index] && queue[index].finish) {
									queue[index].finish.call(this);
								}
							}

							// turn off finishing flag
							delete data.finish;
						});
					}
				});

				// Generate parameters to create a standard animation
				function genFx(type, includeWidth) {
					var which,
					    attrs = {
						height : type
					},
					    i = 0;

					// if we include width, step value is 1 to do all cssExpand values,
					// if we don't include width, step value is 2 to skip over Left and Right
					includeWidth = includeWidth ? 1 : 0;
					for (; i < 4; i += 2 - includeWidth) {
						which = cssExpand[i];
						attrs["margin" + which] = attrs["padding" + which] = type;
					}

					if (includeWidth) {
						attrs.opacity = attrs.width = type;
					}

					return attrs;
				}

				// Generate shortcuts for custom animations
				jQuery.each({
					slideDown : genFx("show"),
					slideUp : genFx("hide"),
					slideToggle : genFx("toggle"),
					fadeIn : {
						opacity : "show"
					},
					fadeOut : {
						opacity : "hide"
					},
					fadeToggle : {
						opacity : "toggle"
					}
				}, function(name, props) {
					jQuery.fn[name] = function(speed, easing, callback) {
						return this.animate(props, speed, easing, callback);
					};
				});

				jQuery.speed = function(speed, easing, fn) {
					var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
						complete : fn || !fn && easing || jQuery.isFunction(speed) && speed,
						duration : speed,
						easing : fn && easing || easing && !jQuery.isFunction(easing) && easing
					};

					opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

					// normalize opt.queue - true/undefined/null -> "fx"
					if (opt.queue == null || opt.queue === true) {
						opt.queue = "fx";
					}

					// Queueing
					opt.old = opt.complete;

					opt.complete = function() {
						if (jQuery.isFunction(opt.old)) {
							opt.old.call(this);
						}

						if (opt.queue) {
							jQuery.dequeue(this, opt.queue);
						}
					};

					return opt;
				};

				jQuery.easing = {
					linear : function(p) {
						return p;
					},
					swing : function(p) {
						return 0.5 - Math.cos(p * Math.PI) / 2;
					}
				};

				jQuery.timers = [];
				jQuery.fx = Tween.prototype.init;
				jQuery.fx.tick = function() {
					var timer,
					    timers = jQuery.timers,
					    i = 0;

					fxNow = jQuery.now();

					for (; i < timers.length; i++) {
						timer = timers[i];
						// Checks the timer has not already been removed
						if (!timer() && timers[i] === timer) {
							timers.splice(i--, 1);
						}
					}

					if (!timers.length) {
						jQuery.fx.stop();
					}
					fxNow = undefined;
				};

				jQuery.fx.timer = function(timer) {
					if (timer() && jQuery.timers.push(timer)) {
						jQuery.fx.start();
					}
				};

				jQuery.fx.interval = 13;

				jQuery.fx.start = function() {
					if (!timerId) {
						timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
					}
				};

				jQuery.fx.stop = function() {
					clearInterval(timerId);
					timerId = null;
				};

				jQuery.fx.speeds = {
					slow : 600,
					fast : 200,
					// Default speed
					_default : 400
				};

				// Back Compat <1.8 extension point
				jQuery.fx.step = {};

				if (jQuery.expr && jQuery.expr.filters) {
					jQuery.expr.filters.animated = function(elem) {
						return jQuery.grep(jQuery.timers, function(fn) {
							return elem === fn.elem;
						}).length;
					};
				}
				jQuery.fn.offset = function(options) {
					if (arguments.length) {
						return options === undefined ? this : this.each(function(i) {
							jQuery.offset.setOffset(this, options, i);
						});
					}

					var docElem,
					    win,
					    box = {
						top : 0,
						left : 0
					},
					    elem = this[0],
					    doc = elem && elem.ownerDocument;

					if (!doc) {
						return;
					}

					docElem = doc.documentElement;

					// Make sure it's not a disconnected DOM node
					if (!jQuery.contains(docElem, elem)) {
						return box;
					}

					// If we don't have gBCR, just use 0,0 rather than error
					// BlackBerry 5, iOS 3 (original iPhone)
					if ( typeof elem.getBoundingClientRect !== core_strundefined) {
						box = elem.getBoundingClientRect();
					}
					win = getWindow(doc);
					return {
						top : box.top + (win.pageYOffset || docElem.scrollTop ) - (docElem.clientTop || 0 ),
						left : box.left + (win.pageXOffset || docElem.scrollLeft ) - (docElem.clientLeft || 0 )
					};
				};

				jQuery.offset = {

					setOffset : function(elem, options, i) {
						var position = jQuery.css(elem, "position");

						// set position first, in-case top/left are set even on static elem
						if (position === "static") {
							elem.style.position = "relative";
						}

						var curElem = jQuery(elem),
						    curOffset = curElem.offset(),
						    curCSSTop = jQuery.css(elem, "top"),
						    curCSSLeft = jQuery.css(elem, "left"),
						    calculatePosition = (position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
						    props = {},
						    curPosition = {},
						    curTop,
						    curLeft;

						// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
						if (calculatePosition) {
							curPosition = curElem.position();
							curTop = curPosition.top;
							curLeft = curPosition.left;
						} else {
							curTop = parseFloat(curCSSTop) || 0;
							curLeft = parseFloat(curCSSLeft) || 0;
						}

						if (jQuery.isFunction(options)) {
							options = options.call(elem, i, curOffset);
						}

						if (options.top != null) {
							props.top = (options.top - curOffset.top ) + curTop;
						}
						if (options.left != null) {
							props.left = (options.left - curOffset.left ) + curLeft;
						}

						if ("using" in options) {
							options.using.call(elem, props);
						} else {
							curElem.css(props);
						}
					}
				};

				jQuery.fn.extend({

					position : function() {
						if (!this[0]) {
							return;
						}

						var offsetParent,
						    offset,
						    parentOffset = {
							top : 0,
							left : 0
						},
						    elem = this[0];

						// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
						if (jQuery.css(elem, "position") === "fixed") {
							// we assume that getBoundingClientRect is available when computed position is fixed
							offset = elem.getBoundingClientRect();
						} else {
							// Get *real* offsetParent
							offsetParent = this.offsetParent();

							// Get correct offsets
							offset = this.offset();
							if (!jQuery.nodeName(offsetParent[0], "html")) {
								parentOffset = offsetParent.offset();
							}

							// Add offsetParent borders
							parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
							parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
						}

						// Subtract parent offsets and element margins
						// note: when an element has margin: auto the offsetLeft and marginLeft
						// are the same in Safari causing offset.left to incorrectly be 0
						return {
							top : offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
							left : offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
						};
					},

					offsetParent : function() {
						return this.map(function() {
							var offsetParent = this.offsetParent || document.documentElement;
							while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static" )) {
								offsetParent = offsetParent.offsetParent;
							}
							return offsetParent || document.documentElement;
						});
					}
				});

				// Create scrollLeft and scrollTop methods
				jQuery.each({
					scrollLeft : "pageXOffset",
					scrollTop : "pageYOffset"
				}, function(method, prop) {
					var top = /Y/.test(prop);

					jQuery.fn[method] = function(val) {
						return jQuery.access(this, function(elem, method, val) {
							var win = getWindow(elem);

							if (val === undefined) {
								return win ? ( prop in win) ? win[prop] : win.document.documentElement[method] : elem[method];
							}

							if (win) {
								win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());

							} else {
								elem[method] = val;
							}
						}, method, val, arguments.length, null);
					};
				});

				function getWindow(elem) {
					return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
				}

				// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
				jQuery.each({
					Height : "height",
					Width : "width"
				}, function(name, type) {
					jQuery.each({
						padding : "inner" + name,
						content : type,
						"" : "outer" + name
					}, function(defaultExtra, funcName) {
						// margin is only for outerHeight, outerWidth
						jQuery.fn[funcName] = function(margin, value) {
							var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean" ),
							    extra = defaultExtra || (margin === true || value === true ? "margin" : "border" );

							return jQuery.access(this, function(elem, type, value) {
								var doc;

								if (jQuery.isWindow(elem)) {
									// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
									// isn't a whole lot we can do. See pull request at this URL for discussion:
									// https://github.com/jquery/jquery/pull/764
									return elem.document.documentElement["client" + name];
								}

								// Get document width or height
								if (elem.nodeType === 9) {
									doc = elem.documentElement;

									// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
									// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
									return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
								}

								return value === undefined ?
								// Get width or height on the element, requesting but not forcing parseFloat
								jQuery.css(elem, type, extra) :

								// Set width or height on the element
								jQuery.style(elem, type, value, extra);
							}, type, chainable ? margin : undefined, chainable, null);
						};
					});
				});
				// Limit scope pollution from any deprecated API
				// (function() {

				// })();
				// Expose jQuery to the global object
				window.jQuery = window.$ = jQuery;

				// Expose jQuery as an AMD module, but only for AMD loaders that
				// understand the issues with loading multiple versions of jQuery
				// in a page that all might call define(). The loader will indicate
				// they have special allowances for multiple jQuery versions by
				// specifying define.amd.jQuery = true. Register as a named module,
				// since jQuery can be concatenated with other files that may use define,
				// but not use a proper concatenation script that understands anonymous
				// AMD modules. A named AMD is safest and most robust way to register.
				// Lowercase jquery is used because AMD module names are derived from
				// file names, and jQuery is normally delivered in a lowercase file name.
				// Do this after creating the global so that if an AMD module wants to call
				// noConflict to hide this version of jQuery, it will work.
				if ( typeof define === "function" && define.amd && define.amd.jQuery) {
					define("jquery", [], function() {
						return jQuery;
					});
				}

			})(window);
		</script>

		<!-- spectrum color picker code -->
		<script>
			//contents of spectrum.js script:

			// Spectrum Colorpicker v1.5.1
			// https://github.com/bgrins/spectrum
			// Author: Brian Grinstead
			// License: MIT

			(function(window, $, undefined) {
				"use strict";

				var defaultOpts = {

					// Callbacks
					beforeShow : noop,
					move : noop,
					change : noop,
					show : noop,
					hide : noop,

					// Options
					color : false,
					flat : false,
					showInput : false,
					allowEmpty : false,
					showButtons : true,
					clickoutFiresChange : false,
					showInitial : false,
					showPalette : false,
					showPaletteOnly : false,
					hideAfterPaletteSelect : false,
					togglePaletteOnly : false,
					showSelectionPalette : true,
					localStorageKey : false,
					appendTo : "body",
					maxSelectionSize : 7,
					cancelText : "cancel",
					chooseText : "choose",
					togglePaletteMoreText : "more",
					togglePaletteLessText : "less",
					clearText : "Clear Color Selection",
					noColorSelectedText : "No Color Selected",
					preferredFormat : false,
					className : "", // Deprecated - use containerClassName and replacerClassName instead.
					containerClassName : "",
					replacerClassName : "",
					showAlpha : false,
					theme : "sp-light",
					palette : [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]],
					selectionPalette : [],
					disabled : false
				},
				    spectrums = [],
				    IE = !!/msie/i.exec(window.navigator.userAgent),
				    rgbaSupport = (function() {
					function contains(str, substr) {
						return !!~('' + str).indexOf(substr);
					}

					var elem = document.createElement('div');
					var style = elem.style;
					style.cssText = 'background-color:rgba(0,0,0,.5)';
					return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
				})(),
				    inputTypeColorSupport = (function() {
					var colorInput = $("<input type='color' value='!' />")[0];
					return colorInput.type === "color" && colorInput.value !== "!";
				})(),
				    replaceInput = ["<div class='sp-replacer'>", "<div class='sp-preview'><div class='sp-preview-inner'></div></div>", "<div class='sp-dd'>&#9660;</div>", "</div>"].join(''),
				    markup = (function() {

					// IE does not support gradients with multiple stops, so we need to simulate
					//  that for the rainbow slider with 8 divs that each have a single gradient
					var gradientFix = "";
					if (IE) {
						for (var i = 1; i <= 6; i++) {
							gradientFix += "<div class='sp-" + i + "'></div>";
						}
					}

					return ["<div class='sp-container sp-hidden'>", "<div class='sp-palette-container'>", "<div class='sp-palette sp-thumb sp-cf'></div>", "<div class='sp-palette-button-container sp-cf'>", "<button type='button' class='sp-palette-toggle'></button>", "</div>", "</div>", "<div class='sp-picker-container'>", "<div class='sp-top sp-cf'>", "<div class='sp-fill'></div>", "<div class='sp-top-inner'>", "<div class='sp-color'>", "<div class='sp-sat'>", "<div class='sp-val'>", "<div class='sp-dragger'></div>", "</div>", "</div>", "</div>", "<div class='sp-clear sp-clear-display'>", "</div>", "<div class='sp-hue'>", "<div class='sp-slider'></div>", gradientFix, "</div>", "</div>", "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>", "</div>", "<div class='sp-input-container sp-cf'>", "<input class='sp-input' type='text' spellcheck='false'  />", "</div>", "<div class='sp-initial sp-thumb sp-cf'></div>", "<div class='sp-button-container sp-cf'>", "<a class='sp-cancel' href='#'></a>", "<button type='button' class='sp-choose'></button>", "</div>", "</div>", "</div>"].join("");
				})();

				function paletteTemplate(p, color, className, opts) {
					var html = [];
					for (var i = 0; i < p.length; i++) {
						var current = p[i];
						if (current) {
							var tiny = tinycolor(current);
							var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
							c += (tinycolor.equals(color, current)) ? " sp-thumb-active" : "";
							var formattedString = tiny.toString(opts.preferredFormat || "rgb");
							var swatchStyle = rgbaSupport ? ("background-color:" + tiny.toRgbString()) : "filter:" + tiny.toFilter();
							html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
						} else {
							var cls = 'sp-clear-display';
							html.push($('<div />').append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>').attr('title', opts.noColorSelectedText)).html());
						}
					}
					return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
				}

				function hideAll() {
					for (var i = 0; i < spectrums.length; i++) {
						if (spectrums[i]) {
							spectrums[i].hide();
						}
					}
				}

				function instanceOptions(o, callbackContext) {
					var opts = $.extend({}, defaultOpts, o);
					opts.callbacks = {
						'move' : bind(opts.move, callbackContext),
						'change' : bind(opts.change, callbackContext),
						'show' : bind(opts.show, callbackContext),
						'hide' : bind(opts.hide, callbackContext),
						'beforeShow' : bind(opts.beforeShow, callbackContext)
					};

					return opts;
				}

				function spectrum(element, o) {

					var opts = instanceOptions(o, element),
					    flat = opts.flat,
					    showSelectionPalette = opts.showSelectionPalette,
					    localStorageKey = opts.localStorageKey,
					    theme = opts.theme,
					    callbacks = opts.callbacks,
					    resize = throttle(reflow, 10),
					    visible = false,
					    dragWidth = 0,
					    dragHeight = 0,
					    dragHelperHeight = 0,
					    slideHeight = 0,
					    slideWidth = 0,
					    alphaWidth = 0,
					    alphaSlideHelperWidth = 0,
					    slideHelperHeight = 0,
					    currentHue = 0,
					    currentSaturation = 0,
					    currentValue = 0,
					    currentAlpha = 1,
					    palette = [],
					    paletteArray = [],
					    paletteLookup = {},
					    selectionPalette = opts.selectionPalette.slice(0),
					    maxSelectionSize = opts.maxSelectionSize,
					    draggingClass = "sp-dragging",
					    shiftMovementDirection = null;

					var doc = element.ownerDocument,
					    body = doc.body,
					    boundElement = $(element),
					    disabled = false,
					    container = $(markup, doc).addClass(theme),
					    pickerContainer = container.find(".sp-picker-container"),
					    dragger = container.find(".sp-color"),
					    dragHelper = container.find(".sp-dragger"),
					    slider = container.find(".sp-hue"),
					    slideHelper = container.find(".sp-slider"),
					    alphaSliderInner = container.find(".sp-alpha-inner"),
					    alphaSlider = container.find(".sp-alpha"),
					    alphaSlideHelper = container.find(".sp-alpha-handle"),
					    textInput = container.find(".sp-input"),
					    paletteContainer = container.find(".sp-palette"),
					    initialColorContainer = container.find(".sp-initial"),
					    cancelButton = container.find(".sp-cancel"),
					    clearButton = container.find(".sp-clear"),
					    chooseButton = container.find(".sp-choose"),
					    toggleButton = container.find(".sp-palette-toggle"),
					    isInput = boundElement.is("input"),
					    isInputTypeColor = isInput && inputTypeColorSupport && boundElement.attr("type") === "color",
					    shouldReplace = isInput && !flat,
					    replacer = (shouldReplace) ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $([]),
					    offsetElement = (shouldReplace) ? replacer : boundElement,
					    previewElement = replacer.find(".sp-preview-inner"),
					    initialColor = opts.color || (isInput && boundElement.val()),
					    colorOnShow = false,
					    preferredFormat = opts.preferredFormat,
					    currentPreferredFormat =
					    preferredFormat,
					    clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange,
					    isEmpty = !initialColor,
					    allowEmpty = opts.allowEmpty && !isInputTypeColor;

					function applyOptions() {

						if (opts.showPaletteOnly) {
							opts.showPalette = true;
						}

						toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);

						if (opts.palette) {
							palette = opts.palette.slice(0);
							paletteArray = $.isArray(palette[0]) ? palette : [palette];
							paletteLookup = {};
							for (var i = 0; i < paletteArray.length; i++) {
								for (var j = 0; j < paletteArray[i].length; j++) {
									var rgb = tinycolor(paletteArray[i][j]).toRgbString();
									paletteLookup[rgb] = true;
								}
							}
						}

						container.toggleClass("sp-flat", flat);
						container.toggleClass("sp-input-disabled", !opts.showInput);
						container.toggleClass("sp-alpha-enabled", opts.showAlpha);
						container.toggleClass("sp-clear-enabled", allowEmpty);
						container.toggleClass("sp-buttons-disabled", !opts.showButtons);
						container.toggleClass("sp-palette-buttons-disabled", !opts.togglePaletteOnly);
						container.toggleClass("sp-palette-disabled", !opts.showPalette);
						container.toggleClass("sp-palette-only", opts.showPaletteOnly);
						container.toggleClass("sp-initial-disabled", !opts.showInitial);
						container.addClass(opts.className).addClass(opts.containerClassName);

						reflow();
					}

					function initialize() {

						if (IE) {
							container.find("*:not(input)").attr("unselectable", "on");
						}

						applyOptions();

						if (shouldReplace) {
							boundElement.after(replacer).hide();
						}

						if (!allowEmpty) {
							clearButton.hide();
						}

						if (flat) {
							boundElement.after(container).hide();
						} else {

							var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);
							if (appendTo.length !== 1) {
								appendTo = $("body");
							}

							appendTo.append(container);
						}

						updateSelectionPaletteFromStorage();

						offsetElement.bind("click.spectrum touchstart.spectrum", function(e) {
							if (!disabled) {
								toggle();
							}

							e.stopPropagation();

							if (!$(e.target).is("input")) {
								e.preventDefault();
							}
						});

						if (boundElement.is(":disabled") || (opts.disabled === true)) {
							disable();
						}

						// Prevent clicks from bubbling up to document.  This would cause it to be hidden.
						container.click(stopPropagation);

						// Handle user typed input
						textInput.change(setFromTextInput);
						textInput.bind("paste", function() {
							setTimeout(setFromTextInput, 1);
						});
						textInput.keydown(function(e) {
							if (e.keyCode == 13) {
								setFromTextInput();
							}
						});

						cancelButton.text(opts.cancelText);
						cancelButton.bind("click.spectrum", function(e) {
							e.stopPropagation();
							e.preventDefault();
							revert();
							hide();
						});

						clearButton.attr("title", opts.clearText);
						clearButton.bind("click.spectrum", function(e) {
							e.stopPropagation();
							e.preventDefault();
							isEmpty = true;
							move();

							if (flat) {
								//for the flat style, this is a change event
								updateOriginalInput(true);
							}
						});

						chooseButton.text(opts.chooseText);
						chooseButton.bind("click.spectrum", function(e) {
							e.stopPropagation();
							e.preventDefault();

							if (isValid()) {
								updateOriginalInput(true);
								hide();
							}
						});

						toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
						toggleButton.bind("click.spectrum", function(e) {
							e.stopPropagation();
							e.preventDefault();

							opts.showPaletteOnly = !opts.showPaletteOnly;

							// To make sure the Picker area is drawn on the right, next to the
							// Palette area (and not below the palette), first move the Palette
							// to the left to make space for the picker, plus 5px extra.
							// The 'applyOptions' function puts the whole container back into place
							// and takes care of the button-text and the sp-palette-only CSS class.
							if (!opts.showPaletteOnly && !flat) {
								container.css('left', '-=' + (pickerContainer.outerWidth(true) + 5));
							}
							applyOptions();
						});

						draggable(alphaSlider, function(dragX, dragY, e) {
							currentAlpha = (dragX / alphaWidth);
							isEmpty = false;
							if (e.shiftKey) {
								currentAlpha = Math.round(currentAlpha * 10) / 10;
							}

							move();
						}, dragStart, dragStop);

						draggable(slider, function(dragX, dragY) {
							currentHue = parseFloat(dragY / slideHeight);
							isEmpty = false;
							if (!opts.showAlpha) {
								currentAlpha = 1;
							}
							move();
						}, dragStart, dragStop);

						draggable(dragger, function(dragX, dragY, e) {

							// shift+drag should snap the movement to either the x or y axis.
							if (!e.shiftKey) {
								shiftMovementDirection = null;
							} else if (!shiftMovementDirection) {
								var oldDragX = currentSaturation * dragWidth;
								var oldDragY = dragHeight - (currentValue * dragHeight);
								var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);

								shiftMovementDirection = furtherFromX ? "x" : "y";
							}

							var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
							var setValue = !shiftMovementDirection || shiftMovementDirection === "y";

							if (setSaturation) {
								currentSaturation = parseFloat(dragX / dragWidth);
							}
							if (setValue) {
								currentValue = parseFloat((dragHeight - dragY) / dragHeight);
							}

							isEmpty = false;
							if (!opts.showAlpha) {
								currentAlpha = 1;
							}

							move();

						}, dragStart, dragStop);

						if (!!initialColor) {
							set(initialColor);

							// In case color was black - update the preview UI and set the format
							// since the set function will not run (default color is black).
							updateUI();
							currentPreferredFormat = preferredFormat || tinycolor(initialColor).format;

							addColorToSelectionPalette(initialColor);
						} else {
							updateUI();
						}

						if (flat) {
							show();
						}

						function paletteElementClick(e) {
							if (e.data && e.data.ignore) {
								set($(e.target).closest(".sp-thumb-el").data("color"));
								move();
							} else {
								set($(e.target).closest(".sp-thumb-el").data("color"));
								move();
								updateOriginalInput(true);
								if (opts.hideAfterPaletteSelect) {
									hide();
								}
							}

							return false;
						}

						var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
						paletteContainer.delegate(".sp-thumb-el", paletteEvent, paletteElementClick);
						initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, {
							ignore : true
						}, paletteElementClick);
					}

					function updateSelectionPaletteFromStorage() {

						if (localStorageKey && window.localStorage) {

							// Migrate old palettes over to new format.  May want to remove this eventually.
							try {
								var oldPalette = window.localStorage[localStorageKey].split(",#");
								if (oldPalette.length > 1) {
									delete window.localStorage[localStorageKey];
									$.each(oldPalette, function(i, c) {
										addColorToSelectionPalette(c);
									});
								}
							} catch(e) {
							}

							try {
								selectionPalette = window.localStorage[localStorageKey].split(";");
							} catch (e) {
							}
						}
					}

					function addColorToSelectionPalette(color) {
						if (showSelectionPalette) {
							var rgb = tinycolor(color).toRgbString();
							if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {
								selectionPalette.push(rgb);
								while (selectionPalette.length > maxSelectionSize) {
									selectionPalette.shift();
								}
							}

							if (localStorageKey && window.localStorage) {
								try {
									window.localStorage[localStorageKey] = selectionPalette.join(";");
								} catch(e) {
								}
							}
						}
					}

					function getUniqueSelectionPalette() {
						var unique = [];
						if (opts.showPalette) {
							for (var i = 0; i < selectionPalette.length; i++) {
								var rgb = tinycolor(selectionPalette[i]).toRgbString();

								if (!paletteLookup[rgb]) {
									unique.push(selectionPalette[i]);
								}
							}
						}

						return unique.reverse().slice(0, opts.maxSelectionSize);
					}

					function drawPalette() {

						var currentColor = get();

						var html = $.map(paletteArray, function(palette, i) {
							return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i, opts);
						});

						updateSelectionPaletteFromStorage();

						if (selectionPalette) {
							html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));
						}

						paletteContainer.html(html.join(""));
					}

					function drawInitial() {
						if (opts.showInitial) {
							var initial = colorOnShow;
							var current = get();
							initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial", opts));
						}
					}

					function dragStart() {
						if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
							reflow();
						}
						container.addClass(draggingClass);
						shiftMovementDirection = null;
						boundElement.trigger('dragstart.spectrum', [get()]);
					}

					function dragStop() {
						container.removeClass(draggingClass);
						boundElement.trigger('dragstop.spectrum', [get()]);
					}

					function setFromTextInput() {

						var value = textInput.val();

						if ((value === null || value === "") && allowEmpty) {
							set(null);
							updateOriginalInput(true);
						} else {
							var tiny = tinycolor(value);
							if (tiny.isValid()) {
								set(tiny);
								updateOriginalInput(true);
							} else {
								textInput.addClass("sp-validation-error");
							}
						}
					}

					function toggle() {
						if (visible) {
							hide();
						} else {
							show();
						}
					}

					function show() {
						var event = $.Event('beforeShow.spectrum');

						if (visible) {
							reflow();
							return;
						}

						boundElement.trigger(event, [get()]);

						if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
							return;
						}

						hideAll();
						visible = true;

						$(doc).bind("click.spectrum", clickout);
						$(window).bind("resize.spectrum", resize);
						replacer.addClass("sp-active");
						container.removeClass("sp-hidden");

						reflow();
						updateUI();

						colorOnShow = get();

						drawInitial();
						callbacks.show(colorOnShow);
						boundElement.trigger('show.spectrum', [colorOnShow]);
					}

					function clickout(e) {
						// Return on right click.
						if (e && e.type == "click" && e.button == 2) {
							return;
						}

						if (clickoutFiresChange) {
							updateOriginalInput(true);
						} else {
							revert();
						}
						hide();
					}

					function hide() {
						// Return if hiding is unnecessary
						if (!visible || flat) {
							return;
						}
						visible = false;

						$(doc).unbind("click.spectrum", clickout);
						$(window).unbind("resize.spectrum", resize);

						replacer.removeClass("sp-active");
						container.addClass("sp-hidden");

						callbacks.hide(get());
						boundElement.trigger('hide.spectrum', [get()]);
					}

					function revert() {
						set(colorOnShow, true);
					}

					function set(color, ignoreFormatChange) {
						if (tinycolor.equals(color, get())) {
							// Update UI just in case a validation error needs
							// to be cleared.
							updateUI();
							return;
						}

						var newColor,
						    newHsv;
						if (!color && allowEmpty) {
							isEmpty = true;
						} else {
							isEmpty = false;
							newColor = tinycolor(color);
							newHsv = newColor.toHsv();

							currentHue = (newHsv.h % 360) / 360;
							currentSaturation = newHsv.s;
							currentValue = newHsv.v;
							currentAlpha = newHsv.a;
						}
						updateUI();

						if (newColor && newColor.isValid() && !ignoreFormatChange) {
							currentPreferredFormat = preferredFormat || newColor.getFormat();
						}
					}

					function get(opts) {
						opts = opts || { };

						if (allowEmpty && isEmpty) {
							return null;
						}

						return tinycolor.fromRatio({
							h : currentHue,
							s : currentSaturation,
							v : currentValue,
							a : Math.round(currentAlpha * 100) / 100
						}, {
							format : opts.format || currentPreferredFormat
						});
					}

					function isValid() {
						return !textInput.hasClass("sp-validation-error");
					}

					function move() {
						updateUI();

						callbacks.move(get());
						boundElement.trigger('move.spectrum', [get()]);
					}

					function updateUI() {

						textInput.removeClass("sp-validation-error");

						updateHelperLocations();

						// Update dragger background color (gradients take care of saturation and value).
						var flatColor = tinycolor.fromRatio({
							h : currentHue,
							s : 1,
							v : 1
						});
						dragger.css("background-color", flatColor.toHexString());

						// Get a format that alpha will be included in (hex and names ignore alpha)
						var format = currentPreferredFormat;
						if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
							if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
								format = "rgb";
							}
						}

						var realColor = get({
							format : format
						}),
						    displayColor = '';

						//reset background info for preview element
						previewElement.removeClass("sp-clear-display");
						previewElement.css('background-color', 'transparent');

						if (!realColor && allowEmpty) {
							// Update the replaced elements background with icon indicating no color selection
							previewElement.addClass("sp-clear-display");
						} else {
							var realHex = realColor.toHexString(),
							    realRgb = realColor.toRgbString();

							// Update the replaced elements background color (with actual selected color)
							if (rgbaSupport || realColor.alpha === 1) {
								previewElement.css("background-color", realRgb);
							} else {
								previewElement.css("background-color", "transparent");
								previewElement.css("filter", realColor.toFilter());
							}

							if (opts.showAlpha) {
								var rgb = realColor.toRgb();
								rgb.a = 0;
								var realAlpha = tinycolor(rgb).toRgbString();
								var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";

								if (IE) {
									alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({
										gradientType : 1
									}, realHex));
								} else {
									alphaSliderInner.css("background", "-webkit-" + gradient);
									alphaSliderInner.css("background", "-moz-" + gradient);
									alphaSliderInner.css("background", "-ms-" + gradient);
									// Use current syntax gradient on unprefixed property.
									alphaSliderInner.css("background", "linear-gradient(to right, " + realAlpha + ", " + realHex + ")");
								}
							}

							displayColor = realColor.toString(format);
						}

						// Update the text entry input as it changes happen
						if (opts.showInput) {
							textInput.val(displayColor);
						}

						if (opts.showPalette) {
							drawPalette();
						}

						drawInitial();
					}

					function updateHelperLocations() {
						var s = currentSaturation;
						var v = currentValue;

						if (allowEmpty && isEmpty) {
							//if selected color is empty, hide the helpers
							alphaSlideHelper.hide();
							slideHelper.hide();
							dragHelper.hide();
						} else {
							//make sure helpers are visible
							alphaSlideHelper.show();
							slideHelper.show();
							dragHelper.show();

							// Where to show the little circle in that displays your current selected color
							var dragX = s * dragWidth;
							var dragY = dragHeight - (v * dragHeight);
							dragX = Math.max(-dragHelperHeight, Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight));
							dragY = Math.max(-dragHelperHeight, Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight));
							dragHelper.css({
								"top" : dragY + "px",
								"left" : dragX + "px"
							});

							var alphaX = currentAlpha * alphaWidth;
							alphaSlideHelper.css({
								"left" : (alphaX - (alphaSlideHelperWidth / 2)) + "px"
							});

							// Where to show the bar that displays your current selected hue
							var slideY = (currentHue) * slideHeight;
							slideHelper.css({
								"top" : (slideY - slideHelperHeight) + "px"
							});
						}
					}

					function updateOriginalInput(fireCallback) {
						var color = get(),
						    displayColor = '',
						    hasChanged = !tinycolor.equals(color, colorOnShow);

						if (color) {
							displayColor = color.toString(currentPreferredFormat);
							// Update the selection palette with the current color
							addColorToSelectionPalette(color);
						}

						if (isInput) {
							boundElement.val(displayColor);
						}

						if (fireCallback && hasChanged) {
							callbacks.change(color);
							boundElement.trigger('change', [color]);
						}
					}

					function reflow() {
						dragWidth = dragger.width();
						dragHeight = dragger.height();
						dragHelperHeight = dragHelper.height();
						slideWidth = slider.width();
						slideHeight = slider.height();
						slideHelperHeight = slideHelper.height();
						alphaWidth = alphaSlider.width();
						alphaSlideHelperWidth = alphaSlideHelper.width();

						if (!flat) {
							container.css("position", "absolute");
							container.offset(getOffset(container, offsetElement));
						}

						updateHelperLocations();

						if (opts.showPalette) {
							drawPalette();
						}

						boundElement.trigger('reflow.spectrum');
					}

					function destroy() {
						boundElement.show();
						offsetElement.unbind("click.spectrum touchstart.spectrum");
						container.remove();
						replacer.remove();
						spectrums[spect.id] = null;
					}

					function option(optionName, optionValue) {
						if (optionName === undefined) {
							return $.extend({}, opts);
						}
						if (optionValue === undefined) {
							return opts[optionName];
						}

						opts[optionName] = optionValue;
						applyOptions();
					}

					function enable() {
						disabled = false;
						boundElement.attr("disabled", false);
						offsetElement.removeClass("sp-disabled");
					}

					function disable() {
						hide();
						disabled = true;
						boundElement.attr("disabled", true);
						offsetElement.addClass("sp-disabled");
					}

					initialize();

					var spect = {
						show : show,
						hide : hide,
						toggle : toggle,
						reflow : reflow,
						option : option,
						enable : enable,
						disable : disable,
						set : function(c) {
							set(c);
							updateOriginalInput();
						},
						get : get,
						destroy : destroy,
						container : container
					};

					spect.id = spectrums.push(spect) - 1;

					return spect;
				}

				/**
				 * checkOffset - get the offset below/above and left/right element depending on screen position
				 * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
				 */
				function getOffset(picker, input) {
					var extraY = 0;
					var dpWidth = picker.outerWidth();
					var dpHeight = picker.outerHeight();
					var inputHeight = input.outerHeight();
					var doc = picker[0].ownerDocument;
					var docElem = doc.documentElement;
					var viewWidth = docElem.clientWidth + $(doc).scrollLeft();
					var viewHeight = docElem.clientHeight + $(doc).scrollTop();
					var offset = input.offset();
					offset.top += inputHeight;

					offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ? Math.abs(offset.left + dpWidth - viewWidth) : 0);

					offset.top -= Math.min(offset.top, ((offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ? Math.abs(dpHeight + inputHeight - extraY) : extraY));

					return offset;
				}

				/**
				 * noop - do nothing
				 */
				function noop() {

				}

				/**
				 * stopPropagation - makes the code only doing this a little easier to read in line
				 */
				function stopPropagation(e) {
					e.stopPropagation();
				}

				/**
				 * Create a function bound to a given object
				 * Thanks to underscore.js
				 */
				function bind(func, obj) {
					var slice = Array.prototype.slice;
					var args = slice.call(arguments, 2);
					return function() {
						return func.apply(obj, args.concat(slice.call(arguments)));
					};
				}

				/**
				 * Lightweight drag helper.  Handles containment within the element, so that
				 * when dragging, the x is within [0,element.width] and y is within [0,element.height]
				 */
				function draggable(element, onmove, onstart, onstop) {
					onmove = onmove ||
					function() {
					};
					onstart = onstart ||
					function() {
					};
					onstop = onstop ||
					function() {
					};
					var doc = document;
					var dragging = false;
					var offset = {};
					var maxHeight = 0;
					var maxWidth = 0;
					var hasTouch = ('ontouchstart' in window);

					var duringDragEvents = {};
					duringDragEvents["selectstart"] = prevent;
					duringDragEvents["dragstart"] = prevent;
					duringDragEvents["touchmove mousemove"] = move;
					duringDragEvents["touchend mouseup"] = stop;

					function prevent(e) {
						if (e.stopPropagation) {
							e.stopPropagation();
						}
						if (e.preventDefault) {
							e.preventDefault();
						}
						e.returnValue = false;
					}

					function move(e) {
						if (dragging) {
							// Mouseup happened outside of window
							if (IE && doc.documentMode < 9 && !e.button) {
								return stop();
							}

							var touches = e.originalEvent.touches;
							var pageX = touches ? touches[0].pageX : e.pageX;
							var pageY = touches ? touches[0].pageY : e.pageY;

							var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
							var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

							if (hasTouch) {
								// Stop scrolling in iOS
								prevent(e);
							}

							onmove.apply(element, [dragX, dragY, e]);
						}
					}

					function start(e) {
						var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

						if (!rightclick && !dragging) {
							if (onstart.apply(element, arguments) !== false) {
								dragging = true;
								maxHeight = $(element).height();
								maxWidth = $(element).width();
								offset = $(element).offset();

								$(doc).bind(duringDragEvents);
								$(doc.body).addClass("sp-dragging");

								if (!hasTouch) {
									move(e);
								}

								prevent(e);
							}
						}
					}

					function stop() {
						if (dragging) {
							$(doc).unbind(duringDragEvents);
							$(doc.body).removeClass("sp-dragging");
							onstop.apply(element, arguments);
						}
						dragging = false;
					}


					$(element).bind("touchstart mousedown", start);
				}

				function throttle(func, wait, debounce) {
					var timeout;
					return function() {
						var context = this,
						    args =
						    arguments;
						var throttler = function() {
							timeout = null;
							func.apply(context, args);
						};
						if (debounce)
							clearTimeout(timeout);
						if (debounce || !timeout)
							timeout = setTimeout(throttler, wait);
					};
				}

				/**
				 * Define a jQuery plugin
				 */
				var dataID = "spectrum.id";
				$.fn.spectrum = function(opts, extra) {

					if ( typeof opts == "string") {

						var returnValue = this;
						var args = Array.prototype.slice.call(arguments, 1);

						this.each(function() {
							var spect = spectrums[$(this).data(dataID)];
							if (spect) {
								var method = spect[opts];
								if (!method) {
									throw new Error("Spectrum: no such method: '" + opts + "'");
								}

								if (opts == "get") {
									returnValue = spect.get();
								} else if (opts == "container") {
									returnValue = spect.container;
								} else if (opts == "option") {
									returnValue = spect.option.apply(spect, args);
								} else if (opts == "destroy") {
									spect.destroy();
									$(this).removeData(dataID);
								} else {
									method.apply(spect, args);
								}
							}
						});

						return returnValue;
					}

					// Initializing a new instance of spectrum
					return this.spectrum("destroy").each(function() {
						var options = $.extend({}, opts, $(this).data());
						var spect = spectrum(this, options);
						$(this).data(dataID, spect.id);
					});
				};

				$.fn.spectrum.load = true;
				$.fn.spectrum.loadOpts = {};
				$.fn.spectrum.draggable = draggable;
				$.fn.spectrum.defaults = defaultOpts;

				$.spectrum = { };
				$.spectrum.localization = { };
				$.spectrum.palettes = { };

				$.fn.spectrum.processNativeColorInputs = function() {
					if (!inputTypeColorSupport) {
						$("input[type=color]").spectrum({
							preferredFormat : "hex6"
						});
					}
				};

				// TinyColor v1.0.0
				// https://github.com/bgrins/TinyColor
				// Brian Grinstead, MIT License

				(function() {

					var trimLeft = /^[\s,#]+/,
					    trimRight = /\s+$/,
					    tinyCounter = 0,
					    math =
					    Math,
					    mathRound = math.round,
					    mathMin = math.min,
					    mathMax = math.max,
					    mathRandom = math.random;

					var tinycolor = function tinycolor(color, opts) {

						color = (color) ? color : '';
						opts = opts || { };

						// If input is already a tinycolor, return itself
						if ( color instanceof tinycolor) {
							return color;
						}
						// If we are called as a function, call using new instead
						if (!(this instanceof tinycolor)) {
							return new tinycolor(color, opts);
						}

						var rgb = inputToRGB(color);
						this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
						this._gradientType = opts.gradientType;

						// Don't let the range of [0,255] come back in [0,1].
						// Potentially lose a little bit of precision here, but will fix issues where
						// .5 gets interpreted as half of the total, instead of half of 1
						// If it was supposed to be 128, this was already taken care of by `inputToRgb`
						if (this._r < 1) {
							this._r = mathRound(this._r);
						}
						if (this._g < 1) {
							this._g = mathRound(this._g);
						}
						if (this._b < 1) {
							this._b = mathRound(this._b);
						}

						this._ok = rgb.ok;
						this._tc_id = tinyCounter++;
					};

					tinycolor.prototype = {
						isDark : function() {
							return this.getBrightness() < 128;
						},
						isLight : function() {
							return !this.isDark();
						},
						isValid : function() {
							return this._ok;
						},
						getFormat : function() {
							return this._format;
						},
						getAlpha : function() {
							return this._a;
						},
						getBrightness : function() {
							var rgb = this.toRgb();
							return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
						},
						setAlpha : function(value) {
							this._a = boundAlpha(value);
							this._roundA = mathRound(100 * this._a) / 100;
							return this;
						},
						toHsv : function() {
							var hsv = rgbToHsv(this._r, this._g, this._b);
							return {
								h : hsv.h * 360,
								s : hsv.s,
								v : hsv.v,
								a : this._a
							};
						},
						toHsvString : function() {
							var hsv = rgbToHsv(this._r, this._g, this._b);
							var h = mathRound(hsv.h * 360),
							    s = mathRound(hsv.s * 100),
							    v = mathRound(hsv.v * 100);
							return (this._a == 1) ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
						},
						toHsl : function() {
							var hsl = rgbToHsl(this._r, this._g, this._b);
							return {
								h : hsl.h * 360,
								s : hsl.s,
								l : hsl.l,
								a : this._a
							};
						},
						toHslString : function() {
							var hsl = rgbToHsl(this._r, this._g, this._b);
							var h = mathRound(hsl.h * 360),
							    s = mathRound(hsl.s * 100),
							    l = mathRound(hsl.l * 100);
							return (this._a == 1) ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
						},
						toHex : function(allow3Char) {
							return rgbToHex(this._r, this._g, this._b, allow3Char);
						},
						toHexString : function(allow3Char) {
							return '#' + this.toHex(allow3Char);
						},
						toHex8 : function() {
							return rgbaToHex(this._r, this._g, this._b, this._a);
						},
						toHex8String : function() {
							return '#' + this.toHex8();
						},
						toRgb : function() {
							return {
								r : mathRound(this._r),
								g : mathRound(this._g),
								b : mathRound(this._b),
								a : this._a
							};
						},
						toRgbString : function() {
							return (this._a == 1) ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
						},
						toPercentageRgb : function() {
							return {
								r : mathRound(bound01(this._r, 255) * 100) + "%",
								g : mathRound(bound01(this._g, 255) * 100) + "%",
								b : mathRound(bound01(this._b, 255) * 100) + "%",
								a : this._a
							};
						},
						toPercentageRgbString : function() {
							return (this._a == 1) ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
						},
						toName : function() {
							if (this._a === 0) {
								return "transparent";
							}

							if (this._a < 1) {
								return false;
							}

							return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
						},
						toFilter : function(secondColor) {
							var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
							var secondHex8String = hex8String;
							var gradientType = this._gradientType ? "GradientType = 1, " : "";

							if (secondColor) {
								var s = tinycolor(secondColor);
								secondHex8String = s.toHex8String();
							}

							return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
						},
						toString : function(format) {
							var formatSet = !!format;
							format = format || this._format;

							var formattedString = false;
							var hasAlpha = this._a < 1 && this._a >= 0;
							var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

							if (needsAlphaFormat) {
								// Special case for "transparent", all other non-alpha formats
								// will return rgba when there is transparency.
								if (format === "name" && this._a === 0) {
									return this.toName();
								}
								return this.toRgbString();
							}
							if (format === "rgb") {
								formattedString = this.toRgbString();
							}
							if (format === "prgb") {
								formattedString = this.toPercentageRgbString();
							}
							if (format === "hex" || format === "hex6") {
								formattedString = this.toHexString();
							}
							if (format === "hex3") {
								formattedString = this.toHexString(true);
							}
							if (format === "hex8") {
								formattedString = this.toHex8String();
							}
							if (format === "name") {
								formattedString = this.toName();
							}
							if (format === "hsl") {
								formattedString = this.toHslString();
							}
							if (format === "hsv") {
								formattedString = this.toHsvString();
							}

							return formattedString || this.toHexString();
						},

						_applyModification : function(fn, args) {
							var color = fn.apply(null, [this].concat([].slice.call(args)));
							this._r = color._r;
							this._g = color._g;
							this._b = color._b;
							this.setAlpha(color._a);
							return this;
						},
						lighten : function() {
							return this._applyModification(lighten, arguments);
						},
						brighten : function() {
							return this._applyModification(brighten, arguments);
						},
						darken : function() {
							return this._applyModification(darken, arguments);
						},
						desaturate : function() {
							return this._applyModification(desaturate, arguments);
						},
						saturate : function() {
							return this._applyModification(saturate, arguments);
						},
						greyscale : function() {
							return this._applyModification(greyscale, arguments);
						},
						spin : function() {
							return this._applyModification(spin, arguments);
						},

						_applyCombination : function(fn, args) {
							return fn.apply(null, [this].concat([].slice.call(args)));
						},
						analogous : function() {
							return this._applyCombination(analogous, arguments);
						},
						complement : function() {
							return this._applyCombination(complement, arguments);
						},
						monochromatic : function() {
							return this._applyCombination(monochromatic, arguments);
						},
						splitcomplement : function() {
							return this._applyCombination(splitcomplement, arguments);
						},
						triad : function() {
							return this._applyCombination(triad, arguments);
						},
						tetrad : function() {
							return this._applyCombination(tetrad, arguments);
						}
					};

					// If input is an object, force 1 into "1.0" to handle ratios properly
					// String input requires "1.0" as input, so 1 will be treated as 1
					tinycolor.fromRatio = function(color, opts) {
						if ( typeof color == "object") {
							var newColor = {};
							for (var i in color) {
								if (color.hasOwnProperty(i)) {
									if (i === "a") {
										newColor[i] = color[i];
									} else {
										newColor[i] = convertToPercentage(color[i]);
									}
								}
							}
							color = newColor;
						}

						return tinycolor(color, opts);
					};

					// Given a string or object, convert that input to RGB
					// Possible string inputs:
					//
					//     "red"
					//     "#f00" or "f00"
					//     "#ff0000" or "ff0000"
					//     "#ff000000" or "ff000000"
					//     "rgb 255 0 0" or "rgb (255, 0, 0)"
					//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
					//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
					//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
					//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
					//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
					//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
					//
					function inputToRGB(color) {

						var rgb = {
							r : 0,
							g : 0,
							b : 0
						};
						var a = 1;
						var ok = false;
						var format = false;

						if ( typeof color == "string") {
							color = stringInputToObject(color);
						}

						if ( typeof color == "object") {
							if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
								rgb = rgbToRgb(color.r, color.g, color.b);
								ok = true;
								format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
							} else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
								color.s = convertToPercentage(color.s);
								color.v = convertToPercentage(color.v);
								rgb = hsvToRgb(color.h, color.s, color.v);
								ok = true;
								format = "hsv";
							} else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
								color.s = convertToPercentage(color.s);
								color.l = convertToPercentage(color.l);
								rgb = hslToRgb(color.h, color.s, color.l);
								ok = true;
								format = "hsl";
							}

							if (color.hasOwnProperty("a")) {
								a = color.a;
							}
						}

						a = boundAlpha(a);

						return {
							ok : ok,
							format : color.format || format,
							r : mathMin(255, mathMax(rgb.r, 0)),
							g : mathMin(255, mathMax(rgb.g, 0)),
							b : mathMin(255, mathMax(rgb.b, 0)),
							a : a
						};
					}

					// Conversion Functions
					// --------------------

					// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
					// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

					// `rgbToRgb`
					// Handle bounds / percentage checking to conform to CSS color spec
					// <http://www.w3.org/TR/css3-color/>
					// *Assumes:* r, g, b in [0, 255] or [0, 1]
					// *Returns:* { r, g, b } in [0, 255]
					function rgbToRgb(r, g, b) {
						return {
							r : bound01(r, 255) * 255,
							g : bound01(g, 255) * 255,
							b : bound01(b, 255) * 255
						};
					}

					// `rgbToHsl`
					// Converts an RGB color value to HSL.
					// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
					// *Returns:* { h, s, l } in [0,1]
					function rgbToHsl(r, g, b) {

						r = bound01(r, 255);
						g = bound01(g, 255);
						b = bound01(b, 255);

						var max = mathMax(r, g, b),
						    min = mathMin(r, g, b);
						var h,
						    s,
						    l = (max + min) / 2;

						if (max == min) {
							h = s = 0;
							// achromatic
						} else {
							var d = max - min;
							s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
							switch(max) {
							case r:
								h = (g - b) / d + (g < b ? 6 : 0);
								break;
							case g:
								h = (b - r) / d + 2;
								break;
							case b:
								h = (r - g) / d + 4;
								break;
							}

							h /= 6;
						}

						return {
							h : h,
							s : s,
							l : l
						};
					}

					// `hslToRgb`
					// Converts an HSL color value to RGB.
					// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
					// *Returns:* { r, g, b } in the set [0, 255]
					function hslToRgb(h, s, l) {
						var r,
						    g,
						    b;

						h = bound01(h, 360);
						s = bound01(s, 100);
						l = bound01(l, 100);

						function hue2rgb(p, q, t) {
							if (t < 0)
								t += 1;
							if (t > 1)
								t -= 1;
							if (t < 1 / 6)
								return p + (q - p) * 6 * t;
							if (t < 1 / 2)
								return q;
							if (t < 2 / 3)
								return p + (q - p) * (2 / 3 - t) * 6;
							return p;
						}

						if (s === 0) {
							r = g = b = l;
							// achromatic
						} else {
							var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
							var p = 2 * l - q;
							r = hue2rgb(p, q, h + 1 / 3);
							g = hue2rgb(p, q, h);
							b = hue2rgb(p, q, h - 1 / 3);
						}

						return {
							r : r * 255,
							g : g * 255,
							b : b * 255
						};
					}

					// `rgbToHsv`
					// Converts an RGB color value to HSV
					// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
					// *Returns:* { h, s, v } in [0,1]
					function rgbToHsv(r, g, b) {

						r = bound01(r, 255);
						g = bound01(g, 255);
						b = bound01(b, 255);

						var max = mathMax(r, g, b),
						    min = mathMin(r, g, b);
						var h,
						    s,
						    v =
						    max;

						var d = max - min;
						s = max === 0 ? 0 : d / max;

						if (max == min) {
							h = 0;
							// achromatic
						} else {
							switch(max) {
							case r:
								h = (g - b) / d + (g < b ? 6 : 0);
								break;
							case g:
								h = (b - r) / d + 2;
								break;
							case b:
								h = (r - g) / d + 4;
								break;
							}
							h /= 6;
						}
						return {
							h : h,
							s : s,
							v : v
						};
					}

					// `hsvToRgb`
					// Converts an HSV color value to RGB.
					// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
					// *Returns:* { r, g, b } in the set [0, 255]
					function hsvToRgb(h, s, v) {

						h = bound01(h, 360) * 6;
						s = bound01(s, 100);
						v = bound01(v, 100);

						var i = math.floor(h),
						    f = h - i,
						    p = v * (1 - s),
						    q = v * (1 - f * s),
						    t = v * (1 - (1 - f) * s),
						    mod = i % 6,
						    r = [v, q, p, p, t, v][mod],
						    g = [t, v, v, q, p, p][mod],
						    b = [p, p, t, v, v, q][mod];

						return {
							r : r * 255,
							g : g * 255,
							b : b * 255
						};
					}

					// `rgbToHex`
					// Converts an RGB color to hex
					// Assumes r, g, and b are contained in the set [0, 255]
					// Returns a 3 or 6 character hex
					function rgbToHex(r, g, b, allow3Char) {

						var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];

						// Return a 3 character hex if possible
						if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
							return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
						}

						return hex.join("");
					}

					// `rgbaToHex`
					// Converts an RGBA color plus alpha transparency to hex
					// Assumes r, g, b and a are contained in the set [0, 255]
					// Returns an 8 character hex
					function rgbaToHex(r, g, b, a) {

						var hex = [pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];

						return hex.join("");
					}

					// `equals`
					// Can be called with any tinycolor input
					tinycolor.equals = function(color1, color2) {
						if (!color1 || !color2) {
							return false;
						}
						return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
					};
					tinycolor.random = function() {
						return tinycolor.fromRatio({
							r : mathRandom(),
							g : mathRandom(),
							b : mathRandom()
						});
					};

					// Modification Functions
					// ----------------------
					// Thanks to less.js for some of the basics here
					// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

					function desaturate(color, amount) {
						amount = (amount === 0) ? 0 : (amount || 10);
						var hsl = tinycolor(color).toHsl();
						hsl.s -= amount / 100;
						hsl.s = clamp01(hsl.s);
						return tinycolor(hsl);
					}

					function saturate(color, amount) {
						amount = (amount === 0) ? 0 : (amount || 10);
						var hsl = tinycolor(color).toHsl();
						hsl.s += amount / 100;
						hsl.s = clamp01(hsl.s);
						return tinycolor(hsl);
					}

					function greyscale(color) {
						return tinycolor(color).desaturate(100);
					}

					function lighten(color, amount) {
						amount = (amount === 0) ? 0 : (amount || 10);
						var hsl = tinycolor(color).toHsl();
						hsl.l += amount / 100;
						hsl.l = clamp01(hsl.l);
						return tinycolor(hsl);
					}

					function brighten(color, amount) {
						amount = (amount === 0) ? 0 : (amount || 10);
						var rgb = tinycolor(color).toRgb();
						rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
						rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
						rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
						return tinycolor(rgb);
					}

					function darken(color, amount) {
						amount = (amount === 0) ? 0 : (amount || 10);
						var hsl = tinycolor(color).toHsl();
						hsl.l -= amount / 100;
						hsl.l = clamp01(hsl.l);
						return tinycolor(hsl);
					}

					// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
					// Values outside of this range will be wrapped into this range.
					function spin(color, amount) {
						var hsl = tinycolor(color).toHsl();
						var hue = (mathRound(hsl.h) + amount) % 360;
						hsl.h = hue < 0 ? 360 + hue : hue;
						return tinycolor(hsl);
					}

					// Combination Functions
					// ---------------------
					// Thanks to jQuery xColor for some of the ideas behind these
					// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

					function complement(color) {
						var hsl = tinycolor(color).toHsl();
						hsl.h = (hsl.h + 180) % 360;
						return tinycolor(hsl);
					}

					function triad(color) {
						var hsl = tinycolor(color).toHsl();
						var h = hsl.h;
						return [tinycolor(color), tinycolor({
							h : (h + 120) % 360,
							s : hsl.s,
							l : hsl.l
						}), tinycolor({
							h : (h + 240) % 360,
							s : hsl.s,
							l : hsl.l
						})];
					}

					function tetrad(color) {
						var hsl = tinycolor(color).toHsl();
						var h = hsl.h;
						return [tinycolor(color), tinycolor({
							h : (h + 90) % 360,
							s : hsl.s,
							l : hsl.l
						}), tinycolor({
							h : (h + 180) % 360,
							s : hsl.s,
							l : hsl.l
						}), tinycolor({
							h : (h + 270) % 360,
							s : hsl.s,
							l : hsl.l
						})];
					}

					function splitcomplement(color) {
						var hsl = tinycolor(color).toHsl();
						var h = hsl.h;
						return [tinycolor(color), tinycolor({
							h : (h + 72) % 360,
							s : hsl.s,
							l : hsl.l
						}), tinycolor({
							h : (h + 216) % 360,
							s : hsl.s,
							l : hsl.l
						})];
					}

					function analogous(color, results, slices) {
						results = results || 6;
						slices = slices || 30;

						var hsl = tinycolor(color).toHsl();
						var part = 360 / slices;
						var ret = [tinycolor(color)];

						for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
							hsl.h = (hsl.h + part) % 360;
							ret.push(tinycolor(hsl));
						}
						return ret;
					}

					function monochromatic(color, results) {
						results = results || 6;
						var hsv = tinycolor(color).toHsv();
						var h = hsv.h,
						    s = hsv.s,
						    v = hsv.v;
						var ret = [];
						var modification = 1 / results;

						while (results--) {
							ret.push(tinycolor({
								h : h,
								s : s,
								v : v
							}));
							v = (v + modification) % 1;
						}

						return ret;
					}

					// Utility Functions
					// ---------------------

					tinycolor.mix = function(color1, color2, amount) {
						amount = (amount === 0) ? 0 : (amount || 50);

						var rgb1 = tinycolor(color1).toRgb();
						var rgb2 = tinycolor(color2).toRgb();

						var p = amount / 100;
						var w = p * 2 - 1;
						var a = rgb2.a - rgb1.a;

						var w1;

						if (w * a == -1) {
							w1 = w;
						} else {
							w1 = (w + a) / (1 + w * a);
						}

						w1 = (w1 + 1) / 2;

						var w2 = 1 - w1;

						var rgba = {
							r : rgb2.r * w1 + rgb1.r * w2,
							g : rgb2.g * w1 + rgb1.g * w2,
							b : rgb2.b * w1 + rgb1.b * w2,
							a : rgb2.a * p + rgb1.a * (1 - p)
						};

						return tinycolor(rgba);
					};

					// Readability Functions
					// ---------------------
					// <http://www.w3.org/TR/AERT#color-contrast>

					// `readability`
					// Analyze the 2 colors and returns an object with the following properties:
					//    `brightness`: difference in brightness between the two colors
					//    `color`: difference in color/hue between the two colors
					tinycolor.readability = function(color1, color2) {
						var c1 = tinycolor(color1);
						var c2 = tinycolor(color2);
						var rgb1 = c1.toRgb();
						var rgb2 = c2.toRgb();
						var brightnessA = c1.getBrightness();
						var brightnessB = c2.getBrightness();
						var colorDiff = (Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) + Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) + Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b)
						);

						return {
							brightness : Math.abs(brightnessA - brightnessB),
							color : colorDiff
						};
					};

					// `readable`
					// http://www.w3.org/TR/AERT#color-contrast
					// Ensure that foreground and background color combinations provide sufficient contrast.
					// *Example*
					//    tinycolor.isReadable("#000", "#111") => false
					tinycolor.isReadable = function(color1, color2) {
						var readability = tinycolor.readability(color1, color2);
						return readability.brightness > 125 && readability.color > 500;
					};

					// `mostReadable`
					// Given a base color and a list of possible foreground or background
					// colors for that base, returns the most readable color.
					// *Example*
					//    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
					tinycolor.mostReadable = function(baseColor, colorList) {
						var bestColor = null;
						var bestScore = 0;
						var bestIsReadable = false;
						for (var i = 0; i < colorList.length; i++) {

							// We normalize both around the "acceptable" breaking point,
							// but rank brightness constrast higher than hue.

							var readability = tinycolor.readability(baseColor, colorList[i]);
							var readable = readability.brightness > 125 && readability.color > 500;
							var score = 3 * (readability.brightness / 125) + (readability.color / 500);

							if ((readable && !bestIsReadable) || (readable && bestIsReadable && score > bestScore) || ((!readable) && (!bestIsReadable) && score > bestScore)) {
								bestIsReadable = readable;
								bestScore = score;
								bestColor = tinycolor(colorList[i]);
							}
						}
						return bestColor;
					};

					// Big List of Colors
					// ------------------
					// <http://www.w3.org/TR/css3-color/#svg-color>
					var names = tinycolor.names = {
						aliceblue : "f0f8ff",
						antiquewhite : "faebd7",
						aqua : "0ff",
						aquamarine : "7fffd4",
						azure : "f0ffff",
						beige : "f5f5dc",
						bisque : "ffe4c4",
						black : "000",
						blanchedalmond : "ffebcd",
						blue : "00f",
						blueviolet : "8a2be2",
						brown : "a52a2a",
						burlywood : "deb887",
						burntsienna : "ea7e5d",
						cadetblue : "5f9ea0",
						chartreuse : "7fff00",
						chocolate : "d2691e",
						coral : "ff7f50",
						cornflowerblue : "6495ed",
						cornsilk : "fff8dc",
						crimson : "dc143c",
						cyan : "0ff",
						darkblue : "00008b",
						darkcyan : "008b8b",
						darkgoldenrod : "b8860b",
						darkgray : "a9a9a9",
						darkgreen : "006400",
						darkgrey : "a9a9a9",
						darkkhaki : "bdb76b",
						darkmagenta : "8b008b",
						darkolivegreen : "556b2f",
						darkorange : "ff8c00",
						darkorchid : "9932cc",
						darkred : "8b0000",
						darksalmon : "e9967a",
						darkseagreen : "8fbc8f",
						darkslateblue : "483d8b",
						darkslategray : "2f4f4f",
						darkslategrey : "2f4f4f",
						darkturquoise : "00ced1",
						darkviolet : "9400d3",
						deeppink : "ff1493",
						deepskyblue : "00bfff",
						dimgray : "696969",
						dimgrey : "696969",
						dodgerblue : "1e90ff",
						firebrick : "b22222",
						floralwhite : "fffaf0",
						forestgreen : "228b22",
						fuchsia : "f0f",
						gainsboro : "dcdcdc",
						ghostwhite : "f8f8ff",
						gold : "ffd700",
						goldenrod : "daa520",
						gray : "808080",
						green : "008000",
						greenyellow : "adff2f",
						grey : "808080",
						honeydew : "f0fff0",
						hotpink : "ff69b4",
						indianred : "cd5c5c",
						indigo : "4b0082",
						ivory : "fffff0",
						khaki : "f0e68c",
						lavender : "e6e6fa",
						lavenderblush : "fff0f5",
						lawngreen : "7cfc00",
						lemonchiffon : "fffacd",
						lightblue : "add8e6",
						lightcoral : "f08080",
						lightcyan : "e0ffff",
						lightgoldenrodyellow : "fafad2",
						lightgray : "d3d3d3",
						lightgreen : "90ee90",
						lightgrey : "d3d3d3",
						lightpink : "ffb6c1",
						lightsalmon : "ffa07a",
						lightseagreen : "20b2aa",
						lightskyblue : "87cefa",
						lightslategray : "789",
						lightslategrey : "789",
						lightsteelblue : "b0c4de",
						lightyellow : "ffffe0",
						lime : "0f0",
						limegreen : "32cd32",
						linen : "faf0e6",
						magenta : "f0f",
						maroon : "800000",
						mediumaquamarine : "66cdaa",
						mediumblue : "0000cd",
						mediumorchid : "ba55d3",
						mediumpurple : "9370db",
						mediumseagreen : "3cb371",
						mediumslateblue : "7b68ee",
						mediumspringgreen : "00fa9a",
						mediumturquoise : "48d1cc",
						mediumvioletred : "c71585",
						midnightblue : "191970",
						mintcream : "f5fffa",
						mistyrose : "ffe4e1",
						moccasin : "ffe4b5",
						navajowhite : "ffdead",
						navy : "000080",
						oldlace : "fdf5e6",
						olive : "808000",
						olivedrab : "6b8e23",
						orange : "ffa500",
						orangered : "ff4500",
						orchid : "da70d6",
						palegoldenrod : "eee8aa",
						palegreen : "98fb98",
						paleturquoise : "afeeee",
						palevioletred : "db7093",
						papayawhip : "ffefd5",
						peachpuff : "ffdab9",
						peru : "cd853f",
						pink : "ffc0cb",
						plum : "dda0dd",
						powderblue : "b0e0e6",
						purple : "800080",
						red : "f00",
						rosybrown : "bc8f8f",
						royalblue : "4169e1",
						saddlebrown : "8b4513",
						salmon : "fa8072",
						sandybrown : "f4a460",
						seagreen : "2e8b57",
						seashell : "fff5ee",
						sienna : "a0522d",
						silver : "c0c0c0",
						skyblue : "87ceeb",
						slateblue : "6a5acd",
						slategray : "708090",
						slategrey : "708090",
						snow : "fffafa",
						springgreen : "00ff7f",
						steelblue : "4682b4",
						tan : "d2b48c",
						teal : "008080",
						thistle : "d8bfd8",
						tomato : "ff6347",
						turquoise : "40e0d0",
						violet : "ee82ee",
						wheat : "f5deb3",
						white : "fff",
						whitesmoke : "f5f5f5",
						yellow : "ff0",
						yellowgreen : "9acd32"
					};

					// Make it easy to access colors via `hexNames[hex]`
					var hexNames = tinycolor.hexNames = flip(names);

					// Utilities
					// ---------

					// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
					function flip(o) {
						var flipped = { };
						for (var i in o) {
							if (o.hasOwnProperty(i)) {
								flipped[o[i]] = i;
							}
						}
						return flipped;
					}

					// Return a valid alpha value [0,1] with all invalid values being set to 1
					function boundAlpha(a) {
						a = parseFloat(a);

						if (isNaN(a) || a < 0 || a > 1) {
							a = 1;
						}

						return a;
					}

					// Take input from [0, n] and return it as [0, 1]
					function bound01(n, max) {
						if (isOnePointZero(n)) {
							n = "100%";
						}

						var processPercent = isPercentage(n);
						n = mathMin(max, mathMax(0, parseFloat(n)));

						// Automatically convert percentage into number
						if (processPercent) {
							n = parseInt(n * max, 10) / 100;
						}

						// Handle floating point rounding errors
						if ((math.abs(n - max) < 0.000001)) {
							return 1;
						}

						// Convert into [0, 1] range if it isn't already
						return (n % max) / parseFloat(max);
					}

					// Force a number between 0 and 1
					function clamp01(val) {
						return mathMin(1, mathMax(0, val));
					}

					// Parse a base-16 hex value into a base-10 integer
					function parseIntFromHex(val) {
						return parseInt(val, 16);
					}

					// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
					// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
					function isOnePointZero(n) {
						return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
					}

					// Check to see if string passed in is a percentage
					function isPercentage(n) {
						return typeof n === "string" && n.indexOf('%') != -1;
					}

					// Force a hex value to have 2 characters
					function pad2(c) {
						return c.length == 1 ? '0' + c : '' + c;
					}

					// Replace a decimal with it's percentage value
					function convertToPercentage(n) {
						if (n <= 1) {
							n = (n * 100) + "%";
						}

						return n;
					}

					// Converts a decimal to a hex value
					function convertDecimalToHex(d) {
						return Math.round(parseFloat(d) * 255).toString(16);
					}

					// Converts a hex value to a decimal
					function convertHexToDecimal(h) {
						return (parseIntFromHex(h) / 255);
					}

					var matchers = (function() {

						// <http://www.w3.org/TR/css3-values/#integers>
						var CSS_INTEGER = "[-\\+]?\\d+%?";

						// <http://www.w3.org/TR/css3-values/#number-value>
						var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

						// Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
						var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

						// Actual matching.
						// Parentheses and commas are optional, but not required.
						// Whitespace can take the place of commas or opening paren
						var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
						var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

						return {
							rgb : new RegExp("rgb" + PERMISSIVE_MATCH3),
							rgba : new RegExp("rgba" + PERMISSIVE_MATCH4),
							hsl : new RegExp("hsl" + PERMISSIVE_MATCH3),
							hsla : new RegExp("hsla" + PERMISSIVE_MATCH4),
							hsv : new RegExp("hsv" + PERMISSIVE_MATCH3),
							hex3 : /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
							hex6 : /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
							hex8 : /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
						};
					})();

					// `stringInputToObject`
					// Permissive string parsing.  Take in a number of formats, and output an object
					// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
					function stringInputToObject(color) {

						color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
						var named = false;
						if (names[color]) {
							color = names[color];
							named = true;
						} else if (color == 'transparent') {
							return {
								r : 0,
								g : 0,
								b : 0,
								a : 0,
								format : "name"
							};
						}

						// Try to match string input using regular expressions.
						// Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
						// Just return an object and let the conversion functions handle that.
						// This way the result will be the same whether the tinycolor is initialized with string or object.
						var match;
						if (( match = matchers.rgb.exec(color))) {
							return {
								r : match[1],
								g : match[2],
								b : match[3]
							};
						}
						if (( match = matchers.rgba.exec(color))) {
							return {
								r : match[1],
								g : match[2],
								b : match[3],
								a : match[4]
							};
						}
						if (( match = matchers.hsl.exec(color))) {
							return {
								h : match[1],
								s : match[2],
								l : match[3]
							};
						}
						if (( match = matchers.hsla.exec(color))) {
							return {
								h : match[1],
								s : match[2],
								l : match[3],
								a : match[4]
							};
						}
						if (( match = matchers.hsv.exec(color))) {
							return {
								h : match[1],
								s : match[2],
								v : match[3]
							};
						}
						if (( match = matchers.hex8.exec(color))) {
							return {
								a : convertHexToDecimal(match[1]),
								r : parseIntFromHex(match[2]),
								g : parseIntFromHex(match[3]),
								b : parseIntFromHex(match[4]),
								format : named ? "name" : "hex8"
							};
						}
						if (( match = matchers.hex6.exec(color))) {
							return {
								r : parseIntFromHex(match[1]),
								g : parseIntFromHex(match[2]),
								b : parseIntFromHex(match[3]),
								format : named ? "name" : "hex"
							};
						}
						if (( match = matchers.hex3.exec(color))) {
							return {
								r : parseIntFromHex(match[1] + '' + match[1]),
								g : parseIntFromHex(match[2] + '' + match[2]),
								b : parseIntFromHex(match[3] + '' + match[3]),
								format : named ? "name" : "hex"
							};
						}

						return false;
					}


					window.tinycolor = tinycolor;
				})();

				$(function() {
					if ($.fn.spectrum.load) {
						$.fn.spectrum.processNativeColorInputs();
					}
				});

			})(window, jQuery);

		</script>

		<!-- custom map script -->
		<script>
			//Create a Layer Group for the circle and transparent markers
			var colorMarkers = new L.LayerGroup();

			var osm = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				maxZoom : 22,
				attribution : 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="http://cloudmade.com">CloudMade</a>'
			});

			// use custom map protocol to have map tiles rendered on the fly (replace the openstreetmap bit with: 'map:{z}/{x}/{y}.png' to get this working in MapComposer)
			var new_tiles = L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
				maxZoom : 22
			});

			var map = L.map('map', {
				center : new L.LatLng(45.52, 122.68),
				zoom : 4,
				layers : [osm, new_tiles]
			});

			//Set marker icon options
			//Makes a transparent (invisible) marker that is located on top of the circle marker
			var myIcon = L.icon({
				iconUrl : 'markerClear.png',
				iconAnchor : [10, 10],
			});

			//Set marker options
			var markerOptions = {
				icon : myIcon,
				draggable : true
			};

			var circleOptions = {
				opacity : 1,
				fillOpacity : 1,
				color : '000000'
			};

			//Define the color picker (uses spectrum.js)
			function openColorPicker(circleMarker) {
				//Color picker with some options configured (see http://bgrins.github.io/spectrum/)
				alert("hello jane");
				$(".custom").spectrum({
					color : circleMarker.options.color,
					showButtons : false,
					showInitial : true,
					showInput : true,
					hideAfterPaletteSelect : true,
					showPalette : true,
					palette : [["rgb(0, 0, 0)", "rgb(67, 67, 67)", "rgb(102, 102, 102)", "rgb(204, 204, 204)", "rgb(217, 217, 217)", "rgb(255, 255, 255)"], ["rgb(152, 0, 0)", "rgb(255, 0, 0)", "rgb(255, 153, 0)", "rgb(255, 255, 0)", "rgb(0, 255, 0)", "rgb(0, 255, 255)", "rgb(74, 134, 232)", "rgb(0, 0, 255)", "rgb(153, 0, 255)", "rgb(255, 0, 255)"], ["rgb(230, 184, 175)", "rgb(244, 204, 204)", "rgb(252, 229, 205)", "rgb(255, 242, 204)", "rgb(217, 234, 211)", "rgb(208, 224, 227)", "rgb(201, 218, 248)", "rgb(207, 226, 243)", "rgb(217, 210, 233)", "rgb(234, 209, 220)", "rgb(221, 126, 107)", "rgb(234, 153, 153)", "rgb(249, 203, 156)", "rgb(255, 229, 153)", "rgb(182, 215, 168)", "rgb(162, 196, 201)", "rgb(164, 194, 244)", "rgb(159, 197, 232)", "rgb(180, 167, 214)", "rgb(213, 166, 189)", "rgb(204, 65, 37)", "rgb(224, 102, 102)", "rgb(246, 178, 107)", "rgb(255, 217, 102)", "rgb(147, 196, 125)", "rgb(118, 165, 175)", "rgb(109, 158, 235)", "rgb(111, 168, 220)", "rgb(142, 124, 195)", "rgb(194, 123, 160)", "rgb(166, 28, 0)", "rgb(204, 0, 0)", "rgb(230, 145, 56)", "rgb(241, 194, 50)", "rgb(106, 168, 79)", "rgb(69, 129, 142)", "rgb(60, 120, 216)", "rgb(61, 133, 198)", "rgb(103, 78, 167)", "rgb(166, 77, 121)", "rgb(91, 15, 0)", "rgb(102, 0, 0)", "rgb(120, 63, 4)", "rgb(127, 96, 0)", "rgb(39, 78, 19)", "rgb(12, 52, 61)", "rgb(28, 69, 135)", "rgb(7, 55, 99)", "rgb(32, 18, 77)", "rgb(76, 17, 48)"]],
					//Gets the selected color as a hex string and sets the circle marker color
					change : function(color) {
						var selectedColor = color.toHexString();
						circleMarker.setStyle({
							color : selectedColor
						});
					}
				});
			}

			//Deletes a marker & its associated circle. Called by clicking the Delete button in the popup bound to the marker.
			//Clicking the Delete button calls the function and gets the marker & circleMarker IDs associated with the popup, which are used as parameters
			function deleteMarkers(markerID, circleMarkerID) {

				//Delete the things with the desired IDs:
				colorMarkers.removeLayer(markerID);
				colorMarkers.removeLayer(circleMarkerID);
			}

			//FINISH ME: Gets each circle object on the map and stores this information in an array
			//I think this really also needs to get the marker leaflet IDs though, since those locations have to be changed too, so instead of using a new array, maybe it's best to just
			//use the colorMarkers.getLayers() array and pull info from there? can ID circles b/c they have options.color, and markers don't.
			//if we need to create a new array, it should really be marker id & location, circle id, location, and color. Also, the correct marker (the one immediately preceding) needs to
			//be changed for the correct circleMarker, and I'm not sure how that would get indicated to setColors except by order.
			function getColors() {
				alert("get colors");
				alert(colorMarkers.getLayers());

				var colorMarkersArray = [];
				colorMarkersArray = colorMarkers.getLayers();
				//assigns the array of layers in colorMarkers to a variable

				var res = [];
				//a new array to hold only the circle layers

				for ( i = 0; i < colorMarkersArray.length; i++) {
					if (colorMarkersArray[i].options.color != undefined) {
						var circle = colorMarkersArray[i];
						res.push(circle._latlng.lng);
						res.push(circle._latlng.lat);
						res.push(circle.options.color);
					}
				}

				//from here, we need can then access the lat/long (xy) and color options for each member of the array, ie:
				// circleArray[0].options.color     and      circleArray[0]._latlng
				//What about the leaflet ID? circleArray[0]._leaflet_id
				/*
				console.log(circleArray[0].options.color);
				console.log(circleArray[0]._latlng.lat);
				console.log(circleArray[0]._latlng.lng);
				console.log(circleArray[0]._leaflet_id);
				*/
				//at this point, do I need an array with just these things, or can I leave circleArray as is? What else do I need to do here?*/

				return res;
			}

			//FINISH ME:
			//Also, the correct marker (the one immediately preceding) needs to
			//be changed for the correct circleMarker, and I'm not sure how that would get indicated to setColors except by order.
			function setColors(colorMarkers) {
				alert("setColors called");
				return;
				//remove colorMarkers Layer Group from map
				map.removeLayer(colorMarkers);

				//TODO: get Leaflet IDs that had colors and locations changed by the Java interface, and the actual changes

				//figure out which positions those IDs have in the colorMarkers.getLayers() array
				//if position has desired ._leaflet_id(s), change properties
				//change/set the marker & circleMarker latlng locations
				//change/set the circleMarker colors

				//Place holder values (31 and 36 are always the first marker and circleMarker if you check the coloredMarkers box first, otherwise it's 31 & 32)
				var changedMarker = 31;
				var changedCircleMarker = 36;
				var newColor = "red";

				//if getColors generates a new array, which is then altered by the Java side & returned,
				//then that array needs to be used in the for/if conditions and passed to this function.
				for ( i = 0; i < colorMarkers.getLayers().length; i++) {
					if (changedMarker == colorMarkers.getLayers()[i]._leaflet_id) {
						colorMarkers.getLayers()[i]._latlng = L.latLng(46, -145);
					}

					if (changedCircleMarker == colorMarkers.getLayers()[i]._leaflet_id) {
						colorMarkers.getLayers()[i]._latlng = L.latLng(46, -145);
					}

					if (changedCircleMarker == colorMarkers.getLayers()[i]._leaflet_id) {
						colorMarkers.getLayers()[i].setStyle({
							color : newColor
						});
					}
				}

				console.log(colorMarkers.getLayers());

				//Add colorMarkers Layer Group back to map
				map.addLayer(colorMarkers);
			}

			//TESTING setColors function using right-click on map
			map.on('contextmenu', function() {
				setColors(colorMarkers);
			});

			/*Create a new circle marker (IDW color) and a new marker (drag handler) when the map is clicked at the clicked location,
			 then add them to their respective Layer Groups*/
			map.on('click', function(e) {
				alert("start click");
				//make a draggable marker & add to the colorMarkers Layer Group
				var marker = new L.marker(e.latlng, markerOptions).addTo(colorMarkers);

				//make a circle marker & add to Layer Group
				var circleMarker = new L.circleMarker(e.latlng, circleOptions).addTo(colorMarkers);

				console.log(colorMarkers.getLayers());

				//TESTING: Calls the getColors function
				//getColors(colorMarkers);

				//define popup content:
				//initializes the color picker and links it to the jQuery color picker class
				//provides a button for deleting the marker & circleMarker pair
				//onClick function calls deleteMarkers, which takes in the leaflet IDs of the layers to be deleted
				var popupContent = "<input type='text' class='custom'/><br><br><input type='button' value='Delete' onClick='deleteMarkers(" + marker._leaflet_id + "," + circleMarker._leaflet_id + ")' />";

				//Set popup options
				var popupOptions = {
					maxWidth : 55,
					offset : [0, 3] //adjusts the anchor position
				};

				//bind a popup to the marker
				marker.bindPopup(popupContent, popupOptions).openPopup();
				alert("bind popup");

				//comment this
				marker.on('click', function() {
					alert("open picker");
					openColorPicker(circleMarker);
				});

				//comment this
				openColorPicker(circleMarker);

				//Get the starting position of the marker
				var startPosition = marker.getLatLng();

				//Get the marker position on the start of movement
				//Set the circle marker to the marker position
				marker.on('movestart', function() {
					var moveStartPosition = marker.getLatLng();
					circleMarker.setLatLng(moveStartPosition);
				});

				//Get the marker position during movement
				//Set the circle marker position to the marker position during movement
				marker.on('move', function() {
					var movePosition = marker.getLatLng();
					circleMarker.setLatLng(movePosition);
				});

				//Get the marker position at the end of movement
				//Set the circle marker to the marker position when the movement ends
				marker.on('moveend', function() {
					var endPosition = marker.getLatLng();
					circleMarker.setLatLng(endPosition);
				});

			});

			var baseMaps = {
				"OpenStreet Map" : osm
			};

			var overlayMaps = {
				"Tileset" : new_tiles,
				"colorMarkers" : colorMarkers,
			};

			L.control.layers(baseMaps, overlayMaps, {
				"collapsed" : false
			}).addTo(map);

		</script>
	</body>
</html>
